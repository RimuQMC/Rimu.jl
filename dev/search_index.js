var documenterSearchIndex = {"docs":
[{"location":"index.html#Rimu.jl-Package-Guide","page":"Guide","title":"Rimu.jl Package Guide","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Random Integrators for many-body quantum systems","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"The grand aim is to develop a toolbox for many-body quantum systems that can be represented by a Hamiltonian in second quantisation language. Currently there are tools to find the ground state with a Lanczos algorithm (using KrylovKit.jl for small Hilbert spaces), or with projector quantum Monte Carlo in the flavour of full configuration interaction quantum Monte Carlo (FCIQMC, see References). We will add tools to solve the time-dependent Schrödinger equation and Master equations for open system time evolution.","category":"page"},{"location":"index.html#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"index.html#Installing-Rimu-for-usage","page":"Guide","title":"Installing Rimu for usage","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu can be installed with the package manager directly from the github repository. Hit the ] key at the Julia REPL to get into Pkg mode and type","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"pkg> add https://github.com/joachimbrand/Rimu.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Alternatively, use","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Pkg; Pkg.add(PackageSpec(url=\"https://github.com/joachimbrand/Rimu.jl\"))","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"in order to install Rimu from a script.","category":"page"},{"location":"index.html#Installing-Rimu-for-development","page":"Guide","title":"Installing Rimu for development","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"In order to be able to edit the source code, push changes, change and make new git branches, etc., clone the git repository with git clone to a convenient location, e.g. ~/mygitpackagefolder/. Then hit the ] key at the Julia REPL to get into Pkg mode and type","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"pkg> develop ~/mygitpackagefolder/rimu.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"where the file path has to be adjusted to the location of the cloned git repository.","category":"page"},{"location":"index.html#Usage","page":"Guide","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The package is now installed and can be imported with","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Rimu","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"When planning to edit the code of the package it is advisable to use the Revise package by issuing","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"julia> using Revise","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"before using Rimu. This will track any changes made to the source code of Rimu and the changed package will be available after saving the source code (hopefully, and most of the time, without restarting the Julia REPL).","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu offers a number of tools for representing Hamiltonians (see Hamiltonians) and state vectors / wave functions (see DictVectors) as well as algorithms to find the ground state, e.g. lomc!.","category":"page"},{"location":"index.html#Scripts","page":"Guide","title":"Scripts","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"Rimu is written as a Julia package to be imported with using Rimu as described above. It supplies useful functions and types. Performing actual calculations and analysing the results is done with scripts. The folder scripts/ contains a collections of scripts that are either examples for use of the Rimu package or useful scripts for data analysis. In particular:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"scripts/BHM-example.jl is an example script that runs fciqmc on the 1D Bose-Hubbard model. A data frame with results is written to the file fciqmcdata.arrow.\ntest/script_mpi_minimum_ptp.jl demonstrates basic usage of Rimu with MPI.","category":"page"},{"location":"index.html#MPI","page":"Guide","title":"MPI","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The Rimu package can run in parallel on different processes or node and distribute work by making use of MPI, or \"message passing interface\". For example, running","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"> julia scripts/BHM-example.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"will run on one processor with the main lomc!() computation (i.e. after package loading and compilation) completing in 2.69 seconds.","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Running","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"> mpirun -np 4 julia scripts/BHM-example-mpi.jl","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"on the same hardware makes use of 4 cores and the main part completes in 1.04 seconds, a speedup factor of 2.6. This seems reasonable, given that extra work needs to be done for communicating between different processes.","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Initialising and finalising MPI communication has to be handled at the script level. Enabling MPI communication for use in lomc!() is done by wrapping the primary data structures as MPIData. The relevant functionality is provided by the module Rimu.RMPI.","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"See examples in the Scripts folder.","category":"page"},{"location":"index.html#References","page":"Guide","title":"References","text":"","category":"section"},{"location":"index.html","page":"Guide","title":"Guide","text":"The code implements the FCIQMC algorithm described in","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"\"Fermion Monte Carlo without fixed nodes: A game of life, death, and annihilation in Slater determinant space\", G. H. Booth, A. J. W. Thom, A. Alavi, J. Chem. Phys. 131, 054106 (2009).","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"Scientific papers using the Rimu code:","category":"page"},{"location":"index.html","page":"Guide","title":"Guide","text":"\"Improved walker population control for full configuration interaction quantum Monte Carlo\", M. Yang, E. Pahl, J. Brand, J. Chem. Phys. 153, 170143 (2020); DOI: 10.1063/5.0023088; arXiv:2008.01927.\n\"Stochastic differential equation approach to understanding the population control bias in full configuration interaction quantum Monte Carlo\", J. Brand, M. Yang, E. Pahl; arXiv:2103.07800 (2021).","category":"page"},{"location":"statstools.html#Module-Rimu/StatsTools","page":"StatsTools","title":"Module Rimu/StatsTools","text":"","category":"section"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"The  module Rimu/StatsTools contains helper function for analysis and post processing of Monte Carlo data.","category":"page"},{"location":"statstools.html#Usage","page":"StatsTools","title":"Usage","text":"","category":"section"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"The module is not exported by default. In oder to use its functions without explicitly specifying the submodule, import the module with","category":"page"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"using Rimu, Rimu.StatsTools","category":"page"},{"location":"statstools.html#Blocking-analysis","page":"StatsTools","title":"Blocking analysis","text":"","category":"section"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"For blocking analysis of a single time series use blocking_analysis, or mean_and_se.","category":"page"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"For blocking analysis of a couple of time series where the ration of means is the quantity of interest use ratio_of_means.","category":"page"},{"location":"statstools.html#Exported","page":"StatsTools","title":"Exported","text":"","category":"section"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"Modules = [StatsTools]\nPages = [\"StatsTools.jl\", \"blocking.jl\", \"ratio_of_means.jl\", \"convenience.jl\",\n  \"variances.jl\", \"growth_witness.jl\", \"reweighting.jl\"\n]\nPrivate = false","category":"page"},{"location":"statstools.html#Rimu.StatsTools","page":"StatsTools","title":"Rimu.StatsTools","text":"Tools for the statistical analysis of Monte Carlo data.\n\nExports:\n\nblocking_analysis\nmean_and_se\nratio_of_means\ngrowth_witness\nsmoothen\n\n\n\n\n\n","category":"module"},{"location":"statstools.html#Rimu.StatsTools.blocking_analysis-Tuple{AbstractVector{T} where T}","page":"StatsTools","title":"Rimu.StatsTools.blocking_analysis","text":"blocking_analysis(v::AbstractVector; α = 0.01, corrected = true)\n-> BlockingResult(mean, err, err_err, p_cov, k, blocks)\n\nCompute the sample mean mean and estimate the standard deviation of the mean (standard error) err of a correlated time series using the blocking algorithm from Flyvberg and Peterson JCP (1989) and the M test of Jonsson PRE (2018) at significance level 1-α. k is the number of blocking transformations required to pass the hypothesis test for an uncorrelated time series and err_err the estimated standard error or err.\n\nIf decorrelating the time series fails according to the M test, NaN is returned as the standard error and -1 for k. corrected controls whether bias correction for variances is used.\n\nSee BlockingResult.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.mean_and_se-Tuple{Rimu.StatsTools.BlockingResult}","page":"StatsTools","title":"Rimu.StatsTools.mean_and_se","text":"mean_and_se(v::AbstractVector; α = 0.01, corrected::Bool=true) -> mean, err\nmean_and_se(r::BlockingResult) -> mean, err\n\nReturn the mean and standard error (as a tuple) of a time series obtained from blocking_analysis. See also BlockingResult.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.ratio_of_means-Tuple{Any, Any}","page":"StatsTools","title":"Rimu.StatsTools.ratio_of_means","text":"ratio_of_means(num, denom; α = 0.01, corrected = true, mc_samples = 10_000) -> r\n\nEstimate the ratio of mean(num)/mean(denom) assuming that num and denom are possibly correlated time series. A blocking analysis with m-test is used to uncorrelate the time series, see blocking_analysis(). The remaining standard error and correlation of the means is propagated using MonteCarloMeasurements. The results are reported as a RatioBlockingResult.\n\nRobust estimates for the ratio are obtained from median(r) and confidence intervals from quantile(), e.g. quantile(r, [0.025, 0.975]) for the 95% confidence interval.\n\nEstimates from linear uncertainty propagation are returned as r.f and r.σ_f using x_by_y_linear().\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.med_and_errs-Tuple{Any}","page":"StatsTools","title":"Rimu.StatsTools.med_and_errs","text":"med_and_errs(p) -> (; med, err1_l, err1_u, err2_l, err2_u)\n\nConvenience function for extracting plottable data from a distribution or Particles object. Returns the median med and the lower err1_l and upper err1_u standard error (for 1σ or 68% confidence inteval). err2_l and err2_u provide the lower and upper error limits for the 2σ or 95% confidence interval.\n\nExample:\n\njulia> results = [Particles(d) for d in datasets] # Particles[]\njulia> res_w_errs = med_and_errs.(results) # Vector of NamedTuple's with standard errors\njulia> res_df = DataFrame(res_w_errs) # results as DataFrame with lower an upper error\n1×5 DataFrame\n Row │ med      err1_l     err1_u     err2_l    err2_u\n     │ Float64  Float64    Float64    Float64   Float64\n─────┼────────────────────────────────────────────────────\n   1 │ 1.01325  0.0173805  0.0183057  0.034042  0.0366713\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.ratio_with_errs-Tuple{Rimu.StatsTools.RatioBlockingResult}","page":"StatsTools","title":"Rimu.StatsTools.ratio_with_errs","text":"ratio_with_errs(r::RatioBlockingResult)\n-> (;ratio=med, err1_l, err1_u, err2_l, err2_u, f, σ_f, δ_y, k, success)\n\nConvenience function for extracting plottable data from RatioBlockingResult. Returns NamedTuple with median and standard error of r extracted by p_to_errs(). See also ratio_of_means().\n\nExample:\n\njulia> results = [ratio_of_means(n[i], d[i]; args...) for i in datasets]\njulia> res_w_errs = ratio_with_errs.(results) # Vector of NamedTuple's with standard errors\njulia> res_df = DataFrame(res_w_errs) # results as DataFrame with lower an upper error\n1×10 DataFrame\n Row │ ratio    err1_l     err1_u     err2_l    err2_u     f        σ_f        δ_y        k      success\n     │ Float64  Float64    Float64    Float64   Float64    Float64  Float64    Float64    Int64  Bool\n─────┼───────────────────────────────────────────────────────────────────────────────────────────────────\n   1 │ 1.01325  0.0173805  0.0183057  0.034042  0.0366713  1.01361  0.0181869  0.0128806      2     true\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.replica_fidelity-Tuple{Tuple}","page":"StatsTools","title":"Rimu.StatsTools.replica_fidelity","text":"replica_fidelity(rr::Tuple; p_field = :hproj, skip = 0)\n\nCompute the fidelity of the average coefficient vector and the projector defined in p_field from the result of replica fci_qmc!() passed as  argument rr (a tuple of DataFrames). Calls ratio_of_means() to perform a blocking analysis on a ratio of the means of separate time series and returns a RatioBlockingResult. The first skip steps in the time series are skipped.\n\nThe fidelity of states |ψ⟩ and |ϕ⟩ is defined as\n\nF(ψϕ) = fracψϕ^2ψψϕϕ \n\nSpecifically, replica_fidelity computes\n\nF(mathbfvmathbfc) =\n    frac(mathbfc_Amathbfv)(mathbfvmathbfc_B)\n    mathbfc_Amathbfc_B \n\nwhere v is the projector specified by p_field, which is assumed to be normalised to unity with the two-norm (i.e. v⋅v == 1), and mathbfc_A and mathbfc_B are two replica coefficient vectors.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.growth_witness-Tuple{AbstractArray, AbstractArray, Any}","page":"StatsTools","title":"Rimu.StatsTools.growth_witness","text":"growth_witness(norm::AbstractArray, shift::AbstractArray, dt, [b]) -> g\ngrowth_witness(df::DataFrame, [b]) -> g\n\nCompute the growth witness\n\nG^(n) = S^(n) - fracvertmathbfc^(n+1)vert - vertmathbfc^(n)vertvertmathbfc^(n)vert dtau\n\nwhere S is the shift and vertmathbfc^(n)vert == norm[n, 1]. Setting b ≥ 1 a sliding average over b time steps is computed using smoothen().\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.smoothen-Tuple{AbstractVector{T} where T, Integer}","page":"StatsTools","title":"Rimu.StatsTools.smoothen","text":"smoothen(noisy::AbstractVector, b)\n\nSmoothen the array noisy by averaging over a sliding window of length b and wrapping noisy periodically. The mean(noisy) is preserved.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.growth_estimator-NTuple{4, Any}","page":"StatsTools","title":"Rimu.StatsTools.growth_estimator","text":"growth_estimator(\n    shift, wn, h, dτ;\n    skip = 0,\n    E_r = mean(shift[skip+1:end]),\n    weights = w_exp,\n    kwargs...,\n) -> (; E_gr::Particles, k, blocks, success)\ngrowth_estimator(df::DataFrame, h; kwargs ...)\n\nCompute the growth estimator with reference energy E_r by the reweighting technique described in Umirgar et al. (1993), see Eq. (20). shift and wn are equal length vectors containing the shift and walker number time series, respectively. Reweighting is done over h time steps and length(shift) - skip time steps are used for the blocking analysis done with ratio_of_means(). dτ is the time step and weights a function that calulates the weights. See w_exp() and w_lin().\n\nE_gr = E_r - frac1dτln\n    fracsum_n w_h+1^(n+1) N_mathrmw^(n+1)\n        sum_m w_h^(m) N_mathrmw^(m)\n\nWhen h is greater than the autocorrelation time scale of the shift, then E_gr is an unbiased but approximate estimator for the ground state energy E_0 with an error mathcalO(dτ^2) and potentially increased confidence intervals compared to the (biased) shift estimator. Error propagation is done with MonteCarloMeasurements. If success==true the blocking analysis was successful in k-1 steps, using blocks uncorrelated data points.\n\nSee also mixed_estimator().\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.mixed_estimator-NTuple{5, Any}","page":"StatsTools","title":"Rimu.StatsTools.mixed_estimator","text":"mixed_estimator(\n    hproj, vproj, shift, h, dτ;\n    skip = 0,\n    E_r = mean(shift[skip+1:end]),\n    weights = w_exp,\n    kwargs...,\n) -> r::RatioBlockingResult\nmixed_estimator(df::DataFrame, h; kwargs...)\n\nCompute the mixed estimator by the reweighting technique described in Umirgar et al. (1993), Eq. (19)\n\nE_mathrmmix = fracsum_n w_h^(n)  (Hmathrmv)mathrmc^(n)\n        sum_m w_h^(m)  mathrmvmathrmc^(m) \n\nwhere the time series hproj == (Hmathrmv)mathrmc^(n) and vproj == mathrmvmathrmc^(m) have the same length as shift (See ReportingStrategy on how to set these up). Reweighting is done over h time steps and length(shift) - skip time steps are used for the blocking analysis done with ratio_of_means(). dτ is the time step and weights a function that calulates the weights. See w_exp() and w_lin(). Additional keyword arguments are passed on to ratio_of_means().\n\nWhen h is greater than the autocorrelation time scale of the shift, then r.ratio is an unbiased but approximate estimator for the ground state energy E_0 with an error mathcalO(dτ^2) and potentially increased confidence intervals compared to the unweighted ratio. Error propagation is done with MonteCarloMeasurements. Results are returned as RatioBlockingResult.\n\nSee also growth_estimator().\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.w_exp-Tuple{Any, Any, Any}","page":"StatsTools","title":"Rimu.StatsTools.w_exp","text":"w_exp(shift, h, dτ; E_r = mean(shift), skip = 0)\n\nCompute the weights for reweighting over h time steps with reference energy E_r from the exponential formula\n\nw_h^(n) = prod_j=1^h exp-dτ(S^(q+n-j)-E_r) \n\nwhere q = skip.\n\nSee also w_lin(), growth_estimator(), mixed_estimator().\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.w_lin-Tuple{Any, Any, Any}","page":"StatsTools","title":"Rimu.StatsTools.w_lin","text":"w_lin(shift, h, dτ; E_r = mean(shift), skip = 0)\n\nCompute the weights for reweighting over h time steps with reference energy E_r from the linearised formula\n\nw_h^(n) = prod_j=1^h 1-dτ(S^(q+n-j)-E_r) \n\nwhere q = skip.\n\nSee also w_exp(), growth_estimator(), mixed_estimator().\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Additional-docstrings","page":"StatsTools","title":"Additional docstrings","text":"","category":"section"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"Modules = [StatsTools]\nPages = [\"StatsTools.jl\", \"blocking.jl\", \"ratio_of_means.jl\", \"convenience.jl\",\n  \"variances.jl\", \"growth_witness.jl\", \"reweighting.jl\"\n]\nPublic = false","category":"page"},{"location":"statstools.html#MonteCarloMeasurements.Particles-Tuple{Rimu.StatsTools.BlockingResult{var\"#s241\"} where var\"#s241\"<:Real}","page":"StatsTools","title":"MonteCarloMeasurements.Particles","text":"MonteCarloMeasurements.Particles(r::BlockingResult; mc_samples = 2000)\nMonteCarloMeasurements.±(r::BlockingResult)\n\nConvert a BlockingResult into a Particles object for nonlinear error propagation with MonteCarloMeasurements.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.BlockingResult","page":"StatsTools","title":"Rimu.StatsTools.BlockingResult","text":"BlockingResult(mean, err, err_err, p_cov, k, blocks)\n\nResult of blocking_analysis().\n\nFields:\n\nmean: sample mean\nerr: standard error (estimated standard deviation of the mean)\nerr_err: estimated uncertainty of err\np_cov: estimated pseudo covariance of mean, relevant for complex time series\nk::Int: k-1 blocking steps were used to uncorrelate time series\nblocks::Int: number of uncorrelated values after blocking\n\nHas methods for mean_and_se, Measurements.:±, MonteCarloMeasurements.Particles, and Statistics.cov for Complex data.\n\n\n\n\n\n","category":"type"},{"location":"statstools.html#Measurements.measurement-Tuple{Rimu.StatsTools.BlockingResult{var\"#s332\"} where var\"#s332\"<:Real}","page":"StatsTools","title":"Measurements.measurement","text":"measurement(r::BlockingResult)\nMeasurements.±(r::BlockingResult)\n\nConvert a BlockingResult into a Measurement for linear error propagation with Measurements.\n\nLimitation: Does not account for covariance in complex BlockingResult. Consider using MonteCarloMeasurements.Particles(r)!\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.blocker-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"StatsTools","title":"Rimu.StatsTools.blocker","text":"blocker(v::Vector) -> new_v::Vector\n\nReblock the data by successively taking the mean of two adjacent data points to form a new vector with a half of the length(v). The last data point will be discarded if length(v) is odd.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.blocks_with_m-Tuple{Any}","page":"StatsTools","title":"Rimu.StatsTools.blocks_with_m","text":"blocks_with_m(v; corrected = true) -> (;blocks, mean, std_err, std_err_err, p_cov, mj)\n\nPerform the blocking algorithm from Flyvberg and Peterson JCP (1989). Returns named tuple with the results from all blocking steps. See mtest().\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.mtest-Tuple{AbstractVector{T} where T}","page":"StatsTools","title":"Rimu.StatsTools.mtest","text":"mtest(mj::AbstractVector; α = 0.01, warn = true) -> k\nmtest(table; α = 0.01, warn = true) -> k\n\nHypothesis test for decorrelation of a time series after blocking transformations with significance level 1-α after Jonson PRE (2018). mj or table.mj is expected to be a vector with relevant M_j values from a blocking analysis as obtained from blocks_with_m(). Returns the row number k where the M-test is passed. If the M-test has failed mtest() returns the value -1 and optionally prints a warning message.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Statistics.cov-Tuple{Rimu.StatsTools.BlockingResult{var\"#s332\"} where var\"#s332\"<:Complex}","page":"StatsTools","title":"Statistics.cov","text":"cov(r::BlockingResult{<:Complex})\n\nReturn the covariance matrix of the multivariate normal distribution approximating the uncertainty of the blocking result r of a complex time series. See (https://en.wikipedia.org/wiki/Complexnormaldistribution).\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.RatioBlockingResult","page":"StatsTools","title":"Rimu.StatsTools.RatioBlockingResult","text":"RatioBlockingResult(ratio, f, σ_f, δ_y, k, success)\n\nResult of ratio_of_means().\n\nFields:\n\nratio::P: ratio with uncertainties propagated by MonteCarloMeasurements\nf::T: ratio of means\nσ_f::T: std from linear propagation\nδ_y::T: coefficient of variation for denominator (≤ 0.1 for normal approx)\nk::Int: k-1 blocking steps were used to uncorrelate time series\nblocks::Int: number of data values after blocking\nsuccess::Bool: false if any of the blocking steps failed\n\n\n\n\n\n","category":"type"},{"location":"statstools.html#Rimu.StatsTools.ratio_estimators-Tuple{Any, Any}","page":"StatsTools","title":"Rimu.StatsTools.ratio_estimators","text":"ratio_estimators(x, y, [k]; corrected=true, mc_samples=10_000) -> (; r, f, σ_f, δ_y, n)\n\nEstimators for the ratio of means mean(x)/mean(y). If k is given, k-1 blocking steps are performed to remove internal correlations in the time series x and y. Otherwise these are assumed to be free of internal correlations. Correlations between x and y may be present and are taken into account.\n\nReturn values:\n\nr::Particles is the Monte Carlo sampled ratio estimator, see Particles\nf = mean(x)/mean(y)\nσ_f standard deviation of f from linear error propagation (normal approximation)\nδ_y = std(y)/mean(y) coefficient of variation; < 0.1 for normal approximation to work\nn: number of uncorrelated data used for uncertainty estimation\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.x_by_y_linear-NTuple{5, Any}","page":"StatsTools","title":"Rimu.StatsTools.x_by_y_linear","text":"x_by_y_linear(μ_x,μ_y,σ_x,σ_y,ρ) -> f, σ_f\n\nLinear error propagation for ratio f = x/y assuming x and y are correlated normal random variables and assuming the ratio can be approximated as a normal distribution. See wikipedia and Díaz-Francés, Rubio (2013).\n\nσ_f = sqrtfracσ_xμ_y^2 + fracμ_x σ_yμ_y^2^2 - frac2 ρ μ_xμ_y^3\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.autocovariance-Tuple{AbstractVector{T} where T, Int64}","page":"StatsTools","title":"Rimu.StatsTools.autocovariance","text":"autocovariance(v::Vector,h::Int; corrected::Bool=true)\n\nhatgamma(h) =frac1nsum_t=1^n-h(v_t+h-barv)(v_t-barv)^* Calculate the autocovariance of dataset v with a delay h. If corrected is true (the default) then the sum is scaled with n-h, whereas the sum is scaled with n if corrected is false where n = length(v).\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Rimu.StatsTools.pseudo_cov-Tuple{Any, Any}","page":"StatsTools","title":"Rimu.StatsTools.pseudo_cov","text":"pseudo_cov(x, y; xmean = mean(x), ymean = mean(y), corrected = true)\n\nCompute the pseudo covariance between collections x and y returning a scalar:\n\nfrac1nsum_i=1^n (x_i - barx)(y_i - bary)\n\nOptionally, precomputed means can be passed as keyword arguments. pseudo_cov(x,y) is functionally equivalent to Statistics.cov(x, conj(y); corrected = false) but it is found to be significantly faster and avoids allocations.\n\n\n\n\n\n","category":"method"},{"location":"statstools.html#Index","page":"StatsTools","title":"Index","text":"","category":"section"},{"location":"statstools.html","page":"StatsTools","title":"StatsTools","text":"Pages   = [\"statstools.md\"]","category":"page"},{"location":"hamiltonians.html#Module-Hamiltionians.jl","page":"Hamiltonians","title":"Module Hamiltionians.jl","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"This module contains definitions of Hamiltonians, in particular specific physical models of interest. These are organised by means of an interface around the abstract type AbstractHamiltonian, in the spirit of the AbstractArray interface as discussed in the Julia Documentation.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Hamiltonians","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians","page":"Hamiltonians","title":"Rimu.Hamiltonians","text":"module Hamiltonians\n\nThis module defines Hamiltonian types, interfaces, and functions for working with Hamiltonians.\n\n\n\n\n\n","category":"module"},{"location":"hamiltonians.html#Relation-to-other-parts-of-the-Rimu-code","page":"Hamiltonians","title":"Relation to other parts of the Rimu code","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"In order to define a specific model Hamiltonian with relevant parameters for the model, instantiate the model like this in the input file:","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"ham = HubbardReal1D(BoseFS((1,2,0,3)); u=1.0, t=1.0)","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"In the rest of the Rimu code, access to properties and matrix elements of the model are then provided by the following methods:","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"ham[address1, address2]:  indexing of matrix elements (slow - use with caution)\nham * dv, ham(dv::AbstractDVec) or mul!(dv1, ham, dv2): use as linear operator\ndiagonal_element(ham, add): diagonal matrix element\nnum_offdiagonals(ham, add): number of off-diagonals\nget_offdiagonal(ham, add, chosen): access off-diagonal matrix element\noffdiagonals(ham, add): iterator over off-diagonal matrix elements\nrandom_offdiagonal(hops): choose random off-diagonal\ndimension(T, ham): dimension of linear space\nnearUniform(ham): configuration with particles spread across modes\nstarting_address(ham): address for accessing one of the diagonal elements of ham","category":"page"},{"location":"hamiltonians.html#Model-Hamiltonians","page":"Hamiltonians","title":"Model Hamiltonians","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Here is a list of fully implemented model Hamiltonians. So far there are two variants implemented of the one-dimensional Bose-Hubbard model real space as well as a momentum-space Hubbard chain.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"HubbardReal1D\nExtendedHubbardReal1D\nHubbardMom1D\nMatrixHamiltonian","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.HubbardReal1D","text":"HubbardReal1D(address; u=1.0, t=1.0)\n\nImplements a one-dimensional Bose Hubbard chain in real space.\n\nhatH = -t sum_langle ijrangle a_i^ a_j + fracu2sum_i n_i (n_i-1)\n\nArguments\n\naddress: the starting address, defines number of particles and sites.\nu: the interaction parameter.\nt: the hopping strength.\n\nSee also\n\nHubbardMom1D\nExtendedHubbardReal1D\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.ExtendedHubbardReal1D","text":"ExtendedHubbardReal1D(address; u=1.0, v=1.0, t=1.0)\n\nImplements the extended Hubbard model on a one-dimensional chain in real space.\n\nhatH = -t sum_langle ijrangle a_i^ a_j + fracu2sum_i n_i (n_i-1) + v sum_langle ijrangle n_i n_j\n\nArguments\n\naddress: the starting address.\nu: on-site interaction parameter\nv: the next-neighbor interaction\nt: the hopping strength\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D","page":"Hamiltonians","title":"Rimu.Hamiltonians.HubbardMom1D","text":"HubbardMom1D(address; u=1.0, t=1.0)\n\nImplements a one-dimensional Bose Hubbard chain in momentum space.\n\nhatH =  sum_k ϵ_k n_k + fracuMsum_kpqr a^_r a^_q a_p a_k δ_r+qp+k\nϵ_k = -2t cos(k)\n\nArguments\n\naddress: the starting address, defines number of particles and sites.\nu: the interaction parameter.\nt: the hopping strength.\n\nSee also\n\nHubbardReal1D\nExtendedHubbardReal1D\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian","page":"Hamiltonians","title":"Rimu.Hamiltonians.MatrixHamiltonian","text":"MatrixHamiltonian(mat::AbstractMatrix{T}; starting_address=1) <: AbstractHamiltonian{T}\n\nWrap an abstract matrix mat as an AbstractHamiltonian object for use with regular Vectors indexed by integers. Works with stochatic methods of lomc!(). Optionally, a starting_address can be provided.\n\nSpecialised methods are implemented for sparse matrices of type AbstractSparseMatrixCSC.\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Hamiltonians-interface","page":"Hamiltonians","title":"Hamiltonians interface","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"Behind the implementation of a particular model is a more abstract interface for defining hamiltonians. If you want to define a new model you should make use of this interface. The most general form of a model Hamiltonian should subtype to AbstractHamiltonian and implement the relevant methods.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"AbstractHamiltonian\noffdiagonals\nrandom_offdiagonal","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian","page":"Hamiltonians","title":"Rimu.Hamiltonians.AbstractHamiltonian","text":"AbstractHamiltonian{T}\n\nSupertype that provides an interface for linear operators over a linear space with scalar type T that are suitable for FCIQMC. Indexing is done with addresses (typically not integers) from an address space that may be large (and will not need to be completely generated).\n\nAbstractHamiltonian instances operate on vectors of type AbstractDVec from the module DictVectors and work well with addresses of type AbstractFockAddress from the module BitStringAddresses. The type works well with the external package KrylovKit.jl.\n\nMethods\n\nProvides:\n\noffdiagonals: iterator over reachable off-diagonal matrix elements\nrandom_offdiagonal: function to generate random off-diagonal matrix element\ndimension: get the dimension of the address space.\nH[address1, address2]: indexing with getindex() - mostly for testing purposes\n*(H, v): deterministic matrix-vector multiply.\nH(v): equivalent to H * v.\nmul!(w, H, v): mutating matrix-vector multiply.\ndot(x, H, v): compute x⋅(H*v) minimizing allocations.\n\nMethods that need to be implemented:\n\nnum_offdiagonals(::AbstractHamiltonian, address)\nget_offdiagonal(::AbstractHamiltonian, address, chosen::Integer)\ndiagonal_element(::AbstractHamiltonian, address)\nstarting_address(::AbstractHamiltonian)\n\nOptional methods to implement:\n\nHamiltonians.LOStructure(::Type{typeof(lo)})\ndimension(::Type{T}, ::AbstractHamiltonian)\noffdiagonals(::AbstractHamiltonian, ::AbstractFockAddress)\nmomentum(::AbstractHamiltonian)\n\n\n\n\n\n","category":"type"},{"location":"hamiltonians.html#Rimu.Hamiltonians.offdiagonals","page":"Hamiltonians","title":"Rimu.Hamiltonians.offdiagonals","text":"offdiagonals(h::AbstractHamiltonian, address)\n\nReturn an iterator over reachable off-diagonal matrix elements of type <:AbstractOffdiagonals. Defaults to returning Offdiagonals(h, a)\n\nSee also\n\nOffdiagonals\nAbstractOffdiagonals\n\njulia> addr = BoseFS((3,2,1));\n\njulia> H = HubbardReal1D(addr);\n\njulia> h = offdiagonals(H, addr)\n6-element Rimu.Hamiltonians.Offdiagonals{Float64,BoseFS{6,3,BitString{8,1}},HubbardReal1D{Float64,BoseFS{6,3,BitString{8,1}},1.0,1.0}}:\n (BoseFS{6,3}((2, 3, 1)), -3.0)\n (BoseFS{6,3}((2, 2, 2)), -2.449489742783178)\n (BoseFS{6,3}((3, 1, 2)), -2.0)\n (BoseFS{6,3}((4, 1, 1)), -2.8284271247461903)\n (BoseFS{6,3}((4, 2, 0)), -2.0)\n (BoseFS{6,3}((3, 3, 0)), -1.7320508075688772)\n\n\n\n\n\n","category":"function"},{"location":"hamiltonians.html#Rimu.Hamiltonians.random_offdiagonal","page":"Hamiltonians","title":"Rimu.Hamiltonians.random_offdiagonal","text":"random_offdiagonal(offdiagonals::AbstractOffdiagonals)\nrandom_offdiagonal(ham::AbstractHamiltonian, add)\n\nGenerate a single random excitation, i.e. choose from one of the accessible off-diagonal elements in the column corresponding to address add of the Hamiltonian matrix represented by ham. Alternatively, pass as argument an iterator over the accessible matrix elements.\n\n\n\n\n\n","category":"function"},{"location":"hamiltonians.html#Core-functions","page":"Hamiltonians","title":"Core functions","text":"","category":"section"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"The following functions are part of the core functionality of a Hamiltonian and need to be implemented efficiently and specifically for each model.","category":"page"},{"location":"hamiltonians.html","page":"Hamiltonians","title":"Hamiltonians","text":"num_offdiagonals\nget_offdiagonal\ndiagonal_element","category":"page"},{"location":"hamiltonians.html#Rimu.Hamiltonians.num_offdiagonals","page":"Hamiltonians","title":"Rimu.Hamiltonians.num_offdiagonals","text":"num_offdiagonals(ham, add)\n\nCompute the number of number of reachable configurations from address add.\n\nExample\n\njulia> addr = BoseFS((3, 2, 1));\n\njulia> H = HubbardMom1D(addr);\n\njulia> num_offdiagonals(H, addr)\n10\n\n\n\n\n\n","category":"function"},{"location":"hamiltonians.html#Rimu.Hamiltonians.get_offdiagonal","page":"Hamiltonians","title":"Rimu.Hamiltonians.get_offdiagonal","text":"newadd, me = get_offdiagonal(ham, add, chosen)\n\nCompute value me and new address newadd of a single (off-diagonal) matrix element in a Hamiltonian ham. The off-diagonal element is in the same column as address add and is indexed by integer index chosen.\n\nExample\n\njulia> addr = BoseFS((3, 2, 1));\n\njulia> H = HubbardMom1D(addr);\n\njulia> get_offdiagonal(H, addr, 3)\n(BoseFS{6,3}((2, 1, 3)), 1.0)\n\n\n\n\n\n","category":"function"},{"location":"hamiltonians.html#Rimu.Hamiltonians.diagonal_element","page":"Hamiltonians","title":"Rimu.Hamiltonians.diagonal_element","text":"diagonal_element(ham, add)\n\nCompute the diagonal matrix element of the linear operator ham at address add.\n\nExample\n\njulia> addr = BoseFS((3, 2, 1));\n\njulia> H = HubbardMom1D(addr);\n\njulia> diagonal_element(H, addr)\n8.666666666666664\n\n\n\n\n\n","category":"function"},{"location":"consistentrng.html#Random-Numbers","page":"Random Numbers","title":"Random Numbers","text":"","category":"section"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"Generating good quality random numbers is crucial for any Monte Carlo code. In addition to generating pseudo random numbers with good statistics and in minimal CPU time, we also have the requirement that computations should be reproducible and the random number sequences independent on each worker when the code runs in parallel mode.","category":"page"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"We define the random number generator in the module ConsistentRNG.jl, which is loaded onto each process. Furthermore, independent seeds are used to seed the RNGs on each worker (from goQMC.jl). These seeds are generated using the Random.RandomDevice random number generator, which draws entropy from the operating system / hardware. The seeds are saved to file with a filename that includes the number of processes used. If a suitable file is found, then seeds are read in from the file. This behaviour can be controlled by the flag reuseRandomSeeds in the input file.","category":"page"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"For the random number generator we are currently using 'Xoroshiro128Plus' from 'RandomNumbers.jl'. For benchmarks and statistical test results see the Documentation of RandomNumbers.jl.","category":"page"},{"location":"consistentrng.html#Module-ConsistentRNG.jl","page":"Random Numbers","title":"Module ConsistentRNG.jl","text":"","category":"section"},{"location":"consistentrng.html","page":"Random Numbers","title":"Random Numbers","text":"Modules = [Rimu.ConsistentRNG]","category":"page"},{"location":"consistentrng.html#Rimu.ConsistentRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG","text":"module ConsistentRNG\n\nProvides a an array random number generators with one for each thread.\n\nExports cRand() and seedCRNG!(). These are thread consistent.\n\n\n\n\n\n","category":"module"},{"location":"consistentrng.html#Rimu.ConsistentRNG.CRNGs","page":"Random Numbers","title":"Rimu.ConsistentRNG.CRNGs","text":"CRNGs[]\n\nDefines an array of random number generators suitable for threaded code. For MPI or distributed runs it should be seeded separately on each process with seedCRNG!. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post. In order to change the random number generator, edit 'ConsistentRNG.jl'.\n\nrng = CRNGs[][Threads.threadid()]\nrand(rng)\n\n\n\n\n\n","category":"constant"},{"location":"consistentrng.html#Rimu.ConsistentRNG.CRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG.CRNG","text":"Baseline random number generator used throughout. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post. In order to change the random number generator, edit 'ConsistentRNG.jl'.\n\n\n\n\n\n","category":"type"},{"location":"consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple","page":"Random Numbers","title":"Rimu.ConsistentRNG.cRand","text":"r = cRand(args...)\n\nSimilar to 'rand(args)' but uses consistent random number generator 'CRNGs[]'. 'cRand()' generates a single uniformly distributed random number in the interval [0,1). Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.cRandn-Tuple","page":"Random Numbers","title":"Rimu.ConsistentRNG.cRandn","text":"r = cRandn(args...)\n\nSimilar to 'randn(args)' but uses consistent random number generators 'CRNGs[]'. 'cRandn()' generates a single normally distributed random number. Currently we are using 'Xoshiro256StarStar' from 'RandomNumbers.jl', see the Documentation and this Blog post.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.check_crng_independence-Tuple{Any}","page":"Random Numbers","title":"Rimu.ConsistentRNG.check_crng_independence","text":"ConsistentRNG.check_crng_independence(v)\n\nPrimitve test to check the random number generators. It throws an error if some of the threaded random number generators are equal. Returns the number of threaded RNGs.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.newChildRNG","page":"Random Numbers","title":"Rimu.ConsistentRNG.newChildRNG","text":"newChildRNG(parent_rng = trng())\n\nRandom number generator that is seeded deterministically from the thread-consistent global rng trng(). By scrambling with hash(), a statistically independent pseudo-random sequence from the parent rng is accessed.\n\n\n\n\n\n","category":"function"},{"location":"consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Vector{T} where T}","page":"Random Numbers","title":"Rimu.ConsistentRNG.seedCRNG!","text":"seedCRNG!([seed])\n\nSeed the threaded consistent random number generators CRNGs[]. If a single number is given, this will be used to seed a random sequence, which is hashed and then used to generate seeds for each rng in the vector CRNGs. When no argument is given, each rng is seeded randomly.\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.sync_cRandn-Tuple{Any}","page":"Random Numbers","title":"Rimu.ConsistentRNG.sync_cRandn","text":"sync_cRandn(v)\n\nGenerate one random number with cRandn() in a synchronous way. Defaults to cRandn().\n\n\n\n\n\n","category":"method"},{"location":"consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}","page":"Random Numbers","title":"Rimu.ConsistentRNG.trng","text":"trng()\n\nThread local random number generator.\n\nrand(trng())\nrand(trng(),UInt)\n\n\n\n\n\n","category":"method"},{"location":"testing.html#Code-testing","page":"Code testing","title":"Code testing","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"The script runtest.jl in the test/ folder contains tests of the code. To run the test simply run the script from the Julia REPL or run","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"Rimu$ julia test/runtest.jl","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"from the command line.","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"More tests should be added over time to test core functionality of the code. To add new tests, directly edit the file runtest.jl.","category":"page"},{"location":"testing.html#Automated-testing-with-GitHub-Actions","page":"Code testing","title":"Automated testing with GitHub Actions","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"GitHub Actions are set up to run the test script automatically on the GitHub cloud server every time a new commit to the master branch is pushed to the server. The setup for this to happen is configured in the file actions.yml in the Rimu/.github/workflows folder.","category":"page"},{"location":"testing.html#Modifying-the-Project.toml-file","page":"Code testing","title":"Modifying the Project.toml file","text":"","category":"section"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"In order for the testing code to be able to run on the cloud server, external packages that are accessed in the code with using or import need to be installed first. This is done in the script actions.yml via the package manager, based on the information contained in the file test/Project.toml. More packages can be added to this file using the package manager in the following way: Say we want to install the package DelimitedFiles. At the Julia REPL, type the following:","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"julia> cd(\"test\")\njulia> ]\n(v1.0) pkg> activate .\n(test) pkg> add DelimitedFiles","category":"page"},{"location":"testing.html","page":"Code testing","title":"Code testing","text":"This will a new line to the file Project.toml with the name of the package and the corresponding uuid. When Pipelines now runs the commands in yml script, it will install the package DelimitedFiles before running the runtest.jl script.","category":"page"},{"location":"BHM-example.html#Example:-1D-Bose-Hubbard-Model","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"","category":"section"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"This is an example calculation finding the ground state of a 1D Bose-Hubbard chain with 6 particles in 6 lattice site. The Julia run-able script is in scripts/BHM-example.jl.","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Firstly, we load all needed modules. Rimu for FCIQMC calculation;","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"using Rimu","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now we define the physical problem: Setting the number of lattice sites m = 6; and the number of particles n = 6:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"m = n = 6","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Generating a configuration that particles are evenly distributed:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"aIni = nearUniform(BoseFS{n,m})","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"where BoseFS is used to create a bosonic system. The Hamiltonian is defined based on the configuration aIni, with additional onsite interaction strength u = 6.0 and the hopping strength t = 1.0:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Ĥ = HubbardReal1D(aIni; u = 6.0, t = 1.0)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's setup the Monte Carlo settings. The number of walkers to use in this Monte Carlo run:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"targetwalkers = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"The number of time steps before doing statistics, i.e. letting the walkers to sample Hilbert and to equilibrate:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"steps_equilibrate = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"And the number of time steps used for getting statistics, e.g. time-average of shift, projected energy, walker numbers, etc.:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"steps_measure = 1_000","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Set the size of a time step","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"dτ = 0.001","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"and we report QMC data every k-th step, setting k = 1 means we record QMC data every step:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"k = 1","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now we prepare initial state and allocate memory. The initial address is defined above as aIni = nearUniform(Ĥ). Define the initial number of walkers per rank:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"nIni = 1","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Putting the nIni number of walkers into the initial address aIni","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"svec = DVec(aIni => nIni)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Let's plant a seed for the random number generator to get consistent result:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Rimu.ConsistentRNG.seedCRNG!(17)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's setup all the FCIQMC strategies.","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Passing dτ and total number of time steps into params:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"params = RunTillLastStep(dτ = dτ, laststep = steps_equilibrate + steps_measure)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for updating the shift:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"s_strat = DoubleLogUpdate(targetwalkers = targetwalkers, ζ = 0.08)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for reporting info and setting projectors:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"r_strat = ReportDFAndInfo(k = k, i = 100, projector = copy(svec))","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Strategy for updating dτ:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"t_strat = ConstantTimeStep()","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Print out info about what we are doing:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"println(\"Finding ground state for:\")\nprintln(Ĥ)\nprintln(\"Strategies for run:\")\nprintln(params, s_strat)\nprintln(t_strat)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Finally, we can start the main FCIQMC loop:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"df, state = lomc!(Ĥ,svec;\n            params = params,\n            laststep = steps_equilibrate + steps_measure,\n            s_strat = s_strat,\n            r_strat = r_strat,\n            τ_strat = t_strat);\nprintln(\"Writing data to disk...\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Saving output data stored in df into a .arrow file which can be read in later:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"save_df(\"fciqmcdata.arrow\", df)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Now let's look at the calculated energy from the shift: Loading the equilibrated data:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"qmcdata = last(df,steps_measure)\nusing Rimu.StatsTools","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"For the shift, it's easy to use mean_and_se from Rimu.StatsTools","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"(qmcShift,qmcShiftErr) = mean_and_se(qmcdata.shift)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"For the projected energy, it a bit more complicated as it's a ratio of two means:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"r = ratio_of_means(qmcdata.hproj,qmcdata.vproj)\nrwe = ratio_with_errs(r)","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Here we use the 95% CI for the lower and upper error bars:","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"(eProj,eProjErrLower,eProjErrUpper) = (rwe.ratio, rwe.err2_l, rwe.err2_u)\n\nprintln(\"Energy from $steps_measure steps with $targetwalkers walkers:\n         Shift: $qmcShift ± $qmcShiftErr;\n         Projected Energy: $eProj ± ($eProjErrLower, $eProjErrUpper)\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"Finished !","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"println(\"Finished!\")","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"","category":"page"},{"location":"BHM-example.html","page":"Example: 1D Bose-Hubbard Model","title":"Example: 1D Bose-Hubbard Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"documentation.html#Documentation-generation","page":"Documentation generation","title":"Documentation generation","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"We are using Documenter.jl to generate the documentation web site based on markdown files stored in docs/src. Please help keeping the documentation up-to-date by editing the markdown files! For instructions on how to write appropriate documentation please refer to the relevant chapter in the Julia documentation and the Documenter.jl documentation.","category":"page"},{"location":"documentation.html#Generating-the-documentation-web-site","page":"Documentation generation","title":"Generating the documentation web site","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"The documentation pages can be generated by running the build script by typing","category":"page"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"Rimu$ julia docs/build.jl","category":"page"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"on the shell prompt from the Rimu/ folder. A complete image of the static documentation web site will be generated in the folder docs/build/. It can be viewed locally by pointing a web browser to file docs/build/index.html, or by deploying it to the Bitbucket pages web server.","category":"page"},{"location":"documentation.html#Automatic-documentation-generation-and-deployment","page":"Documentation generation","title":"Automatic documentation generation and deployment","text":"","category":"section"},{"location":"documentation.html","page":"Documentation generation","title":"Documentation generation","text":"Our documentation is hosted on a Bitbucket pages web site. The documentation web site can be built and deployed automatically with BitBucket pipelines. This needs to be set up with an appropriate script in the file bitbucket-pipelines.yml in the project folder, where triggers for this to happen can be defined. In the current set up, a new documentation web site is generated and deployed whenever someone pushes to the master branch on the BitBucket server. The updated documentation can then be accessed at https://joachimbrand.bitbucket.io/Rimu.jl/dev/.","category":"page"},{"location":"API.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"API.html#Rimu","page":"API","title":"Rimu","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [Rimu]","category":"page"},{"location":"API.html#Rimu.Rimu","page":"API","title":"Rimu.Rimu","text":"Rimu\n\nRandom Integrator for Many-Body Quantum Systems\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.AllOverlaps","page":"API","title":"Rimu.AllOverlaps","text":"AllOverlaps(n=2, operator=nothing) <: ReplicaStrategy{n}\n\nRun n replicas and report overlaps between all pairs of replica vectors. If operator is not nothing, the overlap dot(c1, operator, c2) is reported as well. If operator is a tuple of operators, the overlaps are computed for all operators.\n\nColumn names in the report are of the form c{i}dotc{j} for vector-vector overlaps, and c{i}Op{k}c{j} for operator overlaps.\n\nSee ReplicaStrategy and AbstractHamiltonian (for an interface for implementing operators).\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ConstantTimeStep","page":"API","title":"Rimu.ConstantTimeStep","text":"ConstantTimeStep <: TimeStepStrategy\n\nKeep dτ constant.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedDoubleLogUpdate","page":"API","title":"Rimu.DelayedDoubleLogUpdate","text":"DelayedDoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ and delay of A steps. See DoubleLogUpdate.\n\nS^n+A = S^n -fracζA dτlnleft(fracΨ_1^n+AΨ_1^nright)-fracξA dτlnleft(fracΨ_1^n+AΨ_1^texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedDoubleLogUpdateAfterTW","page":"API","title":"Rimu.DelayedDoubleLogUpdateAfterTW","text":"DelayedDoubleLogUpdateAfterTW(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ and delay of A steps after the number of target walkers is reached. See DoubleLogUpdate.\n\nS^n+A = S^n -fracζA dτlnleft(fracΨ_1^n+AΨ_1^nright)-fracξA dτlnleft(fracΨ_1^n+AΨ_1^texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedLogUpdate","page":"API","title":"Rimu.DelayedLogUpdate","text":"DelayedLogUpdate(ζ = 0.08, a = 10) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and delay of a steps.\n\nS^n+a = S^n -fracζa dτlnleft(fracΨ_1^n+aΨ_1^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DelayedLogUpdateAfterTargetWalkers","page":"API","title":"Rimu.DelayedLogUpdateAfterTargetWalkers","text":"DelayedLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, a = 10) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and delay of a steps. See DelayedLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory","page":"API","title":"Rimu.DeltaMemory","text":"DeltaMemory(Δ::Int) <: MemoryStrategy\n\nBefore updating the shift, memory noise with a memory length of Δ is applied, where Δ = 1 means no memory noise.\n\nr̃ = (pnorm - tnorm)/(dτ*pnorm) + shift\nr = r̃ - <r̃>\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory2","page":"API","title":"Rimu.DeltaMemory2","text":"DeltaMemory2(Δ::Int) <: MemoryStrategy\n\nBefore updating the shift, memory noise with a memory length of Δ is applied, where Δ = 1 means no memory noise.\n\nr̃ = pnorm - tnorm + shift*dτ*pnorm\nr = (r̃ - <r̃>)/(dτ*pnorm)\n\nThe long-term average of r is not guaranteed to be zero.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DeltaMemory3","page":"API","title":"Rimu.DeltaMemory3","text":"DeltaMemory3(Δ::Int, level::Float64) <: MemoryStrategy\n\nBefore updating the shift, apply multiplicative memory noise with a memory length of Δ at level level, where Δ = 1 means no memory noise.\n\nr̃ = (pnorm - tnorm)/pnorm + dτ*shift\nr = r̃ - <r̃>\nw .*= 1 + level*r\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DontUpdate","page":"API","title":"Rimu.DontUpdate","text":"DontUpdate() <: ShiftStrategy Don't update the shift.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogProjected","page":"API","title":"Rimu.DoubleLogProjected","text":"DoubleLogProjected(; target, projector, ζ = 0.08, ξ = ζ^2/4) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ after projecting onto projector.\n\nS^n+1 = S^n -fracζdτlnleft(fracPΨ^(n+1)PΨ^(n)right)-fracξdτlnleft(fracPΨ^(n+1)texttargetright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogSumUpdate","page":"API","title":"Rimu.DoubleLogSumUpdate","text":"DoubleLogSumUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, α = 1/2) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameters ζ and ξ.\n\nS^n+1 = S^n -fracζdτlnleft(fracN_mathrmw^n+1N_mathrmw^nright)\n- fracξdτlnleft(fracN_mathrmw^n+1N_mathrmw^texttargetright)\n\nwhere N_mathrmw = (1-α)*walkernumber() + α*UniformProjector()⋅ψ computed with walkernumber() and UniformProjector(). When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdate","page":"API","title":"Rimu.DoubleLogUpdate","text":"DoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ and ξ.\n\nS^n+1 = S^n -fracζdτlnleft(fracΨ_1^n+1Ψ_1^nright)-fracξdτlnleft(fracΨ_1^n+1Ψ_1^texttargetright)\n\nWhen ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdateAfterTargetWalkers","page":"API","title":"Rimu.DoubleLogUpdateAfterTargetWalkers","text":"LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, ξ = 0.0016) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and ξ. See DoubleLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch","page":"API","title":"Rimu.DoubleLogUpdateAfterTargetWalkersSwitch","text":"LogUpdateAfterTargetWalkersSwitch(targetwalkers, ζ = 0.08, ξ = 0.0016) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ and ξ. After a steps the strategy switches to LogUpdate. See DoubleLogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.EveryKthStep","page":"API","title":"Rimu.EveryKthStep","text":"EveryKthStep(;k = 10, projector = nothing, hproj = :auto)\n\nReport every kth step. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.EveryTimeStep","page":"API","title":"Rimu.EveryTimeStep","text":"EveryTimeStep(;projector = nothing, hproj = :auto)\n\nReport every time step. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.FciqmcRunStrategy","page":"API","title":"Rimu.FciqmcRunStrategy","text":" FciqmcRunStrategy{T}\n\nAbstract type representing the strategy for running and terminating fciqmc!(). The type parameter T is relevant for reporting the shift and the norm.\n\nImplemented strategies:\n\nRunTillLastStep\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.HistoryLogUpdate","page":"API","title":"Rimu.HistoryLogUpdate","text":"HistoryLogUpdate(df::DataFrame; d = 100, k=1, ζ= 0.08)\n\nStrategy for updating the shift according to log formula but with walker numbers accumulated from k samples of the history with delay d. A recent history has to be passed with the data frame df for initialisation.\n\nN_w^n = sum_i=0^k-1 Ψ_1^n-i \nS^n+a = S^n -fracζa dτlnleft(fracN_w^n+1N_w^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.LogUpdate","page":"API","title":"Rimu.LogUpdate","text":"LogUpdate(ζ = 0.08) <: ShiftStrategy\n\nStrategy for updating the shift according to the log formula with damping parameter ζ.\n\nS^n+1 = S^n -fracζdτlnleft(fracΨ_1^n+1Ψ_1^nright)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.LogUpdateAfterTargetWalkers","page":"API","title":"Rimu.LogUpdateAfterTargetWalkers","text":"LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08) <: ShiftStrategy\n\nStrategy for updating the shift: After targetwalkers is reached, update the shift according to the log formula with damping parameter ζ. See LogUpdate.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.MemoryStrategy","page":"API","title":"Rimu.MemoryStrategy","text":"Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:\n\nNoMemory\nDeltaMemory\nShiftMemory\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.NoMemory","page":"API","title":"Rimu.NoMemory","text":"NoMemory <: MemoryStrategy\n\nDefault strategy for MemoryStrategy indicating that no memory noise will be used.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.NoStats","page":"API","title":"Rimu.NoStats","text":"NoStats(N=1) <: ReplicaStrategy{N}\n\nThe default ReplicaStrategy. N replicas are run, but no statistics are collected.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ProjectedMemory","page":"API","title":"Rimu.ProjectedMemory","text":"ProjectedMemory(Δ::Int, projector, pp::Number) <: MemoryStrategy\nProjectedMemory(Δ::Int, projector, v::AbstractDVec)\n\nBefore updating the shift, apply memory noise to minimize the fluctuations of the overlap of the coefficient vector with projector. Averaging over Δ time steps is applied, where Δ = 1 means no memory noise is applied. Use pp to initialise the value of the projection or pass v in order to initialise the projection with pp = projector.v.\n\nr̃ = (projector⋅v - projector⋅w)/projector⋅v + dτ*shift\nr = r̃ - <r̃>\n\nwhere v is the coefficient vector before and w after applying a regular FCIQMC step.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.PurgeNegatives","page":"API","title":"Rimu.PurgeNegatives","text":"PurgeNegatives <: MemoryStrategy\n\nPurge all negative sign walkers.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.QMCState","page":"API","title":"Rimu.QMCState","text":"QMCState\n\nHolds all inforamtion needed to run FCIQMC, except the data frame. Holds a NTuple of ReplicaStates and various strategies that control the algorithm.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReplicaState","page":"API","title":"Rimu.ReplicaState","text":"ReplicaState(v, w, pnorm, params, id)\n\nStruct that holds all information needed for an independent run of the algorithm.\n\nCan be advanced a step forward with advance!.\n\nFields\n\nv: vector.\nw: working memory.\npnorm: previous walker number (see walkernumber).\nparams: the FCIQMCRunStrategy.\nid: appended to reported columns.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReplicaStrategy","page":"API","title":"Rimu.ReplicaStrategy","text":"ReplicaStrategy{N}\n\nAn abstract type that controles how lomc! uses replicas. A subtype of ReplicaStrategy{N} operates on N replicas and must implement the following function:\n\nreplica_stats(::ReplicaStrategy{N}, ::NTuple{N,ReplicaState}) - return a tuple of Strings or Symbols of replica statistic names and a tuple of the values.  These will be reported to the DataFrame returned by lomc!\n\nConcrete implementations:\n\nNoStats: run (possibly one) replica(s), but don't report any additional info.\nAllOverlaps: report overlaps between all pairs of replica vectors.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.Report","page":"API","title":"Rimu.Report","text":"Report\n\nInternal structure that hold the temporary reported values. See report!.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReportDFAndInfo","page":"API","title":"Rimu.ReportDFAndInfo","text":"ReportDFAndInfo(; k=10, i=100, io=stdout, writeinfo=true, projector = nothing, hproj = :auto)\n\nReport every kth step in DataFrame and write info message to io every ith step (unless writeinfo == false). The flag writeinfo is useful for controlling info messages in MPI codes. Include projection onto projector. See ReportingStrategy for details.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReportToFile","page":"API","title":"Rimu.ReportToFile","text":"ReportToFile(; kwargs...) <: ReportingStrategy\n\nReporting strategy that writes the report directly to a file. Useful when dealing with long jobs or large numbers of replicas, when the report can incur a significant memory cost.\n\nKeyword arguments\n\nfilename: the file to report to. If the file already exists, a new file is created.\nchunk_size = 1000: the size of each chunk that is written to the file.\nsave_if = true: if this value is true, save the report, otherwise ignore it. Use save_if=is_mpi_root() when running MPI jobs.\nreturn_df: if this value is true, read the file and return the data frame at the end of computation. Otherwise, an empty DataFrame is returned.\nio=stdout: The IO to print messages to. Set to devnull if you don't want to see messages printed out.\nprojector = nothing: include projection onto projector\nhproj = :auto: secondary projector\n\nSee ReportingStrategy for details regarding the use of projectors.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ReportingStrategy","page":"API","title":"Rimu.ReportingStrategy","text":"ReportingStrategy\n\nAbstract type for strategies for reporting data in a DataFrame with report!(). It also affects the calculation and reporting of projected quantities in the DataFrame.\n\nImplemented strategies:\n\nEveryTimeStep\nEveryKthStep\nReportDFAndInfo\nReportToFile\n\nEvery strategy accepts the keyword arguments projector and hproj according to which a projection of the instantaneous coefficient vector projector⋅v and hproj⋅v are reported to the DataFrame in the fields df.vproj and df.hproj, respectively. Possible values for projector are\n\nnothing - no projections are computed (default)\ndv::AbstractDVec - compute projection onto coefficient vector dv (set up with copy to conserve memory)\nUniformProjector() - projection onto vector of all ones (i.e. sum of elements)\nNormProjector() - compute 1-norm (instead of projection)\nNorm1ProjectorPPop() - compute 1-norm per population\nNorm2Projector() - compute 2-norm\n\nIn order to help set up the calculation of the projected energy, where df.hproj should report dot(projector, ham, v), the keyword hproj accepts the following values (for ReportingStrategys passed to lomc!()):\n\n:auto - choose method depending on projector and ham (default)\n:lazy - compute dot(projector, ham, v) every time (slow)\n:eager -  precompute hproj as ham'*v (fast, requires adjoint(ham))\n:not - don't compute second projector (equivalent to nothing)\n\nInterface\n\nA ReportingStrategy must define the following:\n\nreport!\nreport_after_step (optional)\nfinalize_report! (optional)\n\nExamples\n\nr_strat = EveryTimeStep(projector = copy(svec))\n\nRecord the projected energy components df.vproj = svec⋅v and df.hproj = dot(svec,ham,v) with respect to the starting vector (performs fast eager calculation if Hamiltonians.LOStructure(ham) ≠ Hamiltonians.AdjointUnknown()), and report every time step.\n\nr_strat = EveryKthStep(k=10, projector = UniformProjector(), hproj = :lazy)\n\nRecord the projection of the instananeous coefficient vector v onto the uniform vector of all 1s into df.vproj and of ham⋅v into df.hproj, and report every kth time step.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.RunTillLastStep","page":"API","title":"Rimu.RunTillLastStep","text":"RunTillLastStep(step::Int = 0 # number of current/starting timestep\n             laststep::Int = 100 # number of final timestep\n             shiftMode::Bool = false # whether to adjust shift\n             shift = 0.0 # starting/current value of shift\n             dτ::Float64 = 0.01 # current value of time step\n) <: FciqmcRunStrategy\n\nParameters for running fciqmc!() for a fixed number of time steps. For alternative strategies, see FciqmcRunStrategy.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ShiftMemory","page":"API","title":"Rimu.ShiftMemory","text":"ShiftMemory(Δ::Int) <: MemoryStrategy\n\nEffectively replaces the fluctuating shift update procedure for the coefficient vector by an averaged shift over Δ timesteps, where Δ = 1 means no averaging.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.ShiftStrategy","page":"API","title":"Rimu.ShiftStrategy","text":"Abstract type for defining the strategy for updating the shift with update_shift(). Implemented strategies:\n\nDoubleLogUpdate - default in lomc!()\nDontUpdate\nLogUpdate\nDelayedLogUpdate\nLogUpdateAfterTargetWalkers - FCIQMC standard\nDelayedLogUpdateAfterTargetWalkers\nDoubleLogUpdateAfterTargetWalkers\nDoubleLogUpdateAfterTargetWalkersSwitch\nHistoryLogUpdate\nDoubleLogProjected\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.TimeStepStrategy","page":"API","title":"Rimu.TimeStepStrategy","text":"TimeStepStrategy\n\nAbstract type for strategies for updating the time step with update_dτ(). Implemented strategies:\n\nConstantTimeStep\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.TripleLogUpdate","page":"API","title":"Rimu.TripleLogUpdate","text":"TripleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, η = 0.01) <: ShiftStrategy\n\nStrategy for updating the shift according to the extended log formula with damping parameters ζ, ξ, and η.\n\nS^n+1 = S^n -fracζdτlnleft(fracN_mathrmw^n+1N_mathrmw^nright)\n- fracξdτlnleft(fracN_mathrmw^n+1N_mathrmw^texttargetright)\n- fracηdτlnleft(fracℜ(Ψ^n+1)_1^2 + ℑ(Ψ^n+1)_1^2\nℜ(Ψ^n)_1^2 + ℑ(Ψ^n)_1^2right)\n\nwhere N_mathrmw is the walkernumber(). When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, V, W, R} where {V, W, R<:FciqmcRunStrategy{T}}}} where T","page":"API","title":"Rimu.advance!","text":"advance!(report::Report, state::QMCState, replica::ReplicaState)\n\nAdvance the replica by one step. The state is used only to access the various strategies involved. Steps, stats, and computed quantities are written to the report.\n\nReturns true if the step was successful.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T<:Real}","page":"API","title":"Rimu.apply_memory_noise!","text":"r = apply_memory_noise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)\n\nApply memory noise to w, i.e. w .+= r.*v, computing the noise r according to m_strat. Note that m_strat needs to be compatible with StochasticStyle(w). Otherwise, an error exception is thrown. See MemoryStrategy.\n\nw is the walker array after fciqmc step, v the previous one, pnorm the norm of v, and r the instantaneously applied noise.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.compute_proj_observables-Tuple{Any, Any, ReportingStrategy{Nothing, Nothing}}","page":"API","title":"Rimu.compute_proj_observables","text":"compute_proj_observables(v, ham, r::ReportingStrategy)\n\nCompute the projection of r.projector⋅v and r.hproj⋅v or r.projector⋅ham*v according to the ReportingStrategy r.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T<:Real}","page":"API","title":"Rimu.fciqmc_col!","text":"fciqmc_col!(w, ham, add, num, shift, dτ)\nfciqmc_col!(::Type{T}, args...)\n-> spawns, deaths, clones, antiparticles, annihilations\n\nSpawning and diagonal step of FCIQMC for single column of ham. In essence it computes\n\nw .+= (1 .+ dτ.*(shift .- ham[:,add])).*num.\n\nDepending on T ==StochasticStyle(w), a stochastic or deterministic algorithm will be chosen. The possible values for T are:\n\nIsDeterministic() deteministic algorithm\nIsStochasticInteger() stochastic version where the changes added to w are purely integer, according to the FCIQMC algorithm\nIsStochasticWithThreshold(c) stochastic algorithm with floating point walkers.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.fciqmc_step!","page":"API","title":"Rimu.fciqmc_step!","text":"fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;\n                      m_strat::MemoryStrategy = NoMemory()) -> ṽ, w̃, stats\n\nPerform a single matrix(/operator)-vector multiplication:\n\ntildev = 1 - dτ(hatH - S)v \n\nwhere Ĥ == ham and S == shift. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait StochasticStyle(w). See StochasticStyle. w is a local data structure with the same size and type as v and used for working. Both v and w are modified.\n\nReturns the result ṽ, a (possibly changed) reference to working memory w̃,  and the array stats = [spawns, deaths, clones, antiparticles, annihilations]. Stats will contain zeros when running in deterministic mode.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.finalize_report!-Tuple{ReportingStrategy, Any}","page":"API","title":"Rimu.finalize_report!","text":"finalize_report!(::ReportingStrategy, report)\n\nFinalize the report. This function is called after all steps in lomc! have finished.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.lomc!-Tuple{Any, Any}","page":"API","title":"Rimu.lomc!","text":"lomc!(ham, v; kwargs...)\n\nLinear operator Monte Carlo: Perform the FCIQMC algorithm for determining the lowest eigenvalue of ham. v can be a single starting vector of (wrapped) type :<AbstractDVec.\n\nReturns a DataFrame with various statistics and a QMCState containing all information required for continuation runs.\n\nKeyword arguments, defaults, and precedence:\n\nlaststep - can be used to override information otherwise contained in params\nthreading = :auto - can be used to control the use of multithreading (overridden by wm)\n:auto - use multithreading if s_strat.targetwalkers ≥ 500\ntrue - use multithreading if available (set shell variable JULIA_NUM_THREADS!)\nfalse - run on single thread\nwm - working memory; if set, it controls the use of multithreading and overrides threading; is mutated\nparams::FciqmcRunStrategy = RunTillLastStep(laststep = 100) - contains basic parameters of simulation state, see FciqmcRunStrategy; is mutated\ns_strat::ShiftStrategy = DoubleLogUpdate(targetwalkers = 1000) - see ShiftStrategy\nr_strat::ReportingStrategy = EveryTimeStep() - see ReportingStrategy\nτ_strat::TimeStepStrategy = ConstantTimeStep() - see TimeStepStrategy\nm_strat::MemoryStrategy = NoMemory() - see MemoryStrategy\nreplica::ReplicaStrategy = NoStats(1) - see ReplicaStrategy.\n\nReturn values\n\nlomc! returns a named tuple with the following fields:\n\ndf: a DataFrame with all statistics being reported.\nstate: a QMCState that can be used for continuations.\n\nExample\n\njulia> add = BoseFS((1,2,3));\n\njulia> H = HubbardReal1D(add);\n\njulia> dv = DVec(add => 1);\n\njulia> df1, state = lomc!(H, dv);\n\njulia> df2, _ = lomc!(state, df1; laststep=200); # Contuniation run\n\njulia> size(df1)\n(100, 12)\n\njulia> size(df2)\n(200, 12)\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy, Any}","page":"API","title":"Rimu.refine_r_strat","text":"Rimu.refine_r_strat(r_strat::ReportingStrategy, ham)\n\nRefine the reporting strategy by replacing Symbols in the keyword argument hproj by the appropriate value. See ReportingStrategy\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.replica_stats","page":"API","title":"Rimu.replica_stats","text":"replica_stats(::ReplicaStrategy{N}, replicas::NTuple{N,ReplicaState}) -> (names, values)\n\nReturn the names and values of statistics reported by ReplicaStrategy. names should be a tuple of Symbols or Strings and values should be a tuple of the same length.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.report!-Tuple{Any, Any, Any}","page":"API","title":"Rimu.report!","text":"report!(report, keys, values, id=\"\")\nreport!(report, nt, id=\"\")\n\nWrite keys, values pairs to report that will be converted to a DataFrame later. Alternatively, a named tuple can be passed instead of keys and values.\n\nThe value of id is appended to the name of the column, e.g. report!(report, :key, value, :_1) will report value to a column named :key_1.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.report!","text":" report!(::ReportingStrategy, step, report::Report, keys, values, id=\"\")\n report!(::ReportingStrategy, step, report::Report, nt, id=\"\")\n\nReport keys and values to report, which will be converted to a DataFrame before lomc! exits. Alternatively, a nt::NamedTuple can be passed in place of keys and values. If id is specified, it is appended to all keys. This is used to differentiate between values reported by different replicas.\n\nTo overload this function for a new ReportingStrategy, overload report!(::ReportingStrategy, step, args...) and apply the report by calling report!(args...).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}","page":"API","title":"Rimu.report_after_step","text":"report_after_step(::ReportingStrategy, step, report, state)\n\nThis function is called at the very end of a step. It can let the ReportingStrategy print some information to output.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.sort_into_targets!-Tuple{Any, Any, Any}","page":"API","title":"Rimu.sort_into_targets!","text":"sort_into_targets!(target, source, stats) -> agg, wm, agg_stats\n\nAggregate coefficients from source to agg and from stats to agg_stats according to thread- or MPI-level parallelism. wm passes back a reference to working memory.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.step_stats-Tuple{StochasticStyle}","page":"API","title":"Rimu.step_stats","text":"step_stats(::StochasticStyle)\n\nReturn a tuple of names (Symbol or String) and a zeros of values of the same length. These will be reported as columns in the DataFrame returned by lomc!.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var\"#s332\", false} where var\"#s332\", Any, Any, Any, Any}","page":"API","title":"Rimu.threshold_projected_deposit!","text":"threshold_projected_deposit!\n\nThis function performs threshold projection before spawning, but only for IsDynamicSemistochastic with the project_later parameter set to false.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_dvec!-Tuple{StochasticStyle, Any}","page":"API","title":"Rimu.update_dvec!","text":"update_dvec!([::StochasticStyle,] dvec) -> dvec, nt\n\nPerform an arbitrary transformation on dvec after the spawning step is completed and report statistics to the DataFrame.\n\nReturns the new dvec and a NamedTuple nt of statistics to be reported.\n\nWhen extending this function for a custom StochasticStyle, define a method  for the two-argument call signature!\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.update_dτ","text":"update_dτ(s<:TimeStepStrategy, dτ, tnorm) -> new dτ\n\nUpdate the time step according to the strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.update_shift-Tuple{HistoryLogUpdate, Any, Any, Any, Any, Any, Any, Any, Vararg{Any, N} where N}","page":"API","title":"Rimu.update_shift","text":"update_shift(s <: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df, v_new, v_old)\n\nUpdate the shift according to strategy s. See ShiftStrategy.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Reexported-Submodules","page":"API","title":"Reexported Submodules","text":"","category":"section"},{"location":"API.html#Hamiltonians","page":"API","title":"Hamiltonians","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Link to Module Hamiltionians.jl","category":"page"},{"location":"API.html#BitStringAddresses","page":"API","title":"BitStringAddresses","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [BitStringAddresses]","category":"page"},{"location":"API.html#Rimu.BitStringAddresses.AbstractFockAddress","page":"API","title":"Rimu.BitStringAddresses.AbstractFockAddress","text":"AbstractFockAddress\n\nSupertype representing a Fock state.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BitString","page":"API","title":"Rimu.BitStringAddresses.BitString","text":"BitString{B,N} <: AbstractBitString\n\nType for storing bitstrings of static size. Holds B bits in N chunks, where each chunk is an UInt64\n\nN is chosen automatically to accommodate B bits as efficiently as possible.\n\nConstructors\n\nBitString{B,N}(::SVector{N,T}): unsafe constructor. Does not check for ghost bits.\nBitString{B,N}(i::UInt64): as above, but sets i as the rightmost chunk.\nBitString{B}(::Integer): Convert integer to BitString. Integer is truncated to the correct number of bits.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BoseFS","page":"API","title":"Rimu.BitStringAddresses.BoseFS","text":"BoseFS{N,M,S} <: AbstractFockAddress\nBoseFS(bs::S) where S <: BitAdd\nBoseFS(bs::S, b)\n\nAddress type that represents a Fock state of N spinless bosons in M orbitals by wrapping a bitstring of type S. Orbitals are stored in reverse order, i.e. the first orbital in a BoseFS is stored rightmost in the bitstring bs. If the number of significant bits b is not encoded in S it must be passed as an argument (e.g. for BSAdd64 and BSAdd128).\n\nConstructors\n\nBoseFS{N,M}(::BitString): Unsafe constructor. Does not check whether the number of ones in a is equal to N.\nBoseFS(::BitString): Automatically determine N and M. This constructor is not type stable!\nBoseFS{[N,M,S]}(onr): Create BoseFS{N,M} from onr representation. This is efficient as long as at least N is provided.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.BoseFS2C","page":"API","title":"Rimu.BitStringAddresses.BoseFS2C","text":"BoseFS2C{NA,NB,M,AA,AB} <: AbstractFockAddress\n\nAddress type that constructed with two BoseFS{N,M,S}. It represents a Fock state with two components, e.g. two different species of bosons with particle number NA from species S and particle number NB from species B. The number of orbitals M is expected to be the same for both components.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.OccupiedOrbitalIterator","page":"API","title":"Rimu.BitStringAddresses.OccupiedOrbitalIterator","text":"occupied_orbitals(b)\n\nIterate over occupied orbitals in BoseFS address. Returns tuples of (boson_number, orbital_number, bit_offset).\n\nNote that the bit_offset is zero-based!\n\nExample\n\n```jldoctest julia> b = BoseFS((1,5,0,4)) julia> for (n, i) in occupied_orbitals(b)     @show n, i end (n, i) = (1, 1) (n, i) = (5, 2) (n, i) = (4, 4)\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}}} where {B, N}","page":"API","title":"Rimu.BitStringAddresses.check_bitstring_typeparams","text":"check_bitstring_typeparams(::Val{B}, ::Val{N})\n\nCheck if number of bits B is consistent with number of chunks N. Throw an error if not.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}","page":"API","title":"Rimu.BitStringAddresses.chunk_bits","text":"chunks_bits(s, i)\n\nNumber of bits in the i-th chunk of s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.chunks-Tuple{BitString}","page":"API","title":"Rimu.BitStringAddresses.chunks","text":"chunks(::Type{<:BitString})\nchunks(s)\n\nSVector that stores the chunks of s.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S<:BitString","page":"API","title":"Rimu.BitStringAddresses.has_ghost_bits","text":"has_ghost_bits(s)\n\nCheck for bits outside data field.\n\nSee also: remove_ghost_bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}","page":"API","title":"Rimu.BitStringAddresses.m_onr","text":"m_onr(bs)\n\nCompute and return the occupation number representation of the bit string address bs as an MVector{M,Int32}, where M is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{var\"#s12\"} where var\"#s12\"<:(BoseFS{N, M, S} where S<:BitString)}, Tuple{M}, Tuple{N}} where {N, M}","page":"API","title":"Rimu.BitStringAddresses.nearUniform","text":"nearUniform(BoseFS{N,M})\nnearUniform(BoseFS{N,M,S}) -> bfs::BoseFS{N,M,S}\n\nCreate bosonic Fock state with near uniform occupation number of M modes with a total of N particles. Specifying the bit address type S is optional.\n\nExamples\n\njulia> nearUniform(BoseFS{7,5,BitString{14}})\nBoseFS((2,2,1,1,1))\n\njulia> nearUniform(BoseFS{7,5})\nBoseFS((2,2,1,1,1))\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.nearUniformONR-Tuple{Number, Number}","page":"API","title":"Rimu.BitStringAddresses.nearUniformONR","text":"nearUniformONR(N, M) -> onr::SVector{M,Int}\n\nCreate occupation number representation onr distributing N particles in M modes in a close-to-uniform fashion with each orbital filled with at least N ÷ M particles and at most with N ÷ M + 1 particles.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var\"#s12\"} where var\"#s12\"<:(BitString{B, N} where N)}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.num_bits","text":"num_bits(::Type{<:BitString})\nnum_bits(s::BitString)\n\nTotal number of bits stored in bitstring.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var\"#s11\"} where var\"#s11\"<:(BitString{var\"#s6\", N} where var\"#s6\")}, Tuple{N}} where N","page":"API","title":"Rimu.BitStringAddresses.num_chunks","text":"num_chunks(::Type{<:BitString})\nnum_chunks(s::BitString)\n\nNumber of chunks in bitstring. Equivalent to length(chunks(s)).\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.num_chunks","text":"num_chunks(::Val{B})\n\nDetermine the number of chunks needed to store B bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}","page":"API","title":"Rimu.BitStringAddresses.num_modes","text":"num_modes(::Type{<:AbstractFockAddress})\n\nNumber of modes represented by address.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}","page":"API","title":"Rimu.BitStringAddresses.num_particles","text":"num_particles(::Type{<:AbstractFockAddress})\n\nNumber of particles represented by address.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.onr-Tuple{BoseFS}","page":"API","title":"Rimu.BitStringAddresses.onr","text":"onr(bs)\n\nCompute and return the occupation number representation of the bit string address bs as an SVector{M,Int32}, where M is the number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S<:BitString","page":"API","title":"Rimu.BitStringAddresses.remove_ghost_bits","text":"remove_ghost_bits(s)\n\nRemove set bits outside data field if any are present.\n\nSee also: has_ghost_bits.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var\"#s12\"} where var\"#s12\"<:(BitString{B, N} where N)}, Tuple{B}} where B","page":"API","title":"Rimu.BitStringAddresses.top_chunk_bits","text":"top_chunk_bits(::Type{<:BitString})\ntop_chunk_bits(s::BitString)\n\nNumber of bits stored in top chunk. Equivalent to chunk_bits(s, 1).\n\n\n\n\n\n","category":"method"},{"location":"API.html#DictVectors","page":"API","title":"DictVectors","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [DictVectors]","category":"page"},{"location":"API.html#Rimu.DictVectors","page":"API","title":"Rimu.DictVectors","text":"Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to AbstractVector nor to AbstractDict and are suitable for use with KrylovKit.jl. For this, the abstract type and interface AbstractDVec is provided, with the concrete implementation of DVec\n\n\n\n\n\n","category":"module"},{"location":"API.html#Rimu.DictVectors.AbstractDVec","page":"API","title":"Rimu.DictVectors.AbstractDVec","text":"DictVectors.AbstractDVec{K,V}\n\nAbstract type for sparse vectors with valtype V based on dictionary-like structures. The vectors are designed to work well with FCIQMC and KrylovKit.\n\nThey lie somewhere between AbstractDicts and sparse AbstractVectors, generally behaving like a dictionary, while supportting various linear algebra functionality. Indexing with a value not stored in the dictionary returns zero(V). Setting a stored value to 0 or below eps(V::AbstractFloat) removes the value from the dictionary. Their length signals the number of stored elements, not the size of the vector space.\n\nThey have a StochasticStyle which selects the spawning algorithm in FCIQMC.\n\nTo iterate over an AbstractDVec, use pairs or values.\n\nInterface\n\nThe interface is similar to the AbstractDict interface.\n\nImplement what would be needed for the AbstractDict interface (pairs, keys, values, setindex!, getindex, delete!, length, haskey, empty!, isempty) and, in addition:\n\nStochasticStyle\nstorage(dv) returns an AbstractDict storing the raw data with possibly different valtype than V.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.AbstractProjector","page":"API","title":"Rimu.DictVectors.AbstractProjector","text":"Abstract supertype for projectors to be used in in lieu of DVecs or Vectors.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.CoherentInitiator","page":"API","title":"Rimu.DictVectors.CoherentInitiator","text":"CoherentInitiator(threshold) <: InitiatorRule\n\nInitiator rule to be passed to InitiatorDVec. An initiator is a configuration add with a coefficient with magnitude abs(v[add]) > threshold. Rules:\n\nInitiators can spawn anywhere.\nNon-initiators can spawn to initiators.\nMultiple non-initiators can spawn to a single non-initiator if their contributions add up to a value greater than the initiator threshold.\nSee InitiatorRule.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.DVec","page":"API","title":"Rimu.DictVectors.DVec","text":"DVec{K,V,D<:AbstractDict{K,V},S}\n\nDictionary-based vector-like data structure for use with FCIQMC and KrylovKit. While mostly behaving like a Dict, it supports various linear algebra operations such as norm and dot. It has a StochasticStyle that is used to select an appropriate spawning strategy in the FCIQMC algorithm.\n\nSee also: AbstractDVec.\n\nConstructors\n\nDVec(dict::AbstractDict[; style, capacity]): create a DVec with dict for storage. Note that the data may or may not be copied.\nDVec(args...[; style, capacity]): args... are passed to the Dict constructor. The Dict is used for storage.\nDVec{K,V}([; style, capacity]): create an empty DVec{K,V}.\nDVec(dv::AbstractDVec[; style, capacity]): create a DVec with the same contents as  adv. The style is inherited from dv by default.\n\nThe default style is selected based on the DVec's valtype (see default_style). If a style is given and the valtype does not match the style's eltype, the values are converted to an appropriate type.\n\nThe capacity argument is optional and sets the initial size of the DVec via sizehint!.\n\nExamples\n\njulia> dv = DVec(:a => 1)\nDVec{Symbol,Int64} with 1 entries, style = IsStochasticInteger{Int64}()\n  :a => 1\n\njulia> dv = DVec(:a => 2, :b => 3; style=IsDynamicSemistochastic())\nDVec{Symbol,Float32} with 2 entries, style = IsDynamicSemistochastic{Float64, true}(1.0, Inf, 1.0)\n  :a => 2.0\n  :b => 3.0\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.Initiator","page":"API","title":"Rimu.DictVectors.Initiator","text":"Initiator(threshold) <: InitiatorRule\n\nInitiator rule to be passed to InitiatorDVec. An initiator is a configuration add with a coefficient with magnitude abs(v[add]) > threshold. Rules:\n\nInitiators can spawn anywhere.\nNon-initiators can spawn to initiators.\n\nSee InitiatorRule.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorDVec","page":"API","title":"Rimu.DictVectors.InitiatorDVec","text":"InitiatorDVec{K,V} <: AbstractDVec{K,V}\n\nDictionary-based vector-like data structure for use with lomc! and KrylovKit.jl. See AbstractDVec. Functionally identical to DVec, but contains InitiatorValues internally in order to facilitate initiator methods. How the initiators are handled is controlled by the initiator keyword argument (see below).\n\nConstructors\n\nInitiatorDVec(dict::AbstractDict[; style, initiator, capacity]): create an InitiatorDVec with dict for storage.  Note that the data may or may not be copied.\nInitiatorDVec(args...[; style, initiator, capacity]): args... are passed to the Dict constructor. The Dict is used for storage.\nInitiatorDVec{K,V}([; style, initiator, capacity]): create an empty InitiatorDVec{K,V}.\nInitiatorDVec(dv::AbstractDVec[; style, initiator, capacity]): create an InitiatorDVec  with the same contents as dv. The style is inherited from dv by default.\n\nKeyword  arguments\n\nstyle: A valid StochasticStyle.  The default is selected based on the InitiatorDVec's valtype (see default_style). If a style is given and the valtype does not match the style's eltype, the values are converted to an appropriate type.\ninitiator = Initiator(1): A valid InitiatorRule. See Initiator.\ncapacity: Indicative size as Int. Optional. Sets the initial size of the InitiatorDVec via sizehint!.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorIterator","page":"API","title":"Rimu.DictVectors.InitiatorIterator","text":"InitiatorIterator\n\nIterator over pairs or values of an InitiatorDVec. Supports the SplittablesBase interface.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorRule","page":"API","title":"Rimu.DictVectors.InitiatorRule","text":"InitiatorRule{V}\n\nAbstract type for defining initiator rules for InitiatorDVec. Concrete implementations:\n\nInitiator\nSimpleInitiator\nCoherentInitiator\n\nWhen defining a new InitiatorRule, also define a corresponding method for value!\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.InitiatorValue","page":"API","title":"Rimu.DictVectors.InitiatorValue","text":"InitiatorValue{V}(; safe::V, unsafe::V, initiator::V) where V\n\nComposite \"walker\" with three fields. For use with InitiatorDVecs.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsDeterministic","page":"API","title":"Rimu.DictVectors.IsDeterministic","text":"IsDeterministic{T=Float64}() <: StochasticStyle{T}\n\nTrait for generalised vector of configuration indicating deterministic propagation of walkers.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsDynamicSemistochastic","page":"API","title":"Rimu.DictVectors.IsDynamicSemistochastic","text":"IsDynamicSemistochastic{T=Float64}(rel_threshold=1, abs_threshold=Inf, proj_threshold=1) <: StochasticStyle{T}\n\nQMC propagation with non-integer walker numbers and reduced noise. All possible spawns are performed deterministically when number of walkers in a configuration is high. Stochastic vector compression with threshold proj_threshold is applied after spawning and diagonal death steps.\n\nUnlike with IsStochasticWithThreshold, when late_projection is set to true, walker annihilation is done before the stochastic vector compression.\n\nParameters:\n\nlate_projection = true: If set to true, threshold projection is done after all spawns are collected, otherwise, values are projected as they are being spawned.\nrel_threshold = 1.0: If the walker number on a configuration times this threshold is greater than the number of offdiagonals, spawning is done deterministically. Should be set to 1 or more for best performance.\nabs_threshold = Inf: If the walker number on a configuration is greater than this value, spawning is done deterministically. Can be set to e.g abs_threshold = 0.1 * target_walkers.\nproj_threshold = 1.0: Values below this number are stochastically projected to this value or zero. See also IsStochasticWithThreshold.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochastic2Pop","page":"API","title":"Rimu.DictVectors.IsStochastic2Pop","text":"IsStochastic2Pop{T=Complex{Int}}() <: StochasticStyle{T}\n\nTrait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of integer walkers.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochasticInteger","page":"API","title":"Rimu.DictVectors.IsStochasticInteger","text":"IsStochasticInteger{T=Int}() <: StochasticStyle{T}\n\nTrait for generalised vector of configurations indicating stochastic propagation as seen in the original FCIQMC algorithm.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.IsStochasticWithThreshold","page":"API","title":"Rimu.DictVectors.IsStochasticWithThreshold","text":"IsStochasticWithThreshold(threshold=1.0) <: StochasticStyle\n\nTrait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff threshold.\n\nDuring stochastic propagation, walker numbers small than threshold will be stochastically projected to either zero or threshold.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.Norm1ProjectorPPop","page":"API","title":"Rimu.DictVectors.Norm1ProjectorPPop","text":"Norm1ProjectorPPop()\n\nResults in computing the one-norm per population when used in dot(). E.g.\n\ndot(Norm1ProjectorPPop(),x)\n-> norm(real.(x),1) + im*norm(imag.(x),1)\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.Norm2Projector","page":"API","title":"Rimu.DictVectors.Norm2Projector","text":"Norm2Projector()\n\nResults in computing the two-norm when used in dot(). E.g.\n\ndot(NormProjector(),x)\n-> norm(x,2) # with type Float64\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.NormProjector","page":"API","title":"Rimu.DictVectors.NormProjector","text":"NormProjector()\n\nResults in computing the one-norm when used in dot(). E.g.\n\ndot(NormProjector(),x)\n-> norm(x,1)\n\nNormProjector() thus represents the vector sign.(x).\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.PopsProjector","page":"API","title":"Rimu.DictVectors.PopsProjector","text":"PopsProjector()\n\nResults in computing the projection of one population on the other when used in dot(). E.g.\n\ndot(PopsProjector(),x)\n-> real(x) ⋅ imag(x)\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.SimpleInitiator","page":"API","title":"Rimu.DictVectors.SimpleInitiator","text":"SimpleInitiator(threshold) <: InitiatorRule\n\nSimplified initiator rule to be passed to InitiatorDVec. An initiator is a configuration add with a coefficient with magnitude abs(v[add]) > threshold. Rules:\n\nInitiators can spawn anywhere.\nNon-initiators cannot spawn.\n\nSee InitiatorRule.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.StochasticStyle","page":"API","title":"Rimu.DictVectors.StochasticStyle","text":"StochasticStyle(v)\n\nStochasticStyle specifies the native style of the generalised vector v that determines how simulations are to proceed. This can be fully stochastic (with IsStochasticInteger), fully deterministic (with IsDeterministic), or stochastic with floating point walker numbers and threshold (with IsStochasticWithThreshold).\n\nWhen defining a new StochasticStyle, subtype it as MyStyle<:StochasticStyle{T} where T is the concrete value type the style is designed to work with.\n\nFor it to work with FCIQMC, a StochasticStyle must define the following:\n\nfciqmc_col!(::StochasticStyle, w, H, address, value, shift, dτ)\nstep_stats(::StochasticStyle)\n\nOptionally, it can also define update_dvec!, which can be used to perform arbitrary transformations on the dvec after the spawning step is complete.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.StyleUnknown","page":"API","title":"Rimu.DictVectors.StyleUnknown","text":"StyleUnknown{T}() <: StochasticStyle\n\nTrait for value types not (currently) compatible with FCIQMC. This style makes it possible to construct dict vectors with unsupported valtypes.\n\nSee also StochasticStyle.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.UniformProjector","page":"API","title":"Rimu.DictVectors.UniformProjector","text":"UniformProjector()\n\nRepresents a vector with all elements 1. To be used with dot(). Minimizes memory allocations.\n\nUniformProjector()⋅v == sum(v)\ndot(UniformProjector(), LO, v) == sum(LO*v)\n\nSee also ReportingStrategy for use of projectors in FCIQMC.\n\n\n\n\n\n","category":"type"},{"location":"API.html#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K","page":"API","title":"Rimu.DictVectors.add!","text":"add!(x::AbstractDVec,y::AbstactDVec)\n\nInplace add x+y and store result in x.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T<:Integer","page":"API","title":"Rimu.DictVectors.default_style","text":"default_style(::Type)\n\nPick a StochasticStyle based on the value type. Throws an error if no known default style is known.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.deposit!-NTuple{4, Any}","page":"API","title":"Rimu.DictVectors.deposit!","text":"deposit!(w::AbstractDVec, add, val, parent::Pair)\n\nAdd val into w at address add, taking into account initiator rules if applicable. parent contains the address => value pair from which the pair add => val was created. InitiatorDVec can intercept this and add its own functionality.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var\"#s6\", V, D, S, I} where {var\"#s6\", D<:AbstractDict{var\"#s6\", Rimu.DictVectors.InitiatorValue{V}}, S<:StochasticStyle{V}, I<:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V","page":"API","title":"Rimu.DictVectors.deposit!","text":"deposit!(w::InitiatorDVec, add, val, p_add=>p_val)\n\nAdd val into w at address add as an InitiatorValue.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.localpart-Tuple{Any}","page":"API","title":"Rimu.DictVectors.localpart","text":"localpart(dv) -> AbstractDVec\n\nGet the part of dv that is located on this MPI rank. Returns dv itself for DictVectors.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.storage","page":"API","title":"Rimu.DictVectors.storage","text":"storage(dvec) -> AbstractDict\n\nReturn the raw storage associated with dvec as an AbstractDict. Used in MPI communication.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.DictVectors.value","page":"API","title":"Rimu.DictVectors.value","text":"value(i::InitiatorRule, v::InitiatorValue)\n\nConvert the InitiatorValue v into a scalar value according to the InitiatorRule i.\n\nInternal function that implements functionality of InitiatorDVec.\n\n\n\n\n\n","category":"function"},{"location":"API.html#Rimu.DictVectors.walkernumber-Tuple{Any}","page":"API","title":"Rimu.DictVectors.walkernumber","text":"walkernumber(w)\n\nCompute the number of walkers in w. It is used for updating the shift. Overload this function for modifying population control.\n\nIn most cases walkernumber(w) is identical to norm(w,1). For AbstractDVecs with complex coefficients it reports the one norm separately for the real and the imaginary part as a ComplexF64. See Norm1ProjectorPPop.\n\n\n\n\n\n","category":"method"},{"location":"API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}","page":"API","title":"Rimu.DictVectors.zero!","text":"zero!(v)\n\nReplace v by a zero vector as an inplace operation. For AbstractDVec types it means removing all non-zero elements. For AbstractArrays, it sets all of the values to zero.\n\n\n\n\n\n","category":"method"},{"location":"API.html#ConsistentRNG","page":"API","title":"ConsistentRNG","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Link to Module ConsistentRNG.jl","category":"page"},{"location":"API.html#Unexported-Submodules","page":"API","title":"Unexported Submodules","text":"","category":"section"},{"location":"API.html#StatsTools","page":"API","title":"StatsTools","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Link to Module Rimu/StatsTools","category":"page"},{"location":"API.html#Blocking","page":"API","title":"Blocking","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"Modules = [Blocking]","category":"page"},{"location":"API.html#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API.html","page":"API","title":"API","text":"","category":"page"}]
}
