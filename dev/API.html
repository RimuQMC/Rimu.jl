<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Rimu.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Rimu.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="consistentrng.html">Random Numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li class="is-active"><a class="tocitem" href="API.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rimu-1"><span>Rimu</span></a></li><li><a class="tocitem" href="#Reexported-Submodules-1"><span>Reexported Submodules</span></a></li><li><a class="tocitem" href="#Unexported-Submodules-1"><span>Unexported Submodules</span></a></li><li class="toplevel"><a class="tocitem" href="#Index-1"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="API.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/src/master/docs/src/API.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h1><h2 id="Rimu-1"><a class="docs-heading-anchor" href="#Rimu-1">Rimu</a><a class="docs-heading-anchor-permalink" href="#Rimu-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.Rimu" href="#Rimu.Rimu"><code>Rimu.Rimu</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Rimu</code></pre><p>Random Integrator for Many-Body Quantum Systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Rimu.jl#LL1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ConstantTimeStep" href="#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Keep <code>dτ</code> constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedLogUpdate" href="#Rimu.DelayedLogUpdate"><code>Rimu.DelayedLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedLogUpdate(ζ = 0.3, a = 10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and delay of <code>a</code> steps.</p><div>\[S^{n+a} = S^n -\frac{ζ}{a dτ}\ln\left(\frac{\|Ψ\|_1^{n+a}}{\|Ψ\|_1^n}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedLogUpdateAfterTargetWalkers" href="#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>Rimu.DelayedLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.3, a = 10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and delay of <code>a</code> steps. See <a href="API.html#Rimu.DelayedLogUpdate"><code>DelayedLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory" href="#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = (pnorm - tnorm)/(dτ*pnorm) + shift
r = r̃ - &lt;r̃&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DontUpdate" href="#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DontUpdate() &lt;: ShiftStrategy</code> Don&#39;t update the <code>shift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdate" href="#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DoubleLogUpdate(targetwalkers, ζ = 0.3, ξ = 0.0225) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>.</p><div>\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^\text{target}}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkers" href="#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.3, ξ = 0.0225) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkersSwitch" href="#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>Rimu.DoubleLogUpdateAfterTargetWalkersSwitch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkersSwitch(targetwalkers, ζ = 0.3, ξ = 0.0225) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. After <code>a</code> steps the strategy swiches to <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.EveryKthStep" href="#Rimu.EveryKthStep"><code>Rimu.EveryKthStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EveryKthStep(;k = 10)</code></pre><p>Report every <code>k</code>th step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.EveryTimeStep" href="#Rimu.EveryTimeStep"><code>Rimu.EveryTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Report every time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FciqmcRunStrategy" href="#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing the strategy for running and terminating <a href="API.html#Rimu.fciqmc!"><code>fciqmc!()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.RunTillLastStep"><code>RunTillLastStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.HistoryLogUpdate" href="#Rimu.HistoryLogUpdate"><code>Rimu.HistoryLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HistoryLogUpdate(df::DataFrame; d = 100, k=1, ζ= 0.3)</code></pre><p>Strategy for updating the shift according to log formula but with walker numbers accumulated from <code>k</code> samples of the history with delay <code>d</code>. A recent history has to be passed with the data frame <code>df</code> for initialisation.</p><div>\[N_w^{n} = \sum_{i=0}^{k-1} \|Ψ\|_1^{n-i} \\
S^{n+a} = S^n -\frac{ζ}{a dτ}\ln\left(\frac{N_w^{n+1}}{N_w^n}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL334-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.IsStochasticWithThreshold" href="#Rimu.IsStochasticWithThreshold"><code>Rimu.IsStochasticWithThreshold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsStochasticWithThreshold(threshold::Float16)</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff <code>threshold</code>.</p><pre><code class="language-none">&gt; StochasticStyle(V) = IsStochasticWithThreshold(threshold)</code></pre><p>During stochastic propoagation, walker numbers small than <code>threshold</code> will be stochastically projected to either zero or <code>threshold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL461-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdate" href="#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdate(ζ = 0.3) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code>.</p><div>\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdateAfterTargetWalkers" href="#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.3) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code>. See <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPIData" href="#Rimu.MPIData"><code>Rimu.MPIData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple wrapper used for signaling that this data is part of a distributed data structure and communication should happen with MPI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPIDefault" href="#Rimu.MPIDefault"><code>Rimu.MPIDefault</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPIDefault(nprocs, my_rank, comm)</code></pre><p>Strategy for point-to-point MPI communication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPIOSWin" href="#Rimu.MPIOSWin"><code>Rimu.MPIOSWin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPIOSWin(nprocs, myrank, comm, ::Type{T}, capacity)</code></pre><p>Communication buffer for use with MPI one-sided communication (remote memory access). Up to <code>capacity</code> elements of type <code>T</code> can be exchanged between MPI ranks via <a href="API.html#Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T"><code>put</code></a>. It is important that <code>isbitstype(T) == true</code>. Objects of type <code>MPIOSWin</code> have to be freed manually with a (blocking) call to <a href="API.html#Rimu.free-Tuple{MPIOSWin}"><code>free()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MemoryStrategy" href="#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:</p><ul><li><a href="API.html#Rimu.NoMemory"><code>NoMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>DeltaMemory</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>ShiftMemory</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL137-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoMemory" href="#Rimu.NoMemory"><code>Rimu.NoMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoMemory &lt;: MemoryStrategy</code></pre><p>Default strategy for <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a> indicating that no memory noise will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoProjection" href="#Rimu.NoProjection"><code>Rimu.NoProjection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Do not project the walker amplitudes. See <a href="@ref"><code>norm_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.OvershootControl" href="#Rimu.OvershootControl"><code>Rimu.OvershootControl</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Slow down/Speed up <code>dτ</code> to control the psips overshoot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectStrategy" href="#Rimu.ProjectStrategy"><code>Rimu.ProjectStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the stategy of projection for fciqmc with floating point walker number with <a href="@ref"><code>norm_project</code></a>. Implemented stategies:</p><ul><li><a href="API.html#Rimu.NoProjection"><code>NoProjection</code></a></li><li><a href="API.html#Rimu.ThresholdProject"><code>ThresholdProject</code></a></li><li><a href="API.html#Rimu.ScaledThresholdProject"><code>ScaledThresholdProject</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL556-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportDFAndInfo" href="#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReportDFAndInfo(; k=10, i=100, io=stdout, writeinfo=true)</code></pre><p>Report every <code>k</code>th step in DataFrame and write info message to <code>io</code> every <code>i</code>th step (unless <code>writeinfo == false</code>). The flag <code>writeinfo</code> is useful for controlling info messages in MPI codes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportingStrategy" href="#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for strategies for reporting data in a DataFrame with <a href="API.html#Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}"><code>report!()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.EveryTimeStep"><code>EveryTimeStep</code></a></li><li><a href="API.html#Rimu.EveryKthStep"><code>EveryKthStep</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>ReportDFAndInfo</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RunTillLastStep" href="#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RunTillLastStep(step::Int = 0 # number of current/starting timestep
             laststep::Int = 50 # number of final timestep
             shiftMode::Bool = false # whether to adjust shift
             shift::Float64 = 0.0 # starting/current value of shift
             dτ::Float64 = 0.01 # current value of time step
) &lt;: FciqmcRunStrategy</code></pre><p>Parameters for running <a href="API.html#Rimu.fciqmc!"><code>fciqmc!()</code></a> for a fixed number of time steps. For alternative strategies, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ScaledThresholdProject" href="#Rimu.ScaledThresholdProject"><code>Rimu.ScaledThresholdProject</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScaledThresholdProject(threshold = 1.0) &lt;: ProjectStrategy</code></pre><p>Project stochastically for walker amplitudes below <code>threshold</code> and scale configuration array as to keep the norm constant. As a consequence, the final configuration amplitudes may be smaller than <code>threshold</code>. See <a href="@ref"><code>norm_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftMemory" href="#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Effectively replaces the fluctuating <code>shift</code> update procedure for the coefficient vector by an averaged <code>shift</code> over <code>Δ</code> timesteps, where <code>Δ = 1</code> means no averaging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL189-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.StochasticStyle" href="#Rimu.StochasticStyle"><code>Rimu.StochasticStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StochasticStyle(v)
StochasticStyle(typeof(v))</code></pre><p><code>StochasticStyle</code> specifies the native style of the generalised vector <code>v</code> that determines how simulations are to proceed. This can be fully stochastic (with <code>IsStochastic</code>), fully deterministic (with <code>IsDeterministic</code>), or semistochastic (with <a href="API.html#Rimu.IsSemistochastic"><code>IsSemistochastic</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL443-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ThresholdProject" href="#Rimu.ThresholdProject"><code>Rimu.ThresholdProject</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ThresholdProject(threshold = 1.0) &lt;: ProjectStrategy</code></pre><p>Project stochastically for walker amplitudes below <code>threshold</code>. See <a href="@ref"><code>norm_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/381693d3dfc9b7072707f6d544f82f6637fc5e7c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TimeStepStrategy" href="#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for strategies for updating the time step with <a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}"><code>update_dτ()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.ConstantTimeStep"><code>ConstantTimeStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL98-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc!" href="#Rimu.fciqmc!"><code>Rimu.fciqmc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fciqmc!(v, pa::FciqmcRunStrategy, [df,]
         ham, s_strat::ShiftStrategy,
         [r_strat::ReportingStrategy, τ_strat::TimeStepStrategy, w])
-&gt; df</code></pre><p>Perform the FCIQMC algorithm for determining the lowest eigenvalue of <code>ham</code>. <code>v</code> can be a single starting vector of type <code>:&lt;AbstractDVec</code> or a vector of such structures. In the latter case, independent replicas are constructed. Returns a <code>DataFrame</code> <code>df</code> with statistics about the run, or a tuple of <code>DataFrame</code>s for a replica run. Strategies can be given for updating the shift (see <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a>) and (optionally), for reporting (see <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a>), and for updating the time step <code>dτ</code> (see <a href="API.html#Rimu.TimeStepStrategy"><code>TimeStepStrategy</code></a>).</p><p>A pre-allocated data structure <code>w</code> for working memory can be passed as argument, and controls multi-threading behaviour. By default multi-threading is turned on. To turn multi-threading off, pass <code>similar(localpart(v))</code> for w.</p><p>This function mutates <code>v</code>, the parameter struct <code>pa</code> as well as <code>df</code>, and <code>w</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/fciqmc.jl#LL2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.free-Tuple{MPIOSWin}" href="#Rimu.free-Tuple{MPIOSWin}"><code>Rimu.free</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">free(obj::MPIOSWin)</code></pre><p>De-reference the object, call finalizer and the garbage collector immediately. This is a syncronizing MPI call. Make sure that the object is not used later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.greet-Tuple{}" href="#Rimu.greet-Tuple{}"><code>Rimu.greet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>brief greeting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Rimu.jl#LL49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.mpi_default" href="#Rimu.mpi_default"><code>Rimu.mpi_default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpi_default(data, comm = MPI.COMM_WORLD, root = 0)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to default. Sets up the <a href="API.html#Rimu.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.MPIDefault"><code>MPIDefault</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.mpi_no_exchange" href="#Rimu.mpi_no_exchange"><code>Rimu.mpi_no_exchange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpi_no_exchange(data, comm = MPI.COMM_WORLD, root = 0)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to <code>MPINoWalkerExchange</code>. Sets up the <a href="API.html#Rimu.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.MPINoWalkerExchange"><code>MPINoWalkerExchange</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.mpi_one_sided" href="#Rimu.mpi_one_sided"><code>Rimu.mpi_one_sided</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpi_one_sided(data, comm = MPI.COMM_WORLD, root = 0)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to one-sided with remote memory access (RMA). Sets up the <a href="API.html#Rimu.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.MPIOSWin"><code>MPIOSWin</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T" href="#Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T"><code>Rimu.put</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">put(buf::Vector{T}, [len,] targetrank, s::MPIOSWin{T})
put(obj::T, targetrank, s::MPIOSWin{T})</code></pre><p>Deposit a single <code>obj</code> or vector <code>buf</code> into the MPI window <code>s</code> on rank <code>targetrank</code>. If <code>len</code> is given, only the first <code>len</code> elements are transmitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL204-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.targetrank" href="#Rimu.targetrank"><code>Rimu.targetrank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">targetrank(key, np, hash = hash(key))</code></pre><p>Compute the rank where the <code>key</code> belongs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL244-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory2" href="#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory2(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = pnorm - tnorm + shift*dτ*pnorm
r = (r̃ - &lt;r̃&gt;)/(dτ*pnorm)</code></pre><p>The long-term average of <code>r</code> is not guaranteed to be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL171-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.IsSemistochastic" href="#Rimu.IsSemistochastic"><code>Rimu.IsSemistochastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsSemistochastic(threshold::Float16, d_space)</code></pre><p>Trait for generalised vector of configurations indicating semistochastic propagation. Set with <a href="API.html#Rimu.setSemistochastic!-Tuple{Any,Float16,Any}"><code>setSemistochastic!</code></a>.</p><pre><code class="language-none">&gt; StochasticStyle(V) = IsSemistochastic(threshold, d_space)</code></pre><p>where <code>d_space</code> is a vector of addresses defining the the stochastic subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL475-L483">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPINoWalkerExchange" href="#Rimu.MPINoWalkerExchange"><code>Rimu.MPINoWalkerExchange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPINoWalkerExchange(nprocs, my_rank, comm)</code></pre><p>Strategy for for not exchanging walkers between ranks. Consequently there will be no cross-rank annihilations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftStrategy" href="#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for updating the <code>shift</code> with <a href="API.html#Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any}"><code>update_shift()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.DontUpdate"><code>DontUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdate"><code>DelayedLogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>LogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>DelayedLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.HistoryLogUpdate"><code>HistoryLogUpdate</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL201-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{MPIData}" href="#Base.length-Tuple{MPIData}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(md::MPIData)</code></pre><p>Compute the length of the distributed data on every MPI rank with <code>MPI.Allreduce</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">norm(md::MPIData, p=2)</code></pre><p>Compute the norm of the distributed data on every MPI rank with <code>MPI.Allreduce</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.applyMemoryNoise!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}" href="#Rimu.applyMemoryNoise!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.applyMemoryNoise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">applyMemoryNoise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)</code></pre><p>Apply memory noise to <code>w</code> according to the strategy <code>m_strat</code>. Note that the strategy needs to be compatible with <code>StochasticStyle(w)</code>. The default is to not add memory noise. See <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a>.</p><p><code>w</code> is the walker array after fciqmc step, <code>v</code> the previous one, <code>pnorm</code> the norm of <code>v</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/fciqmc.jl#LL347-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.clearDFlags!-Tuple{Any}" href="#Rimu.clearDFlags!-Tuple{Any}"><code>Rimu.clearDFlags!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clearDFlags!(dv)</code></pre><p>Clear all flags in <code>dv</code> of the deterministic bit (rightmost bit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL504-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_col!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}" href="#Rimu.fciqmc_col!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.fciqmc_col!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fciqmc_col!(w, ham, add, num, shift, dτ)
fciqmc_col!(::Type{T}, args...)
-&gt; spawns, deaths, clones, antiparticles, annihilations</code></pre><p>Spawning and diagonal step of FCIQMC for single column of <code>ham</code>. In essence it computes</p><p><code>w .+= (1 .+ dτ.*(shift .- ham[:,add])).*num</code>.</p><p>Depending on <code>T ==</code><a href="API.html#Rimu.StochasticStyle"><code>StochasticStyle(w)</code></a>, a stochastic or deterministic algorithm will be chosen. The possible values for <code>T</code> are:</p><ul><li><a href="@ref"><code>IsDeterministic()</code></a> deteministic algorithm</li><li><a href="@ref"><code>IsStochastic()</code></a> stochastic version where the changes added to <code>w</code> are purely integer, according to the FCIQMC algorithm</li><li><a href="@ref"><code>IsStochasticNonlinear(c)</code></a> stochastic algorithm with nonlinear diagonal</li><li><a href="API.html#Rimu.IsSemistochastic"><code>IsSemistochastic()</code></a> semistochastic version: TODO</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/fciqmc.jl#LL465-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_step!-Union{Tuple{D}, Tuple{Any,D,Any,Any,Any,D}} where D" href="#Rimu.fciqmc_step!-Union{Tuple{D}, Tuple{Any,D,Any,Any,Any,D}} where D"><code>Rimu.fciqmc_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;
                      m_strat::MemoryStrategy = NoMemory()) -&gt; ṽ, w̃, stats</code></pre><p>Perform a single matrix(/operator)-vector multiplication:</p><div>\[\tilde{v} = [1 - dτ(\hat{H} - S)]⋅v ,\]</div><p>where <code>Ĥ == ham</code> and <code>S == shift</code>. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait <code>StochasticStyle(w)</code>. See <a href="API.html#Rimu.StochasticStyle"><code>StochasticStyle</code></a>. <code>w</code> is a local data structure with the same size and type as <code>v</code> and used for working. Both <code>v</code> and <code>w</code> are modified.</p><p>Returns the result <code>ṽ</code>, a (possibly changed) reference to working memory <code>w̃</code>,  and the array <code>stats = [spawns, deaths, clones, antiparticles, annihilations]</code>. Stats will contain zeros when running in deterministic mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/fciqmc.jl#LL230-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.next_mpiID" href="#Rimu.next_mpiID"><code>Rimu.next_mpiID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">next_mpiID()</code></pre><p>Produce a new ID number for MPI distributed objects. Uses an internal counter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.norm_project!-Tuple{Any,Any}" href="#Rimu.norm_project!-Tuple{Any,Any}"><code>Rimu.norm_project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm_project!(w, p_strat::ProjectStrategy) -&gt; norm</code></pre><p>Computes the 1-norm of <code>w</code>. Project all elements of <code>w</code> to <code>s.threshold</code> preserving the sign if <code>StochasticStyle(w)</code> requires projection according to <code>p_strat</code>. See <a href="API.html#Rimu.ProjectStrategy"><code>ProjectStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/fciqmc.jl#LL310-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}" href="#Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">report!(df::DataFrame, t::Tuple, s&lt;:ReportingStrategy)</code></pre><p>Record results in <code>df</code> and write informational messages according to strategy <code>s</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.setSemistochastic!-Tuple{Any,Float16,Any}" href="#Rimu.setSemistochastic!-Tuple{Any,Float16,Any}"><code>Rimu.setSemistochastic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setSemistochastic!(dv, threshold::Float16, d_space)</code></pre><p>Set the deterministic space for <code>dv</code> with threshold <code>threshold</code>, where <code>d_space</code> is a vector of addresses defining the the stochastic subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL489-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.sort_into_targets!-Tuple{Any,Any,Any}" href="#Rimu.sort_into_targets!-Tuple{Any,Any,Any}"><code>Rimu.sort_into_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_into_targets!(target, source, stats) -&gt; agg, wm, agg_stats</code></pre><p>Aggregate coefficients from <code>source</code> to <code>agg</code> and from <code>stats</code> to <code>agg_stats</code> according to thread- or MPI-level parallelism. <code>wm</code> passes back a reference to working memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/helpers.jl#LL15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.sort_into_targets!-Tuple{MPIData,AbstractDVec}" href="#Rimu.sort_into_targets!-Tuple{MPIData,AbstractDVec}"><code>Rimu.sort_into_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_into_targets!(target::MPIData, source)</code></pre><p>Distribute the entries of <code>source</code> to the <code>target</code> data structure such that all entries in the <code>target</code> dictionaries are on the process with the correct rank as controlled by <a href="API.html#Rimu.targetrank"><code>targetrank()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/mpi_helpers.jl#LL250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}" href="#Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}"><code>Rimu.update_dτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_dτ(s&lt;:TimeStepStrategy, dτ, args...) -&gt; new dτ</code></pre><p>Update the time step according to the strategy <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL110-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any}" href="#Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any}"><code>Rimu.update_shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_shift(s &lt;: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df)</code></pre><p>Update the shift according to strategy <code>s</code>. See <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/strategies_and_params.jl#LL356-L359">source</a></section></article><h2 id="Reexported-Submodules-1"><a class="docs-heading-anchor" href="#Reexported-Submodules-1">Reexported Submodules</a><a class="docs-heading-anchor-permalink" href="#Reexported-Submodules-1" title="Permalink"></a></h2><h3 id="Hamiltonians-1"><a class="docs-heading-anchor" href="#Hamiltonians-1">Hamiltonians</a><a class="docs-heading-anchor-permalink" href="#Hamiltonians-1" title="Permalink"></a></h3><p>Link to <a href="hamiltonians.html#Module-Hamiltionians.jl-1">Module <code>Hamiltionians.jl</code></a></p><h3 id="BitStringAddresses-1"><a class="docs-heading-anchor" href="#BitStringAddresses-1">BitStringAddresses</a><a class="docs-heading-anchor-permalink" href="#BitStringAddresses-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BSAdd128" href="#Rimu.BitStringAddresses.BSAdd128"><code>Rimu.BitStringAddresses.BSAdd128</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSAdd128 &lt;: BitStringAddressType</code></pre><p>Address type that encodes a bistring address in a UInt128.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BSAdd64" href="#Rimu.BitStringAddresses.BSAdd64"><code>Rimu.BitStringAddresses.BSAdd64</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSAdd64 &lt;: BitStringAddressType</code></pre><p>Address type that encodes a bistring address in a UInt64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BStringAdd" href="#Rimu.BitStringAddresses.BStringAdd"><code>Rimu.BitStringAddresses.BStringAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BStringAdd &lt;: BitStringAddressType</code></pre><p>Address type that encodes a bistring address in a one-dim. BitArray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BitAdd" href="#Rimu.BitStringAddresses.BitAdd"><code>Rimu.BitStringAddresses.BitAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BitAdd{I,B} &lt;: BitStringAddressType
BitAdd(address::Integer, B)
BitAdd(chunks::T, B) where T&lt;:Union{Tuple,SVector}
BitAdd{B}(address)</code></pre><p>Address type that encodes a bistring address with <code>B</code> bits. The bits are stored efficiently as <code>SVector</code> of <code>I</code> chunks of type <code>UInt64</code>. The two-argument constructor is preferred due to safety (consistency checks). In hot loops there maybe gain from the (unsafe) parametric constructor. If an integer <code>address</code> is passed, its bit representation  is used to initialize <code>BitAdd</code>. For large bit numbers, <code>BigInt</code> is convenient. <code>BitAdd[i]</code> will return bit <code>i</code> (as <code>Bool</code>), counting from right to left.</p><ul><li><code>BitAdd{B}()</code> creates a <code>BitAdd</code> with all ones.</li><li><code>zero(BitAdd{B})</code>  creates a <code>BitAdd</code> with all zeros.</li></ul><p>Note that no checking for ghost bits occurs when constructing <code>BitAdd</code> from <code>SVector</code> or <code>Tuple</code>. See <a href="@ref"><code>bitadd()</code></a>, <a href="@ref"><code>check_consistency()</code></a>, and <a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I"><code>remove_ghost_bits()</code></a> methods!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL219-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BitStringAddressType" href="#Rimu.BitStringAddresses.BitStringAddressType"><code>Rimu.BitStringAddresses.BitStringAddressType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BitStringAddressType</code></pre><p>Abstract type for configuration addresses with the nature of a bitstring. A number of methods need to be implemented, in particular <code>Base.isless(a,b)</code>, <code>numBits()</code>, <code>numChunks()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS" href="#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoseFS{N,M,A} &lt;: BosonicFockStateAddress &lt;: BitStringAddressType
BoseFS(bs::A) where A &lt;: BitAdd
BoseFS(bs::A, b)</code></pre><p>Address type that represents a Fock state of <code>N</code> spinless bosons in <code>M</code> orbitals by wrapping a bitstring of type <code>A</code>. Orbitals are stored in reverse order, i.e. the first orbital in a <code>BoseFS</code> is stored rightmost in the bitstring <code>bs</code>. If the number of significant bits <code>b</code> is not encoded in <code>A</code> it must be passed as an argument (e.g. for <code>BSAdd64</code> and <code>BSAdd128</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL619-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}" href="#Rimu.BitStringAddresses.BoseFS-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>Rimu.BitStringAddresses.BoseFS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoseFS(onr::T) where T&lt;:Union{AbstractVector,Tuple}
BoseFS{BST}(onr::T)</code></pre><p>Create <code>BoseFS</code> address from an occupation number representation, specifying the occupation number of each orbital. If a type <code>BST</code> is given it will define the underlying bit string type. Otherwise, the bit string type is chosen to fit the <code>onr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL656-L663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.bitaddr-Union{Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:Integer" href="#Rimu.BitStringAddresses.bitaddr-Union{Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:Integer"><code>Rimu.BitStringAddresses.bitaddr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bitaddr(onr, Type)</code></pre><p>Calculate a bitstring address from an occupation number representation the type of the bitstring address is passed as the second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL861-L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.nearUniform-Tuple{Any,Any}" href="#Rimu.BitStringAddresses.nearUniform-Tuple{Any,Any}"><code>Rimu.BitStringAddresses.nearUniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearUniform(N, M) -&gt; onr::SVector{M,Int}</code></pre><p>Create occupation number representation <code>onr</code> distributing <code>N</code> particles in <code>M</code> modes in a close-to-uniform fashion with each orbital filled with at least <code>N ÷ M</code> particles and at most with <code>N ÷ M + 1</code> particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL786-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{BoseFS{N,M,A}}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N" href="#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{BoseFS{N,M,A}}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.nearUniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearUniform(BoseFS{N,M})
nearUniform(BoseFS{N,M,A}) -&gt; bfs::BoseFS{N,M,A}</code></pre><p>Create bosonic Fock state with near uniform occupation number of <code>M</code> modes with a total of <code>N</code> particles. Specifying the bit address type <code>A</code> is optional.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nearUniform(BoseFS{7,5,BitAdd})
BoseFS{BitAdd}((2,2,1,1,1))

julia&gt; nearUniform(BoseFS{7,5})
BoseFS{BSAdd64}((2,2,1,1,1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL803-L817">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numBits-Tuple{Type}" href="#Rimu.BitStringAddresses.numBits-Tuple{Type}"><code>Rimu.BitStringAddresses.numBits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numBits(a)</code></pre><p>Number of bit chunks representing <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numChunks-Tuple{Type}" href="#Rimu.BitStringAddresses.numChunks-Tuple{Type}"><code>Rimu.BitStringAddresses.numChunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numChunks(a)</code></pre><p>Number of 64-bit chunks representing <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL29-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numModes-Tuple{Type}" href="#Rimu.BitStringAddresses.numModes-Tuple{Type}"><code>Rimu.BitStringAddresses.numModes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numModes(a)</code></pre><p>Number of modes represented by <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Rimu.BitStringAddresses.numParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numParticles(a)</code></pre><p>Number of particles represented by <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL50-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.onr-Union{Tuple{A}, Tuple{A,Integer}} where A&lt;:Integer" href="#Rimu.BitStringAddresses.onr-Union{Tuple{A}, Tuple{A,Integer}} where A&lt;:Integer"><code>Rimu.BitStringAddresses.onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onr(address, m)</code></pre><p>Compute and return the occupation number representation as an array of <code>Int</code> corresponding to the given address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL907-L912">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.onr-Union{Tuple{BoseFS{N,M,A}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N" href="#Rimu.BitStringAddresses.onr-Union{Tuple{BoseFS{N,M,A}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onr(bs)</code></pre><p>Compute and return the occupation number representation of the bit string address <code>bs</code> as an <code>SVector{M,Int}</code>, where <code>M</code> is the number of orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL750-L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BosonicFockStateAddress" href="#Rimu.BitStringAddresses.BosonicFockStateAddress"><code>Rimu.BitStringAddresses.BosonicFockStateAddress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BosonicFockStateAddress &lt;: BitStringAddressType</code></pre><p>Supertype representing a bosonic Fock state. Implement <a href="API.html#Rimu.BitStringAddresses.numModes-Tuple{Type}"><code>numModes()</code></a> and <a href="API.html#Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>numParticles()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;&lt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I" href="#Base.:&lt;&lt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">&lt;&lt;(b::BitAdd,n::Integer)</code></pre><p>Bitshift <code>b</code> to the left by <code>n</code> bits and fill from the right with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL469-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;&gt;&gt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I" href="#Base.:&gt;&gt;&gt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&gt;&gt;&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">&gt;&gt;&gt;(b::BitAdd,n::Integer)</code></pre><p>Bitshift <code>b</code> to the right by <code>n</code> bits and fill from the left with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL366-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.lbshr-Union{Tuple{I}, Tuple{N}, Tuple{StaticArrays.SArray{Tuple{N},I,1,N},Any}} where I where N" href="#Rimu.BitStringAddresses.lbshr-Union{Tuple{I}, Tuple{N}, Tuple{StaticArrays.SArray{Tuple{N},I,1,N},Any}} where I where N"><code>Rimu.BitStringAddresses.lbshr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lbshr(c,k)</code></pre><p>Apply logical bit shift to the right by <code>k</code> bits to <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL396-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I" href="#Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_ghost_bits(bs)</code></pre><p>Remove set bits outside data field if any are present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/BitStringAddresses.jl#LL335-L338">source</a></section></article><h3 id="DictVectors-1"><a class="docs-heading-anchor" href="#DictVectors-1">DictVectors</a><a class="docs-heading-anchor-permalink" href="#DictVectors-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors" href="#Rimu.DictVectors"><code>Rimu.DictVectors</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to <code>AbstractVector</code> nor to <code>AbstractDict</code> and are suitable for use with <code>KrylovKit.jl</code>. For this, the abstract type and interface <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a> is provided, with the following concrete subtypes:</p><ul><li><a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a></li><li><a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FastDVec"><code>FastDVec</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/DictVectors.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractDVec" href="#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DictVectors.AbstractDVec{K,V}</code></pre><p>Abstract type for sparse vectors with <code>valtype()</code> <code>V</code> based on dictionary-like structures. They behave like vectors except that indexing is performed with an arbitrary <code>keytype()</code> <code>K</code> (no order required). <code>getindex()</code> returns <code>zero(V)</code> for any unknown key and zeroed elements should be deleted with <code>delete!()</code>. Thus, iteration typically returns only non-zero entries. In variance to <code>AbstractVector</code>, <code>length()</code> will return the number of non-zero elements, while <code>capacity()</code> returns the holding capacity (assumed fixed) of the object. Even though <code>AbstractDVec</code> is similar to both <code>AbstractDict</code> and <code>AbstractVector</code>, it is explicitly not subtyped to either. The aim is to create data structures suitable for FCIQMC and compatible with KrylovKit.jl.</p><p><strong>Interface</strong></p><p>The interface is similar to the <code>AbstractDict</code> interface. Implement what would be needed for the <code>AbstractDict</code> interface (<code>setindex!, getindex, delete!, length, haskey, empty!, isempty</code>) and, in addition:</p><ul><li><code>capacity(dv)</code>: holding capacity</li><li><code>similar(dv [,Type])</code></li><li><code>iterate()</code>: should return values of type <code>V</code></li><li><code>pairs()</code>: should return an iterator over <code>key::K =&gt; content</code> pairs. If <code>content ≠ value::V</code> the provide <code>values()</code> iterator as well!</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.DFVec" href="#Rimu.DictVectors.DFVec"><code>Rimu.DictVectors.DFVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DFVec{K,V,F}(capacity) &lt;: AbstractDVec{K,V &lt;: Number}
DFVec(d::Dict [, capacity])
DFVec(v::Vector{V} [, capacity])</code></pre><p>Construct a wrapped dictionary with minimum capacity <code>capacity</code> to represent a vector-like object with <code>valtype(dv) == V</code>. The value of the <code>Dict</code> are of type <code>Tuple{V,F}</code>, which allows for storing a flag of type <code>F</code> for each entry. Indexing is done with an arbitrary (in general non-integer) <code>keytype(dv) == K</code>. When constructed from a <code>Vector{V}</code>, the keys will be integers <code>∈ [1, length(v)]</code> and the flag <code>zero(UInt16)</code>. See <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>. The method <a href="API.html#Rimu.DictVectors.capacity"><code>capacity()</code></a> is defined but not a strict upper limit as <code>Dict</code> objects can expand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.DVec" href="#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DVec{K,T}(capacity) &lt;: AbstractDVec{K,T}
DVec(d::Dict [, capacity])
DVec(v::Vector{T} [, capacity])</code></pre><p>Construct a wrapped dictionary with minimum capacity <code>capacity</code> to represent a vector-like object with <code>eltype(dv) == T</code>, which corresponds to the values of the <code>Dict</code>. Indexing is done with an arbitrary (in general non-integer) <code>keytype(dv) == K</code>. When constructed from a <code>Vector</code>, the keys will be integers ∈ <code>[0, length(v)]</code>. See <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>. The method <a href="API.html#Rimu.DictVectors.capacity"><code>capacity()</code></a> is defined but not a strict upper limit as <code>Dict</code> objects can expand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dvec.jl#LL1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.FastDVec" href="#Rimu.DictVectors.FastDVec"><code>Rimu.DictVectors.FastDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DictVectors.FastDVec{K,V}(capacity)</code></pre><p>Create a dictionary-like array indexed by keys of type <code>K</code> and values of type <code>V</code> with a maximum capacity of <code>capacity</code>.</p><pre><code class="language-none">FastDVec(a::AbstractArray, [capacity = length(a)])
FastDVec(d::AbstractDict{K,V}, [capacity = length(d)])
FastDVec(d::AbstractDVec{K,V}, [capacity = length(d)])</code></pre><p>Construct a <code>FastDVec</code> object from an existing array or dictionary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/fastdvec.jl#LL2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.NormProjector" href="#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormProjector()</code></pre><p>Results in computing the one-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia">dot(NormProjector(),x)
-&gt; norm(x,1) # with type valtype(x)</code></pre><p><code>NormProjector()</code> thus represents the vector <code>sign.(x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL373-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.UniformProjector" href="#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniformProjector()</code></pre><p>Represents a vector with all elements 1. To be used with <a href="@ref"><code>dot()</code></a>. Minimizes memory allocations.</p><pre><code class="language-julia">UniformProjector()⋅v == sum(v)
dot(UniformProjector(), LO, v) == sum(LO*v)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL357-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.add!-Union{Tuple{V2}, Tuple{V1}, Tuple{K}, Tuple{AbstractDVec{K,V1},AbstractDVec{K,V2}}} where V2 where V1 where K" href="#Rimu.DictVectors.add!-Union{Tuple{V2}, Tuple{V1}, Tuple{K}, Tuple{AbstractDVec{K,V1},AbstractDVec{K,V2}}} where V2 where V1 where K"><code>Rimu.DictVectors.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add!(x::AbstractDVec,y::AbstactDVec)</code></pre><p>Inplace add <code>x+y</code> and store result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL167-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.capacity" href="#Rimu.DictVectors.capacity"><code>Rimu.DictVectors.capacity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DictVectors.capacity(dv::AbstractDVec, [s = :effective])
capacity(dvs::Tuple, [s = :effective])</code></pre><p>gives the effective holding capacity of <code>dv</code>. If a tuple of <code>dvs</code> is given it aggregates the capacities.</p><p>Optional argument <code>s</code>:</p><ul><li><code>:effective</code>  the number of elements that</li></ul><p>can be stored savely (default)</p><ul><li><code>:allocated</code> actual internal memory allocation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.flags-Tuple{DFVec}" href="#Rimu.DictVectors.flags-Tuple{DFVec}"><code>Rimu.DictVectors.flags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flags(dv::DFVec)</code></pre><p>An iterator that yields flags stored in the <a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a> <code>dv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL218-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.gettuple-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any}} where F where V where K" href="#Rimu.DictVectors.gettuple-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any}} where F where V where K"><code>Rimu.DictVectors.gettuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gettuple(dv::DFVec, key)</code></pre><p>Retrieve the tuple <code>(v,f)</code> stored at the given <code>key</code>. If the key is not found, return a tuple of zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.kvpairs-Tuple{Any}" href="#Rimu.DictVectors.kvpairs-Tuple{Any}"><code>Rimu.DictVectors.kvpairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kvpairs(collection)</code></pre><p>Return an iterator over <code>key =&gt; value</code> pairs ignoring any flags. If no flags are present, eg. for generic <code>AbstractDVec</code>, this falls back to <a href="@ref"><code>Base.pairs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL306-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.kvpairs-Tuple{DFVec}" href="#Rimu.DictVectors.kvpairs-Tuple{DFVec}"><code>Rimu.DictVectors.kvpairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kvpairs(dv::DFVec)</code></pre><p>An iterator that yields <code>key =&gt; value</code> pairs stored in the <a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a> <code>dv</code> ignoring any <code>flags</code>. In contrast, <code>Base.pairs()</code> will return pairs <code>key =&gt; (value, flag)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL242-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.pairtype-Tuple{Any}" href="#Rimu.DictVectors.pairtype-Tuple{Any}"><code>Rimu.DictVectors.pairtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pairtype(dv)</code></pre><p>Returns the type of stored data, as returned by the <code>pairs()</code> iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.tuples-Tuple{DFVec}" href="#Rimu.DictVectors.tuples-Tuple{DFVec}"><code>Rimu.DictVectors.tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tuples(dv::DFVec)</code></pre><p>An iterator that yields tuples <code>(v, f)</code> with value <code>v</code> and flag <code>f</code> stored in the <a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a> <code>dv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.zero!-Tuple{AbstractDVec}" href="#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero!(v::AbstractDVec)</code></pre><p>Replace <code>v</code> by a zero vector as an inplace operation. For <code>AbstractDVec</code> types it means removing all non-zero elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.ADVPairsIterator" href="#Rimu.DictVectors.ADVPairsIterator"><code>Rimu.DictVectors.ADVPairsIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ADVPairsIterator</code></pre><p>Iterator type for pairs from a <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL293-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.FlagsIterator" href="#Rimu.DictVectors.FlagsIterator"><code>Rimu.DictVectors.FlagsIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FlagsIterator</code></pre><p>Iterator type returned by <a href="API.html#Rimu.DictVectors.flags-Tuple{DFVec}"><code>flags()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL207-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.KVPairsIterator" href="#Rimu.DictVectors.KVPairsIterator"><code>Rimu.DictVectors.KVPairsIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KVPairsIterator</code></pre><p>Iterator type returned by <a href="API.html#Rimu.DictVectors.kvpairs-Tuple{Any}"><code>kvpairs()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL231-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fill!-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDVec{K,V},V}} where V where K" href="#Base.fill!-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDVec{K,V},V}} where V where K"><code>Base.fill!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill!(da::AbstractDVec, x)</code></pre><p>Empties <code>da</code> if <code>x==zero(valtype(da))</code> and throws an error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL148-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Tuple{DFVec,Any,Tuple}" href="#Base.get-Tuple{DFVec,Any,Tuple}"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get(dv::DFVec, key, deftup::Tuple)</code></pre><p>Return tuple containing value and flag if <code>key</code> exists and otherwise <code>deftup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL124-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any,Number}} where F where V where K" href="#Base.get-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any,Number}} where F where V where K"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get(dv::DFVec, key, defnum::Number)</code></pre><p>Return value only if <code>key</code> exists and otherwise <code>defnum</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL130-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{AbstractDVec,AbstractDVec}" href="#Base.isequal-Tuple{AbstractDVec,AbstractDVec}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequal(l::AbstractDVec, r::AbstractDVec)</code></pre><p>Returns <code>true</code> if all non-zero entries have the same value. Equality of flags is not tested unless both <code>l</code> and <code>r</code> support flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{DFVec,DFVec}" href="#Base.isequal-Tuple{DFVec,DFVec}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequal(l::DFVec, r::DFVec)</code></pre><p>Returns <code>true</code> if all non-zero entries have the same value and the same flag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/dfvec.jl#LL326-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.axpy!-Tuple{Number,AbstractDVec,AbstractDVec}" href="#LinearAlgebra.axpy!-Tuple{Number,AbstractDVec,AbstractDVec}"><code>LinearAlgebra.axpy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">axpy!(α::Number, X::AbstractDVec, Y::AbstractDVec)
axpy!(α::Number, X::AbstractDVec, Ys::Tuple, batchsize)</code></pre><p>Overwrite <code>Y</code> with <code>α*X + Y</code> where <code>α</code> is scalar for <code>AbstractDVec</code>s. If a tuple <code>Ys</code> is passed with <code>Threads.nthreads()</code> <code>AbstractDVec</code>s, then perform the operation in parallel over threads with <code>batchsize</code> elements at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL179-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractDVec,Real}" href="#LinearAlgebra.norm-Tuple{AbstractDVec,Real}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(x::AbstractDVec, p)</code></pre><p>Computes the p-norm of the DVec x. Implemented for <code>p ∈ {1, 2, Inf}</code>. Returns zero if <code>x</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractDVec}" href="#LinearAlgebra.norm-Tuple{AbstractDVec}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(x::AbstractDVec{K,V})</code></pre><p>Computes the 2-norm of the DVec x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL82-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.normInf-Tuple{AbstractDVec}" href="#Rimu.DictVectors.normInf-Tuple{AbstractDVec}"><code>Rimu.DictVectors.normInf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normInf(x::AbstractDVec)</code></pre><p>Infinity norm: largest absolute value of entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.norm_sqr-Union{Tuple{AbstractDVec{K,V}}, Tuple{K}, Tuple{V}} where K where V&lt;:Number" href="#Rimu.DictVectors.norm_sqr-Union{Tuple{AbstractDVec{K,V}}, Tuple{K}, Tuple{V}} where K where V&lt;:Number"><code>Rimu.DictVectors.norm_sqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm_sqr(x::AbstractDVec)</code></pre><p>Fast calculation of the square of the 2-norm of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/DictVectors/abstractdvec.jl#LL74-L77">source</a></section></article><h3 id="Blocking-1"><a class="docs-heading-anchor" href="#Blocking-1">Blocking</a><a class="docs-heading-anchor-permalink" href="#Blocking-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking" href="#Rimu.Blocking"><code>Rimu.Blocking</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>Blocking</code></p><p>Module that contains functions performing the Flyvbjerg-Petersen blocking analysis for evaluating the standard error on a correlated data set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocker-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.blocker-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Reblock the data by successively taking the mean of adjacent data points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL38-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking-Tuple{Array{T,1} where T,Array{T,1} where T}" href="#Rimu.Blocking.blocking-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a> — <span class="docstring-category">Method</span></header><section><div><p>perform a blocking analysis for two data sets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL112-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.blocking-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a> — <span class="docstring-category">Method</span></header><section><div><p>perform a blocking analysis for single data set</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL49-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blockingErrorEstimation-Tuple{DataFrames.DataFrame}" href="#Rimu.Blocking.blockingErrorEstimation-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.blockingErrorEstimation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>estimating stnadard error from blocking analysis based on the overlapping of error bars, if all the error bars (or more than 3 on a roll) behind current one are overlapping with it, return the current standard error with error bar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}" href="#Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.mtest</code></a> — <span class="docstring-category">Method</span></header><section><div><p>The &quot;M test&quot; based on Jonsson, M. Physical Review E, 98(4), 043304, (2018). If the blocking analysis (BA) has passed the M test, an error estimation will be given based on the smallest k (i.e. meaningful results at the k-th data point on a BA plot).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.combination_division-Tuple{Array{T,1} where T,Array{T,1} where T}" href="#Rimu.Blocking.combination_division-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.combination_division</code></a> — <span class="docstring-category">Method</span></header><section><div><p>find the standard error on standard errors on two datasets</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL92-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.covariance-Tuple{Array{T,1} where T,Array{T,1} where T}" href="#Rimu.Blocking.covariance-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.covariance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate the covariance between the two data sets vi and vj.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL72-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.sd-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.sd-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.sd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate the standard deviation of the dataset v</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL28-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.se-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.se-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.se</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate the standard error of the dataset v</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL33-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.variance-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.variance-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.variance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate the variance of the dataset v</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/Blocking.jl#LL13-L15">source</a></section></article><h2 id="Unexported-Submodules-1"><a class="docs-heading-anchor" href="#Unexported-Submodules-1">Unexported Submodules</a><a class="docs-heading-anchor-permalink" href="#Unexported-Submodules-1" title="Permalink"></a></h2><h3 id="FastBufs-1"><a class="docs-heading-anchor" href="#FastBufs-1">FastBufs</a><a class="docs-heading-anchor-permalink" href="#FastBufs-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.FastBufs" href="#Rimu.FastBufs"><code>Rimu.FastBufs</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Provides the <code>FastBuf</code> data structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/FastBufs.jl#LL1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FastBufs.FastBuf" href="#Rimu.FastBufs.FastBuf"><code>Rimu.FastBufs.FastBuf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FastBuf{T}(n)</code></pre><p>Create a first-in-last-out buffer of maximum capacity <code>n</code>. The element type is <code>T</code>. Fill a FastBuf with <code>push!()</code>, retrieve with <code>pop!()</code>. Accessing elements with <code>getindex()</code> and <code>setindex!()</code> as well as iteration are also supported. Check the capacity of a <code>FastBuf</code> with <code>capacity()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/FastBufs.jl#LL12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FastBufs.capacity-Tuple{FastBuf}" href="#Rimu.FastBufs.capacity-Tuple{FastBuf}"><code>Rimu.FastBufs.capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gives the capacity of a <code>FastBuf</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/src/accb9e8fd76cb528ae816d2af5d88fb521ed5a8b/src/FastBufs.jl#LL39">source</a></section></article><h3 id="ConsistentRNG-1"><a class="docs-heading-anchor" href="#ConsistentRNG-1">ConsistentRNG</a><a class="docs-heading-anchor-permalink" href="#ConsistentRNG-1" title="Permalink"></a></h3><p>Link to <a href="consistentrng.html#Module-ConsistentRNG.jl-1">Module <code>ConsistentRNG.jl</code></a></p><h1 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h1><ul><li><a href="API.html#Rimu.Blocking"><code>Rimu.Blocking</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG"><code>Rimu.ConsistentRNG</code></a></li><li><a href="API.html#Rimu.DictVectors"><code>Rimu.DictVectors</code></a></li><li><a href="API.html#Rimu.FastBufs"><code>Rimu.FastBufs</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a></li><li><a href="API.html#Rimu.Rimu"><code>Rimu.Rimu</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BSAdd128"><code>Rimu.BitStringAddresses.BSAdd128</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BSAdd64"><code>Rimu.BitStringAddresses.BSAdd64</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BStringAdd"><code>Rimu.BitStringAddresses.BStringAdd</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BitAdd"><code>Rimu.BitStringAddresses.BitAdd</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BitStringAddressType"><code>Rimu.BitStringAddresses.BitStringAddressType</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>Rimu.BitStringAddresses.BoseFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BosonicFockStateAddress"><code>Rimu.BitStringAddresses.BosonicFockStateAddress</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNG"><code>Rimu.ConsistentRNG.CRNG</code></a></li><li><a href="API.html#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdate"><code>Rimu.DelayedLogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>Rimu.DelayedLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a></li><li><a href="API.html#Rimu.DictVectors.ADVPairsIterator"><code>Rimu.DictVectors.ADVPairsIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.DFVec"><code>Rimu.DictVectors.DFVec</code></a></li><li><a href="API.html#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FastDVec"><code>Rimu.DictVectors.FastDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FlagsIterator"><code>Rimu.DictVectors.FlagsIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.KVPairsIterator"><code>Rimu.DictVectors.KVPairsIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a></li><li><a href="API.html#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>Rimu.DoubleLogUpdateAfterTargetWalkersSwitch</code></a></li><li><a href="API.html#Rimu.EveryKthStep"><code>Rimu.EveryKthStep</code></a></li><li><a href="API.html#Rimu.EveryTimeStep"><code>Rimu.EveryTimeStep</code></a></li><li><a href="API.html#Rimu.FastBufs.FastBuf"><code>Rimu.FastBufs.FastBuf</code></a></li><li><a href="API.html#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D"><code>Rimu.Hamiltonians.BoseHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BosonicHamiltonian"><code>Rimu.Hamiltonians.BosonicHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedBHReal1D"><code>Rimu.Hamiltonians.ExtendedBHReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Hops"><code>Rimu.Hamiltonians.Hops</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LinearOperator"><code>Rimu.Hamiltonians.LinearOperator</code></a></li><li><a href="API.html#Rimu.HistoryLogUpdate"><code>Rimu.HistoryLogUpdate</code></a></li><li><a href="API.html#Rimu.IsSemistochastic"><code>Rimu.IsSemistochastic</code></a></li><li><a href="API.html#Rimu.IsStochasticWithThreshold"><code>Rimu.IsStochasticWithThreshold</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.MPIData"><code>Rimu.MPIData</code></a></li><li><a href="API.html#Rimu.MPIDefault"><code>Rimu.MPIDefault</code></a></li><li><a href="API.html#Rimu.MPINoWalkerExchange"><code>Rimu.MPINoWalkerExchange</code></a></li><li><a href="API.html#Rimu.MPIOSWin"><code>Rimu.MPIOSWin</code></a></li><li><a href="API.html#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a></li><li><a href="API.html#Rimu.NoMemory"><code>Rimu.NoMemory</code></a></li><li><a href="API.html#Rimu.NoProjection"><code>Rimu.NoProjection</code></a></li><li><a href="API.html#Rimu.OvershootControl"><code>Rimu.OvershootControl</code></a></li><li><a href="API.html#Rimu.ProjectStrategy"><code>Rimu.ProjectStrategy</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a></li><li><a href="API.html#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a></li><li><a href="API.html#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a></li><li><a href="API.html#Rimu.ScaledThresholdProject"><code>Rimu.ScaledThresholdProject</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a></li><li><a href="API.html#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a></li><li><a href="API.html#Rimu.StochasticStyle"><code>Rimu.StochasticStyle</code></a></li><li><a href="API.html#Rimu.ThresholdProject"><code>Rimu.ThresholdProject</code></a></li><li><a href="API.html#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a></li><li><a href="API.html#Base.:&lt;&lt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&lt;&lt;</code></a></li><li><a href="API.html#Base.:&gt;&gt;&gt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&gt;&gt;&gt;</code></a></li><li><a href="API.html#Base.fill!-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDVec{K,V},V}} where V where K"><code>Base.fill!</code></a></li><li><a href="API.html#Base.get-Tuple{DFVec,Any,Tuple}"><code>Base.get</code></a></li><li><a href="API.html#Base.get-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any,Number}} where F where V where K"><code>Base.get</code></a></li><li><a href="API.html#Base.isequal-Tuple{AbstractDVec,AbstractDVec}"><code>Base.isequal</code></a></li><li><a href="API.html#Base.isequal-Tuple{DFVec,DFVec}"><code>Base.isequal</code></a></li><li><a href="API.html#Base.length-Tuple{MPIData}"><code>Base.length</code></a></li><li><a href="API.html#LinearAlgebra.axpy!-Tuple{Number,AbstractDVec,AbstractDVec}"><code>LinearAlgebra.axpy!</code></a></li><li><a href="API.html#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li><li><a href="API.html#LinearAlgebra.norm-Tuple{AbstractDVec}"><code>LinearAlgebra.norm</code></a></li><li><a href="API.html#LinearAlgebra.norm-Tuple{AbstractDVec,Real}"><code>LinearAlgebra.norm</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.bitaddr-Union{Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:Integer"><code>Rimu.BitStringAddresses.bitaddr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.lbshr-Union{Tuple{I}, Tuple{N}, Tuple{StaticArrays.SArray{Tuple{N},I,1,N},Any}} where I where N"><code>Rimu.BitStringAddresses.lbshr</code></a></li><li><a href="hamiltonians.html#Rimu.BitStringAddresses.nearUniform"><code>Rimu.BitStringAddresses.nearUniform</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{BoseFS{N,M,A}}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.nearUniform</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.nearUniform-Tuple{Any,Any}"><code>Rimu.BitStringAddresses.nearUniform</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numBits-Tuple{Type}"><code>Rimu.BitStringAddresses.numBits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numChunks-Tuple{Type}"><code>Rimu.BitStringAddresses.numChunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numModes-Tuple{Type}"><code>Rimu.BitStringAddresses.numModes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Rimu.BitStringAddresses.numParticles</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.onr-Union{Tuple{BoseFS{N,M,A}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.onr-Union{Tuple{A}, Tuple{A,Integer}} where A&lt;:Integer"><code>Rimu.BitStringAddresses.onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a></li><li><a href="API.html#Rimu.Blocking.blocker-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocker</code></a></li><li><a href="API.html#Rimu.Blocking.blocking-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a></li><li><a href="API.html#Rimu.Blocking.blocking-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a></li><li><a href="API.html#Rimu.Blocking.blockingErrorEstimation-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.blockingErrorEstimation</code></a></li><li><a href="API.html#Rimu.Blocking.combination_division-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.combination_division</code></a></li><li><a href="API.html#Rimu.Blocking.covariance-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.covariance</code></a></li><li><a href="API.html#Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.mtest</code></a></li><li><a href="API.html#Rimu.Blocking.sd-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.sd</code></a></li><li><a href="API.html#Rimu.Blocking.se-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.se</code></a></li><li><a href="API.html#Rimu.Blocking.variance-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.variance</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple"><code>Rimu.ConsistentRNG.cRand</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.newChildRNG"><code>Rimu.ConsistentRNG.newChildRNG</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Array{T,1} where T}"><code>Rimu.ConsistentRNG.seedCRNG!</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}"><code>Rimu.ConsistentRNG.trng</code></a></li><li><a href="API.html#Rimu.DictVectors.add!-Union{Tuple{V2}, Tuple{V1}, Tuple{K}, Tuple{AbstractDVec{K,V1},AbstractDVec{K,V2}}} where V2 where V1 where K"><code>Rimu.DictVectors.add!</code></a></li><li><a href="API.html#Rimu.DictVectors.capacity"><code>Rimu.DictVectors.capacity</code></a></li><li><a href="API.html#Rimu.DictVectors.flags-Tuple{DFVec}"><code>Rimu.DictVectors.flags</code></a></li><li><a href="API.html#Rimu.DictVectors.gettuple-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any}} where F where V where K"><code>Rimu.DictVectors.gettuple</code></a></li><li><a href="API.html#Rimu.DictVectors.kvpairs-Tuple{Any}"><code>Rimu.DictVectors.kvpairs</code></a></li><li><a href="API.html#Rimu.DictVectors.kvpairs-Tuple{DFVec}"><code>Rimu.DictVectors.kvpairs</code></a></li><li><a href="API.html#Rimu.DictVectors.normInf-Tuple{AbstractDVec}"><code>Rimu.DictVectors.normInf</code></a></li><li><a href="API.html#Rimu.DictVectors.norm_sqr-Union{Tuple{AbstractDVec{K,V}}, Tuple{K}, Tuple{V}} where K where V&lt;:Number"><code>Rimu.DictVectors.norm_sqr</code></a></li><li><a href="API.html#Rimu.DictVectors.pairtype-Tuple{Any}"><code>Rimu.DictVectors.pairtype</code></a></li><li><a href="API.html#Rimu.DictVectors.tuples-Tuple{DFVec}"><code>Rimu.DictVectors.tuples</code></a></li><li><a href="API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a></li><li><a href="API.html#Rimu.FastBufs.capacity-Tuple{FastBuf}"><code>Rimu.FastBufs.capacity</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.bit_String_Length"><code>Rimu.Hamiltonians.bit_String_Length</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.diagME"><code>Rimu.Hamiltonians.diagME</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimensionLO"><code>Rimu.Hamiltonians.dimensionLO</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.fDimensionLO"><code>Rimu.Hamiltonians.fDimensionLO</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.generateRandHop"><code>Rimu.Hamiltonians.generateRandHop</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.hasIntDimension"><code>Rimu.Hamiltonians.hasIntDimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.hop"><code>Rimu.Hamiltonians.hop</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.numOfHops"><code>Rimu.Hamiltonians.numOfHops</code></a></li><li><a href="API.html#Rimu.applyMemoryNoise!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.applyMemoryNoise!</code></a></li><li><a href="API.html#Rimu.clearDFlags!-Tuple{Any}"><code>Rimu.clearDFlags!</code></a></li><li><a href="API.html#Rimu.fciqmc!"><code>Rimu.fciqmc!</code></a></li><li><a href="API.html#Rimu.fciqmc_col!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.fciqmc_col!</code></a></li><li><a href="API.html#Rimu.fciqmc_step!-Union{Tuple{D}, Tuple{Any,D,Any,Any,Any,D}} where D"><code>Rimu.fciqmc_step!</code></a></li><li><a href="API.html#Rimu.free-Tuple{MPIOSWin}"><code>Rimu.free</code></a></li><li><a href="API.html#Rimu.greet-Tuple{}"><code>Rimu.greet</code></a></li><li><a href="API.html#Rimu.mpi_default"><code>Rimu.mpi_default</code></a></li><li><a href="API.html#Rimu.mpi_no_exchange"><code>Rimu.mpi_no_exchange</code></a></li><li><a href="API.html#Rimu.mpi_one_sided"><code>Rimu.mpi_one_sided</code></a></li><li><a href="API.html#Rimu.next_mpiID"><code>Rimu.next_mpiID</code></a></li><li><a href="API.html#Rimu.norm_project!-Tuple{Any,Any}"><code>Rimu.norm_project!</code></a></li><li><a href="API.html#Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T"><code>Rimu.put</code></a></li><li><a href="API.html#Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.setSemistochastic!-Tuple{Any,Float16,Any}"><code>Rimu.setSemistochastic!</code></a></li><li><a href="API.html#Rimu.sort_into_targets!-Tuple{Any,Any,Any}"><code>Rimu.sort_into_targets!</code></a></li><li><a href="API.html#Rimu.sort_into_targets!-Tuple{MPIData,AbstractDVec}"><code>Rimu.sort_into_targets!</code></a></li><li><a href="API.html#Rimu.targetrank"><code>Rimu.targetrank</code></a></li><li><a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}"><code>Rimu.update_dτ</code></a></li><li><a href="API.html#Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any}"><code>Rimu.update_shift</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="testing.html">« Code testing</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 29 June 2020 05:22">Monday 29 June 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
