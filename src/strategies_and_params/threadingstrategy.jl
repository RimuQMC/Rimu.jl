"""
    fciqmc_step!(t_strat::ThreadingStrategy, w, ham, v, shift, dτ) -> stat_names, stats

Perform a single matrix(/operator)-vector multiplication:

```math
v^{(n + 1)} = [1 - dτ(\\hat{H} - S)]⋅v^{(n)} ,
```

where `Ĥ == ham` and `S == shift`.

Whether the operation is performed in stochastic, semistochastic, or determistic way is
controlled by the trait `StochasticStyle(w)`. See [`StochasticStyle`](@ref).

Returns the step stats generated by the `StochasticStyle`.
"""
function fciqmc_step!(working_memory, curr_dv, prev_dv, ham, shift, dτ)
    v = localpart(curr_dv)
    @assert working_memory ≢ v "`w` and `v` must not be the same object"
    zero!(working_memory)

    stat_names, stats = step_stats(v, Val(1))
    for (add, val) in pairs(v)
        stats += fciqmc_col!(working_memory, ham, add, val, shift, dτ)
    end
    # Now, working_memory holds the new values and curr_dv holds previous values.
    # Swap curr and prev, then sort the wm into the (new) curr.
    curr_dv, prev_dv = (prev_dv, curr_dv)
    curr_dv, working_memory, stats = sort_into_targets!(curr_dv, working_memory, stats)

    return stat_names, stats, working_memory, curr_dv, prev_dv
end

"""
    working_memory(t_strat::ThreadingStrategy, dv)

Create a working memory instance compatible with `t_strat`. The working memory must be
compatible with [`sort_into_targets!`](@ref).
"""
working_memory(dv) = similar(localpart(dv))

"""
    sort_into_targets!(target, source, stats) -> agg, wm, agg_stats
Aggregate coefficients from `source` to `agg` and from `stats` to `agg_stats`
according to thread- or MPI-level parallelism. `wm` passes back a reference to
working memory.
"""
sort_into_targets!(dv::T, wm::T, stats) where {T} = wm, dv, stats
