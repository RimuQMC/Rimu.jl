"""
    AbstractDVec{K,V}

Abstract type for data structures that behave similar to sparse vectors, but are indexed
by an arbitrary type `V` (could be non-integers) similarly to dictionaries. `AbstractDVec`s
are  designed to work well with [`lomc!`](@ref Main.lomc!) and
[KrylovKit](https://github.com/Jutho/KrylovKit.jl).

Concrete implementations are available as [`DVec`](@ref Main.DictVectors.DVec)
and [`InitiatorDVec`](@ref Main.DictVectors.InitiatorDVec).

`AbstractDvec`s lie somewhere between `AbstractDict`s and sparse `AbstractVector`s, while
being subtyped to neither.
Generally they behave
like a dictionary, while supportting various linear algebra functionality. Indexing with a
value not stored in the dictionary returns `zero(V)`. Setting a stored value to 0 or below
`eps(V::AbstractFloat)` removes the value from the dictionary. Their `length` signals the
number of stored elements, not the size of the vector space.

They have a [`StochasticStyle`](@ref) which selects the spawning algorithm in `FCIQMC`.

To iterate over an `AbstractDVec`, use `keys`, `pairs`, or `values`.

# Interface

The interface is similar to the `AbstractDict` interface, but with the changed behaviour
as noted above.
Implement what would be needed for the `AbstractDict` interface (`pairs`, `keys`, `values`,
`setindex!, getindex, delete!, length, haskey, empty!, isempty`) and, in addition:
* [`StochasticStyle`](@ref)
* [`storage`](@ref) returns an `AbstractDict` storing the raw data with possibly
  different `valtype` than `V`.
* [`deposit!`](@ref)

See also [`DictVectors`](@ref Main.DictVectors), [`Interfaces`](@ref).
"""
abstract type AbstractDVec{K,V} end

"""
    deposit!(w::AbstractDVec, add, val, parent::Pair)

Add `val` into `w` at address `add`, taking into account initiator rules if applicable.
`parent` contains the `address => value` pair from which the pair `add => val`
was created. [`InitiatorDVec`](@ref Main.DictVectors.InitiatorDVec) can intercept this and add its own functionality.
"""
function deposit!(w, add, val, _)
    w[add] += convert(valtype(w), val)
end

"""
    zero!(v)

Replace `v` by a zero vector as an inplace operation. For `AbstractDVec` types it means
removing all non-zero elements. For `AbstractArrays`, it sets all of the values to zero.
"""
zero!(v::AbstractVector{T}) where {T} = v .= zero(T)

"""
    localpart(dv) -> AbstractDVec

Get the part of `dv` that is located on this MPI rank. Returns `dv` itself for
`AbstractDVec`s.
"""
localpart(dv) = dv # default for local data

"""
    storage(dvec) -> AbstractDict

Return the raw storage associated with `dvec` as an `AbstractDict`. Used in MPI
communication.
"""
storage(v::AbstractVector) = v

StochasticStyle(::AbstractArray{T}) where {T} = default_style(T)

"""
    freeze(dv)

Create a "frozen" version of `dv` which can no longer be modified or used in the
conventional manner, but supports faster dot products.

If `dv` is an [`MPIData`](@ref Main.Rimu.RMPI.MPIData), synchronize its contents among the ranks first.
"""
freeze(v::AbstractVector) = copy(v)

"""
    working_memory(dv::AbstractDVec)

Create a working memory instance compatible with `dv`. The working memory must be
compatible with [`sort_into_targets!`](@ref) and [`fciqmc_step!`](@ref).
"""
working_memory(dv) = similar(localpart(dv))

"""
    fciqmc_step!(working_memory, curr_dv, prev_dv, ham, shift, dτ) -> stat_names, stats, working_memory, curr_dv, prev_dv

Perform a single matrix(/operator)-vector multiplication:

```math
v^{(n + 1)} = [1 - dτ(\\hat{H} - S)]⋅v^{(n)} ,
```

where `Ĥ == ham` and `S == shift`.

Whether the operation is performed in stochastic, semistochastic, or determistic way is
controlled by the trait `StochasticStyle(w)`. See [`StochasticStyle`](@ref).

Returns the step stats generated by the `StochasticStyle`, the current and previous vectors
and the working memory.
"""
function fciqmc_step!(working_memory, curr_dv, prev_dv, ham, shift, dτ)
    v = localpart(curr_dv)
    @assert working_memory ≢ v "`w` and `v` must not be the same object"
    zero!(working_memory)

    stat_names, stats = step_stats(v)
    for (add, val) in pairs(v)
        stats += fciqmc_col!(working_memory, ham, add, val, shift, dτ)
    end
    # Now, working_memory holds the new values and curr_dv holds previous values.
    # Swap curr and prev, then sort the wm into the (new) curr.
    curr_dv, prev_dv = (prev_dv, curr_dv)
    curr_dv, working_memory, stats = sort_into_targets!(curr_dv, working_memory, stats)

    return stat_names, stats, working_memory, curr_dv, prev_dv
end

"""
    sort_into_targets!(target, source, stats) -> agg, wm, agg_stats

Aggregate coefficients from `source` to `agg` and from `stats` to `agg_stats`
according to thread- or MPI-level parallelism. `wm` passes back a reference to
working memory.
"""
sort_into_targets!(dv::T, wm::T, stats) where {T} = wm, dv, stats
