<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calculating observables · Rimu.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Rimu.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Guide</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="BHM-example.html">1D Bose-Hubbard Model</a></li><li><a class="tocitem" href="BHM-example-mpi.html">Rimu with MPI</a></li><li class="is-active"><a class="tocitem" href="G2-example.html">Calculating observables</a></li><li><a class="tocitem" href="exact-example.html">Exact diagonalisation</a></li></ul></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="../statstools.html">StatsTools</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="../dictvectors.html">Dict vectors</a></li><li><a class="tocitem" href="../addresses.html">BitString addresses</a></li><li><a class="tocitem" href="../stochasticstyles.html">Stochastic styles</a></li><li><a class="tocitem" href="../RMPI.html">RMPI</a></li><li><a class="tocitem" href="../rimuio.html">I/O</a></li><li><a class="tocitem" href="../randomnumbers.html">Random numbers</a></li><li><a class="tocitem" href="../documentation.html">Documentation generation</a></li><li><a class="tocitem" href="../testing.html">Code testing</a></li></ul></li><li><a class="tocitem" href="../API.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="G2-example.html">Calculating observables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="G2-example.html">Calculating observables</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/develop/scripts/G2-example.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-3:-Calculating-observables"><a class="docs-heading-anchor" href="#Example-3:-Calculating-observables">Example 3: Calculating observables</a><a id="Example-3:-Calculating-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Calculating-observables" title="Permalink"></a></h1><p>This is an example calculation of the two-body correlation function G_2.</p><p>A runnable script for this example is located <a href="https://github.com/joachimbrand/Rimu.jl/blob/develop/scripts/G2-example.jl">here</a>. Run it with <code>julia G2-example.jl</code>.</p><p>Firstly, we load all needed modules. <code>Rimu</code> for FCIQMC calculation, and <code>DataFrames</code> for output</p><pre><code class="language-julia hljs">using Rimu
using Random
using DataFrames</code></pre><p>We use the same Hamiltonian as the first example, a Bose-Hubbard model with 6 particles in 6 sites, with strong interactions (we expect a Mott insulating state).</p><pre><code class="language-julia hljs">m = n = 6
aIni = near_uniform(BoseFS{n,m})
H = HubbardReal1D(aIni; u = 6.0, t = 1.0)</code></pre><pre><code class="nohighlight hljs">HubbardReal1D(BoseFS{6,6}((1, 1, 1, 1, 1, 1)); u=6.0, t=1.0)</code></pre><p>Now we define the operators for the observables we wish to calculate</p><pre><code class="language-julia hljs">dvals = 0:m-1
G2list = ([G2RealCorrelator(d) for d in dvals]...,)</code></pre><pre><code class="nohighlight hljs">(G2RealCorrelator(0), G2RealCorrelator(1), G2RealCorrelator(2), G2RealCorrelator(3), G2RealCorrelator(4), G2RealCorrelator(5))</code></pre><p>This is a tuple of <a href="../hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a>s, which are subtyped to <a href="../hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>, but with less functionality than a full Hamiltonian. It calculates the two-body correlation function on a lattice</p><p class="math-container">\[    \hat{G}^{(2)}(d) = \frac{1}{M} \sum_i^M \hat{n}_i (\hat{n}_{i+d} - \delta_{0d}).\]</p><p>with normalisation</p><p class="math-container">\[    \sum_{d=0}^{M-1} \langle \hat{G}^{(2)}(d) \rangle = \frac{N (N-1)}{M}.\]</p><p>Observables are calculated using the &quot;replica trick&quot; whereby several copies or &quot;replicas&quot; of the model are run simultaneously. We enable this by defining a <a href="../API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a>. Each replica has its own state and FCIQMC is effectively performed independently on each one. For calculating observables, we use <a href="../API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a> for the <code>ReplicaStrategy</code>. At each timestep, after the necessary FCIQMC variables are calculated for each replica, (e.g. shift, norm etc.), this strategy calculates the overlaps of every operator with the wavefunctions from each pair of replicas.</p><pre><code class="language-julia hljs">num_reps = 3
replica = AllOverlaps(num_reps; operator = G2list)</code></pre><pre><code class="nohighlight hljs">AllOverlaps{3, 6, Tuple{G2RealCorrelator{0}, G2RealCorrelator{1}, G2RealCorrelator{2}, G2RealCorrelator{3}, G2RealCorrelator{4}, G2RealCorrelator{5}}, true}((G2RealCorrelator(0), G2RealCorrelator(1), G2RealCorrelator(2), G2RealCorrelator(3), G2RealCorrelator(4), G2RealCorrelator(5)))</code></pre><p>We need a reasonable number of timesteps to get good statistics, and we are running multiple replicas, so we will only use a small number of walkers:</p><pre><code class="language-julia hljs">steps_equilibrate = 1_000
steps_measure = 5_000
targetwalkers = 100;</code></pre><p>Other FCIQMC parameters and strategies are the same as before</p><pre><code class="language-julia hljs">dτ = 0.001
reporting_interval = 1
svec = DVec(aIni =&gt; 1)
Random.seed!(17)
params = RunTillLastStep(dτ = dτ, laststep = steps_equilibrate + steps_measure)
s_strat = DoubleLogUpdate(targetwalkers = targetwalkers, ζ = 0.08)
r_strat = ReportDFAndInfo(reporting_interval = reporting_interval, info_interval = 100)
τ_strat = ConstantTimeStep();</code></pre><p>Now we run the main FCIQMC loop:</p><pre><code class="language-julia hljs">df, state = lomc!(H, svec;
            params,
            laststep = steps_equilibrate + steps_measure,
            s_strat,
            r_strat,
            τ_strat,
            replica,
);</code></pre><p>The output <code>DataFrame</code> has FCIQMC statistics for each replica (e.g. shift)</p><pre><code class="language-julia hljs">println(filter(startswith(&quot;shift_&quot;), names(df)))</code></pre><pre><code class="nohighlight hljs">[&quot;shift_1&quot;, &quot;shift_noise_1&quot;, &quot;shift_2&quot;, &quot;shift_noise_2&quot;, &quot;shift_3&quot;, &quot;shift_noise_3&quot;]
</code></pre><p>as well as vector-vector overlaps (e.g. <code>c1_dot_c2</code>)</p><pre><code class="language-julia hljs">println(filter(contains(&quot;dot&quot;), names(df)))</code></pre><pre><code class="nohighlight hljs">[&quot;c1_dot_c2&quot;, &quot;c1_dot_c3&quot;, &quot;c2_dot_c3&quot;]
</code></pre><p>and operator overlaps (e.g. <code>c1_Op1_c2</code>) between the replicas.</p><pre><code class="language-julia hljs">println(filter(contains(&quot;Op&quot;), names(df)))</code></pre><pre><code class="nohighlight hljs">[&quot;c1_Op1_c2&quot;, &quot;c1_Op2_c2&quot;, &quot;c1_Op3_c2&quot;, &quot;c1_Op4_c2&quot;, &quot;c1_Op5_c2&quot;, &quot;c1_Op6_c2&quot;, &quot;c1_Op1_c3&quot;, &quot;c1_Op2_c3&quot;, &quot;c1_Op3_c3&quot;, &quot;c1_Op4_c3&quot;, &quot;c1_Op5_c3&quot;, &quot;c1_Op6_c3&quot;, &quot;c2_Op1_c3&quot;, &quot;c2_Op2_c3&quot;, &quot;c2_Op3_c3&quot;, &quot;c2_Op4_c3&quot;, &quot;c2_Op5_c3&quot;, &quot;c2_Op6_c3&quot;]
</code></pre><p>The vector-vector and operator overlaps go into calculating the Rayleigh quotient for an observable</p><p class="math-container">\[    \langle \hat{G}^{(2)}(d) \rangle = \frac{\sum_{a&lt;b} \mathbf{c}_a^\dagger \cdot \hat{G}^{(2)}(d) \cdot \mathbf{c}_b}{\sum_{a&lt;b} \mathbf{c}_a^\dagger \cdot \mathbf{c}_b }\]</p><p>The sum over all replica pairs (a,b), especially in the denominator, helps to avoid errors from poor sampling if the number of walkers is too low.</p><p>We use the function <a href="../statstools.html#Rimu.StatsTools.rayleigh_replica_estimator-Tuple{Vector, Vector, Vector, Any, Any}"><code>rayleigh_replica_estimator</code></a> to calculate the Rayleigh quotient using all replicas in <code>df</code>, returning a <code>RatioBlockingResult</code> using <code>MonteCarloMeasurements</code>. Using the keyword <code>skip</code> will ignore the initial equilibration steps.</p><p>Now we can calculate the correlation function for each value of <code>d</code></p><pre><code class="language-julia hljs">println(&quot;Two-body correlator from $num_reps replicas:&quot;)
for d in dvals
    r = rayleigh_replica_estimator(df; op_name = &quot;Op$(d+1)&quot;, skip=steps_equilibrate)
    println(&quot;   G2($d) = $(r.f) ± $(r.σ_f)&quot;)
end</code></pre><pre><code class="nohighlight hljs">Two-body correlator from 3 replicas:
   G2(0) = 0.21613155078119725 ± 0.01085821157566204
   G2(1) = 0.9169697523770443 ± 0.0038806082210552633
   G2(2) = 0.9824296470223551 ± 0.0017958379949926653
   G2(3) = 0.9850696504200039 ± 0.0021126795728273265
   G2(4) = 0.9824296470223551 ± 0.0017958379949926653
   G2(5) = 0.9169697523770443 ± 0.0038806082210552633
</code></pre><p>As expected, the onsite correlation at <span>$d=0$</span> is low since this is a Mott insulating state with unit filling fraction, and is highest at <span>$d=3$</span> which is the longest possible separation with periodic boundary conditions.</p><p>Since we ran multiple independent replicas, we also have multiple estimates of the shift energy</p><pre><code class="language-julia hljs">println(&quot;Shift energy from $num_reps replicas:&quot;)
for i in 1:num_reps
    se = shift_estimator(df; shift=&quot;shift_$i&quot;, skip=steps_equilibrate)
    println(&quot;   Replica $i: $(se.mean) ± $(se.err)&quot;)
end</code></pre><pre><code class="nohighlight hljs">Shift energy from 3 replicas:
   Replica 1: -3.822539185245795 ± 0.22458214092101125
   Replica 2: -4.0952774782992565 ± 0.20113200040556367
   Replica 3: -4.003586035974758 ± 0.20727140414134074
</code></pre><p>Finished!</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="BHM-example-mpi.html">« Rimu with MPI</a><a class="docs-footer-nextpage" href="exact-example.html">Exact diagonalisation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 17 February 2023 05:24">Friday 17 February 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
