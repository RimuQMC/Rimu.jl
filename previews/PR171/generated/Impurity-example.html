<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Impurity Yrast States · Rimu.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Rimu.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Guide</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="BHM-example.html">1D Bose-Hubbard Model</a></li><li><a class="tocitem" href="BHM-example-mpi.html">Rimu with MPI</a></li><li><a class="tocitem" href="G2-example.html">Calculating observables</a></li><li class="is-active"><a class="tocitem" href="Impurity-example.html">Impurity Yrast States</a><ul class="internal"><li><a class="tocitem" href="#Initial-setup-and-parameters"><span>Initial setup and parameters</span></a></li><li><a class="tocitem" href="#Stage-1:-Running-with-the-&quot;dummy&quot;-Hamiltonian"><span>Stage 1: Running with the &quot;dummy&quot; Hamiltonian</span></a></li><li><a class="tocitem" href="#Stage-2:-Running-with-the-real-Hamiltonian-with-replica-but-no-observables"><span>Stage 2: Running with the real Hamiltonian with replica but no observables</span></a></li><li><a class="tocitem" href="#Stage-3:-Running-with-the-real-Hamiltonian-with-replica-and-observables"><span>Stage 3: Running with the real Hamiltonian with replica and observables</span></a></li><li><a class="tocitem" href="#Post-calculation-analysis"><span>Post-calculation analysis</span></a></li></ul></li></ul></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="../statstools.html">StatsTools</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="../dictvectors.html">Dict vectors</a></li><li><a class="tocitem" href="../addresses.html">BitString addresses</a></li><li><a class="tocitem" href="../stochasticstyles.html">Stochastic styles</a></li><li><a class="tocitem" href="../RMPI.html">RMPI</a></li><li><a class="tocitem" href="../consistentrng.html">Random Numbers</a></li><li><a class="tocitem" href="../rimuio.html">I/O</a></li><li><a class="tocitem" href="../documentation.html">Documentation generation</a></li><li><a class="tocitem" href="../testing.html">Code testing</a></li></ul></li><li><a class="tocitem" href="../API.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="Impurity-example.html">Impurity Yrast States</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Impurity-example.html">Impurity Yrast States</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/develop/scripts/Impurity-example.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-4:-Impurity-Yrast-States"><a class="docs-heading-anchor" href="#Example-4:-Impurity-Yrast-States">Example 4: Impurity Yrast States</a><a id="Example-4:-Impurity-Yrast-States-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Impurity-Yrast-States" title="Permalink"></a></h1><p>This is an example calculation of the lowest energy eigenstates at given total momentum (yrast states) of a mobile impurity coupled with a one-dimensional Bose gas. We will be using MPI parallelisation as such calculations are typically expensive. This script is designed to be run effectively on a high performance computing (HPC) unit.</p><p>The aim of this example is to showcase how a two-component Hamiltonian in momentum-space can be set up, as well as how a multi-stage FCIQMC can be run. Furthermore, this momentum-space setup will incur the sign problem, hence the initiator approach for FCIQMC will be used.</p><p>A detailed description of the physical system and the physics behind the model can be found at our published paper (open access) &quot;Polaron-Depleton Transition in the Yrast Excitations of a One-Dimensional Bose Gas with a Mobile Impurity&quot;, M. Yang, M. Čufar, E. Pahl, J. Brand, <a href="https://www.mdpi.com/2410-3896/7/1/15"><em>Condens. Matter</em> <strong>7</strong>, 15 (2022)</a>.</p><p>A runnable script for this example is located <a href="https://github.com/joachimbrand/Rimu.jl/blob/develop/scripts/Impurity-example.jl">here</a>. Run it with <code>mpirun -np [# of CPUs] julia Impurity-example.jl</code>.</p><h2 id="Initial-setup-and-parameters"><a class="docs-heading-anchor" href="#Initial-setup-and-parameters">Initial setup and parameters</a><a id="Initial-setup-and-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-setup-and-parameters" title="Permalink"></a></h2><p>Firstly, we load all needed modules <code>Rimu</code> and <code>Rimu.RMPI</code> for parallel FCIQMC calculation.</p><pre><code class="language-julia hljs">using Rimu
using Rimu.RMPI</code></pre><p>Let&#39;s define a function for constructing the starting vector based on the total momentum of the coupled system <code>P</code>, the number of modes <code>m</code> and the number of non-impurity bosons <code>n</code>. The maximum allowed total momentum equals to the total number of particles including the impurity, hence <code>n+1</code>. Apart from the zero and the maximum total momentum states, we will have more than one configurations in the starting vector to reflect various possible excitation options based on intuitions in physics.</p><pre><code class="language-julia hljs">function init_dv(P,m,n)
    aIni = BoseFS2C(BoseFS([n; zeros(Int, m-1)]), BoseFS([1; zeros(Int, m-1)]))
    dv = InitiatorDVec(aIni=&gt;1.0;style=IsDynamicSemistochastic())
    empty!(dv)
    c = (m+1)÷2 # finding the zero-momentum mode
    if P == 0 # zero total momentum
        bfs1 = zeros(Int, m);bfs2 = zeros(Int, m)
        bfs1[c] = n; bfs2[c] = 1
        dv[BoseFS2C(BoseFS(bfs1),BoseFS(bfs2))]+=1.0
    elseif P == (n+1) # maximum total momentum
        bfs1 = zeros(Int, m);bfs2 = zeros(Int, m)
        bfs1[c+1] = n; bfs2[c+1] = 1
        dv[BoseFS2C(BoseFS(bfs1),BoseFS(bfs2))]+=1.0
    else
        bfs1 = zeros(Int, m);bfs2 = zeros(Int, m)
        bfs1[c] = n-(P-1); bfs1[c+1] = P-1; bfs2[c+1] = 1 # move impurity to c+1
        dv[BoseFS2C(BoseFS(bfs1),BoseFS(bfs2))]+=1.0

        bfs1 = zeros(Int, m);bfs2 = zeros(Int, m)
        bfs1[c] = n-P; bfs1[c+1] = P; bfs2[c] = 1 # move bosons to c+1
        dv[BoseFS2C(BoseFS(bfs1),BoseFS(bfs2))]+=1.0

        bfs1 = zeros(Int, m);bfs2 = zeros(Int, m)
        bfs1[c] = n; bfs2[c+P] = 1 # move impurity to c+P
        dv[BoseFS2C(BoseFS(bfs1),BoseFS(bfs2))]+=1.0

        if (n-1) &gt;= P &gt;(n÷2)
            bfs1 = zeros(Int, m);bfs2 = zeros(Int, m)
            bfs1[c] = n-(P+1); bfs1[c+1] = P+1; bfs2[c-1] = 1 # move impurity to c-1 and a boson to c+1
            dv[BoseFS2C(BoseFS(bfs1),BoseFS(bfs2))]+=1.0
        end
    end
    return dv
end</code></pre><pre><code class="nohighlight hljs">init_dv (generic function with 1 method)</code></pre><p>Note that the <code>dv</code> will be constructed with <code>InitiatorDVec()</code>, meaning that the initiator-FCIQMC algorithm will be used.</p><p>Now let&#39;s first do some MPI sanity checks and print some information:</p><pre><code class="language-julia hljs">mpi_barrier() # optional, use for debugging and sanity checks
@info &quot;After barrier 1&quot; mpi_rank() mpi_size() Threads.nthreads()</code></pre><pre><code class="nohighlight hljs">┌ Info: After barrier 1
│   mpi_rank() = 0
│   mpi_size() = 1
└   Threads.nthreads() = 1
</code></pre><p>Now we specify parameters for constructing a two-component Hamiltonian</p><pre><code class="language-julia hljs">P = 3 # total momentum
m = 8 # number of modes
na= 4 # number of non-impurity bosons
γ = 0.2 # boson-boson coupling strength, dimensionless quantity
η = 0.5 # impurity-boson coupling strength, dimensionless quantity
T = m^2/2 # normalised hopping strength
U = m*γ*na/(γ*na/(m*π^2) + 1) # converting γ to U
V = m*η*na/(η*na/(m*π^2) + 1) # converting η to V</code></pre><pre><code class="nohighlight hljs">15.60472763149028</code></pre><p>Here we use an initial address <code>aIni</code> for constructing the Hamiltonian, but it will not be used in the starting vector.</p><pre><code class="language-julia hljs">aIni = BoseFS2C(BoseFS([na; zeros(Int, m-1)]), BoseFS([1; zeros(Int, m-1)]))
ham = BoseHubbardMom1D2C(aIni;ta=T,tb=T,ua=U,v=V,dispersion=continuum_dispersion)</code></pre><pre><code class="nohighlight hljs">BoseHubbardMom1D2C(BoseFS2C(BoseFS{4,8}((4, 0, 0, 0, 0, 0, 0, 0)), BoseFS{1,8}((1, 0, 0, 0, 0, 0, 0, 0))); ua=6.33580487507307, ub=1.0, ta=32.0, tb=32.0, v=15.60472763149028)</code></pre><p>Now we can setup the Monte Carlo parameters</p><pre><code class="language-julia hljs">steps_warmup = 10_000 # number of QMC steps running with a dummy Hamiltonian, see Stage 1
steps_equilibrate = 10_000 # number of QMC steps running with the real `ham`
steps_final = 10_000 # number of QMC steps running with G2 correlators, very slow, be caution!
tw = 1_000 # number of walkers, be sure to use a larger enough number to eliminate biases</code></pre><pre><code class="nohighlight hljs">1000</code></pre><p>Specifying the shift strategy:</p><pre><code class="language-julia hljs">s_strat = DoubleLogUpdateAfterTargetWalkers(targetwalkers = tw)</code></pre><pre><code class="nohighlight hljs">DoubleLogUpdateAfterTargetWalkers
  targetwalkers: Int64 1000
  ζ: Float64 0.08
  ξ: Float64 0.0016
</code></pre><p>Wrapping <code>dv</code> for MPI:</p><pre><code class="language-julia hljs">dv = MPIData(init_dv(P,m,na));</code></pre><p>Let&#39;s have a look of the starting vector, in this particular case, all 4 different ways of distributing total momenta <code>P</code> with <code>init_dv()</code> are triggered:</p><pre><code class="language-julia hljs">@mpi_root @show dv</code></pre><pre><code class="nohighlight hljs">MPIData(InitiatorDVec) with 4 entries, style = IsDynamicSemistochastic{Float64,ThresholdCompression,DynamicSemistochastic}(), strategy = MPIPointToPoint
  BoseFS2C(BoseFS{4,8}((0, 0, 0, 1, 3, 0, 0, 0)), BoseFS{1,8}((0, 0, 0, 1, 0, 0, 0, 0))) =&gt; 1.0
  BoseFS2C(BoseFS{4,8}((0, 0, 0, 4, 0, 0, 0, 0)), BoseFS{1,8}((0, 0, 0, 0, 0, 0, 1, 0))) =&gt; 1.0
  BoseFS2C(BoseFS{4,8}((0, 0, 0, 0, 4, 0, 0, 0)), BoseFS{1,8}((0, 0, 1, 0, 0, 0, 0, 0))) =&gt; 1.0
  BoseFS2C(BoseFS{4,8}((0, 0, 0, 2, 2, 0, 0, 0)), BoseFS{1,8}((0, 0, 0, 0, 1, 0, 0, 0))) =&gt; 1.0</code></pre><h2 id="Stage-1:-Running-with-the-&quot;dummy&quot;-Hamiltonian"><a class="docs-heading-anchor" href="#Stage-1:-Running-with-the-&quot;dummy&quot;-Hamiltonian">Stage 1: Running with the &quot;dummy&quot; Hamiltonian</a><a id="Stage-1:-Running-with-the-&quot;dummy&quot;-Hamiltonian-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-1:-Running-with-the-&quot;dummy&quot;-Hamiltonian" title="Permalink"></a></h2><p>Here we are constructing a secondary Hamiltonian <code>ham2</code> with equal boson-boson and impurity coupling strength. We use this Hamiltonian to further generate a batter staring vector. From previous experiences calculating impurity problems, this setup can significantly speed up the convergence and help FCIQMC to sample the important part of the Hilbert space, especially useful when <code>η</code> is very small.</p><pre><code class="language-julia hljs">η2 = γ
V2 = m*η2*na/(η2*na/(m*π^2) + 1)
ham2 = BoseHubbardMom1D2C(aIni;ta=T,tb=T,ua=U,v=V2,dispersion=continuum_dispersion)</code></pre><pre><code class="nohighlight hljs">BoseHubbardMom1D2C(BoseFS2C(BoseFS{4,8}((4, 0, 0, 0, 0, 0, 0, 0)), BoseFS{1,8}((1, 0, 0, 0, 0, 0, 0, 0))); ua=6.33580487507307, ub=1.0, ta=32.0, tb=32.0, v=6.33580487507307)</code></pre><p>We use very small time-step size and high starting value of shift</p><pre><code class="language-julia hljs">params = RunTillLastStep(step = 0, dτ = 0.00001, laststep = steps_warmup,shift = 200.0)</code></pre><pre><code class="nohighlight hljs">RunTillLastStep{Float64}
  step: Int64 0
  laststep: Int64 10000
  shiftMode: Bool false
  shift: Float64 200.0
  dτ: Float64 1.0e-5
</code></pre><p>As we only use the secondary Hamiltonian <code>ham2</code> to generate a staring vector, we don&#39;t have to save any data in this stage. Progress messages are suppressed with <code>io=devnull</code>.</p><pre><code class="language-julia hljs">r_strat = ReportDFAndInfo(reporting_interval = 1_000, info_interval = 1_000, writeinfo = is_mpi_root(), io = devnull)</code></pre><pre><code class="nohighlight hljs">ReportDFAndInfo
  reporting_interval: Int64 1000
  info_interval: Int64 1000
  io: Base.DevNull Base.DevNull()
  writeinfo: Bool true
</code></pre><p>Now we run FCIQMC with <code>lomc!()</code> and track the elapsed time. Both <code>df</code> and <code>state</code> will be overwritten later with the &quot;real&quot; data.</p><pre><code class="language-julia hljs">el = @elapsed df, state = lomc!(ham2, dv; params, s_strat, r_strat,)
@mpi_root @info &quot;Initial fciqmc completed in $(el) seconds.&quot;</code></pre><pre><code class="nohighlight hljs">[ Info: Initial fciqmc completed in 2.359277312 seconds.
</code></pre><h2 id="Stage-2:-Running-with-the-real-Hamiltonian-with-replica-but-no-observables"><a class="docs-heading-anchor" href="#Stage-2:-Running-with-the-real-Hamiltonian-with-replica-but-no-observables">Stage 2: Running with the real Hamiltonian with replica but no observables</a><a id="Stage-2:-Running-with-the-real-Hamiltonian-with-replica-but-no-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-2:-Running-with-the-real-Hamiltonian-with-replica-but-no-observables" title="Permalink"></a></h2><p>We are ready to run the real Hamiltonian, here we redefine some variables for saving outputs. We save the Monte Carlo data every 1000 steps. Progress messages are suppressed with <code>io=devnull</code>, for a real job one should remove the line to invoke the default <code>io</code> and reenable the output messages.</p><pre><code class="language-julia hljs">r_strat = ReportToFile(
    save_if = is_mpi_root(),
    filename = &quot;mpi_df_$(η)_$(P).arrow&quot;,
    chunk_size = 1000,
    return_df = true, # change it to `false` when running the real job
    io=devnull # remove this line when running the real job
    )</code></pre><pre><code class="nohighlight hljs">ReportToFile
  filename: String &quot;mpi_df_0.5_3.arrow&quot;
  reporting_interval: Int64 1
  chunk_size: Int64 1000
  save_if: Bool true
  return_df: Bool true
  io: Base.DevNull Base.DevNull()
</code></pre><p>We will turn on the replica, but without operators for a fast equilibration.</p><pre><code class="language-julia hljs">el2 = @elapsed df, state = lomc!(ham,dv; params, s_strat, r_strat, replica = AllOverlaps(2, nothing), laststep = (steps_equilibrate+steps_warmup))
@mpi_root @info &quot;Replica fciqmc completed in $(el2) seconds.&quot;</code></pre><pre><code class="nohighlight hljs">[ Info: Replica fciqmc completed in 4.804052751 seconds.
</code></pre><h2 id="Stage-3:-Running-with-the-real-Hamiltonian-with-replica-and-observables"><a class="docs-heading-anchor" href="#Stage-3:-Running-with-the-real-Hamiltonian-with-replica-and-observables">Stage 3: Running with the real Hamiltonian with replica and observables</a><a id="Stage-3:-Running-with-the-real-Hamiltonian-with-replica-and-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Stage-3:-Running-with-the-real-Hamiltonian-with-replica-and-observables" title="Permalink"></a></h2><p>We now at the last stage of the calculation, doing replica FCIQMC with a serious of G2 correlators with distance <code>d</code> from <code>0</code> to <code>m</code>. See <a href="generated/@ref"><code>G2Correlator</code></a>. Here we save data every 1000 steps, but using a smaller <code>chunk_size</code> like 10 or even 1 is highly recommended as replica FCIQMC with many observables being calculated are very expensive and you don&#39;t want to loose too much data if the job stops before finishes. Progress messages are suppressed with <code>io=devnull</code>, for a real job one should remove the line to invoke the default <code>io</code> and reenable the output messages.</p><pre><code class="language-julia hljs">r_strat = ReportToFile(
    save_if = is_mpi_root(),
    filename = &quot;mpi_df_g2_$(η)_$(P).arrow&quot;,
    chunk_size = 1000,
    return_df = true, # change it to `false` when running the real job
    io = devnull # remove this line when running the real job
    )</code></pre><pre><code class="nohighlight hljs">ReportToFile
  filename: String &quot;mpi_df_g2_0.5_3.arrow&quot;
  reporting_interval: Int64 1
  chunk_size: Int64 1000
  save_if: Bool true
  return_df: Bool true
  io: Base.DevNull Base.DevNull()
</code></pre><p>Setting up a tuple of G2 correlators:</p><pre><code class="language-julia hljs">g = Tuple(G2Correlator.(0:m))</code></pre><pre><code class="nohighlight hljs">(G2MomCorrelator(0,:cross), G2MomCorrelator(1,:cross), G2MomCorrelator(2,:cross), G2MomCorrelator(3,:cross), G2MomCorrelator(4,:cross), G2MomCorrelator(5,:cross), G2MomCorrelator(6,:cross), G2MomCorrelator(7,:cross), G2MomCorrelator(8,:cross))</code></pre><p>By default, for a two-component system the cross-component G2 operators are set up. If you want to calculate the correlations within a single component, <code>G2Correlator(d,:first)</code> or <code>G2Correlator(d,:second)</code> can be called based on your choice.</p><p>Carry over information from the previous stage and set up a new <code>QMCState</code>:</p><pre><code class="language-julia hljs">new_state = Rimu.QMCState(
    state.hamiltonian, state.replicas, Ref(Int(state.maxlength)),
    state.m_strat, r_strat, state.s_strat, state.τ_strat, state.threading, state.post_step, AllOverlaps(2, g)
    )</code></pre><pre><code class="nohighlight hljs">QMCState with 2 replicas
  H:    BoseHubbardMom1D2C(BoseFS2C(BoseFS{4,8}((4, 0, 0, 0, 0, 0, 0, 0)), BoseFS{1,8}((1, 0, 0, 0, 0, 0, 0, 0))); ua=6.33580487507307, ub=1.0, ta=32.0, tb=32.0, v=15.60472763149028)
  step: 20000 / 20000
  replicas: 
    1: ReplicaState(v: 81-element MPIData, w: 137-element InitiatorDVec)
    2: ReplicaState(v: 68-element MPIData, w: 135-element InitiatorDVec)</code></pre><p>The final stage</p><pre><code class="language-julia hljs">el3 = @elapsed df2, state2 = lomc!(new_state; laststep = (steps_equilibrate+steps_warmup+steps_final))
@mpi_root @info &quot;Replica fciqmc with G2 completed in $(el3) seconds.&quot;
println(&quot;MPI run finished!&quot;)</code></pre><pre><code class="nohighlight hljs">[ Info: Replica fciqmc with G2 completed in 34.716548331 seconds.
MPI run finished!
</code></pre><h2 id="Post-calculation-analysis"><a class="docs-heading-anchor" href="#Post-calculation-analysis">Post-calculation analysis</a><a id="Post-calculation-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Post-calculation-analysis" title="Permalink"></a></h2><p>Typically, one should not include any analyses when using MPI, as they will be calculated multiple time unless you put the <code>@mpi_root</code> macro everywhere. Even so, all other MPI ranks apart from the root will be idling and wasting CPU hours on a HPC unit. But here, let&#39;s have a look of the calculated G2 correlations:</p><pre><code class="language-julia hljs">@mpi_root println(&quot;Two-body correlator from 2 replicas:&quot;)
@mpi_root for d in 0:m
    r = rayleigh_replica_estimator(df2; op_name = &quot;Op$(d+1)&quot;, skip = 5_000)
    println(&quot;   G2($d) = $(r.f) ± $(r.σ_f)&quot;)
end</code></pre><pre><code class="nohighlight hljs">Two-body correlator from 2 replicas:
   G2(0) = 0.6212950620687653 + 0.0im ± 0.0010420784480727411 + 0.0im
   G2(1) = 0.6394061668273612 + 0.0001034761450805627im ± 0.0008452345141311301 - 6.532751467959406e-6im
   G2(2) = 0.5289765668862786 + 0.00018520776568315154im ± 0.00013453097827293236 - 0.00013076215956360992im
   G2(3) = 0.3706557171006199 + 0.00020231762206882026im ± 0.0007894510343786228 - 1.4406266414898128e-5im
   G2(4) = 0.3006280363027145 + 4.5495512452306034e-20im ± 0.0011774850519135805 - 2.1051422271162484e-21im
   G2(5) = 0.37065571710061984 - 0.0002023176220688198im ± 0.0007894510343786231 + 1.4406266414898022e-5im
   G2(6) = 0.5289765668862786 - 0.00018520776568315504im ± 0.00013453097827293068 + 0.00013076215956361143im
   G2(7) = 0.6394061668273611 - 0.00010347614508056342im ± 0.0008452345141311276 + 6.532751467959437e-6im
   G2(8) = 0.6212950620687653 - 2.3522836362458078e-20im ± 0.0010420784480727411 + 2.08602972572349e-21im
</code></pre><p>A symmetry between <code>G2(d)</code> and <code>G2(m-d)</code> can be observed above, which is the expected outcome due the periodic boundary conditions.</p><p>Finished !</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="G2-example.html">« Calculating observables</a><a class="docs-footer-nextpage" href="../statstools.html">StatsTools »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 21 September 2022 03:13">Wednesday 21 September 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
