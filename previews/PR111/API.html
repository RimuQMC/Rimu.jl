<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Rimu.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Rimu.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="generated/BHM-example.html">1D Bose-Hubbard Model</a></li><li><a class="tocitem" href="generated/BHM-example-mpi.html">Using MPI</a></li></ul></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="statstools.html">StatsTools</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="addresses.html">BitString addresses</a></li><li><a class="tocitem" href="consistentrng.html">Random Numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li class="is-active"><a class="tocitem" href="API.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rimu"><span>Rimu</span></a></li><li class="toplevel"><a class="tocitem" href="#Reexported-Submodules"><span>Reexported Submodules</span></a></li><li><a class="tocitem" href="#Hamiltonians"><span>Hamiltonians</span></a></li><li><a class="tocitem" href="#BitStringAddresses"><span>BitStringAddresses</span></a></li><li><a class="tocitem" href="#DictVectors"><span>DictVectors</span></a></li><li><a class="tocitem" href="#ConsistentRNG"><span>ConsistentRNG</span></a></li><li class="toplevel"><a class="tocitem" href="#Unexported-Submodules"><span>Unexported Submodules</span></a></li><li><a class="tocitem" href="#StatsTools"><span>StatsTools</span></a></li><li><a class="tocitem" href="#Blocking"><span>Blocking</span></a></li><li><a class="tocitem" href="#RMPI"><span>RMPI</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="API.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Rimu"><a class="docs-heading-anchor" href="#Rimu">Rimu</a><a id="Rimu-1"></a><a class="docs-heading-anchor-permalink" href="#Rimu" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.Rimu" href="#Rimu.Rimu"><code>Rimu.Rimu</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Rimu</code></pre><p>Random Integrator for Many-Body Quantum Systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Rimu.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.AllOverlaps" href="#Rimu.AllOverlaps"><code>Rimu.AllOverlaps</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AllOverlaps(n=2, operator=nothing) &lt;: ReplicaStrategy{n}</code></pre><p>Run <code>n</code> replicas and report overlaps between all pairs of replica vectors. If operator is not <code>nothing</code>, the overlap <code>dot(c1, operator, c2)</code> is reported as well. If operator is a tuple of operators, the overlaps are computed for all operators.</p><p>Column names in the report are of the form c{i}<em>dot</em>c{j} for vector-vector overlaps, and c{i}<em>Op{k}</em>c{j} for operator overlaps.</p><p>See <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> (for an interface for implementing operators).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/replicastrategy.jl#L39-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ConstantTimeStep" href="#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantTimeStep &lt;: TimeStepStrategy</code></pre><p>Keep <code>dτ</code> constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/timestepstrategy.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory" href="#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeltaMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="nohighlight hljs">r̃ = (pnorm - tnorm)/(dτ*pnorm) + shift
r = r̃ - &lt;r̃&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory2" href="#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeltaMemory2(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="nohighlight hljs">r̃ = pnorm - tnorm + shift*dτ*pnorm
r = (r̃ - &lt;r̃&gt;)/(dτ*pnorm)</code></pre><p>The long-term average of <code>r</code> is not guaranteed to be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory3" href="#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeltaMemory3(Δ::Int, level::Float64) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, apply multiplicative memory noise with a memory length of <code>Δ</code> at level <code>level</code>, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="nohighlight hljs">r̃ = (pnorm - tnorm)/pnorm + dτ*shift
r = r̃ - &lt;r̃&gt;
w .*= 1 + level*r</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L59-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DontUpdate" href="#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DontUpdate(; targetwalkers = 1_000_000) &lt;: ShiftStrategy</code></pre><p>Don&#39;t update the <code>shift</code>.  Return when <code>targetwalkers</code> is reached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L19-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogProjected" href="#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogProjected(; target, projector, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> after projecting onto <code>projector</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{P⋅Ψ^{(n)}}\right)-\frac{ξ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{\text{target}}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L203-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogSumUpdate" href="#Rimu.DoubleLogSumUpdate"><code>Rimu.DoubleLogSumUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogSumUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, α = 1/2) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameters <code>ζ</code> and <code>ξ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^n}\right)
- \frac{ξ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^\text{target}}\right),\]</p><p>where <span>$N_\mathrm{w} =$</span> <code>(1-α)*walkernumber() + α*UniformProjector()⋅ψ</code> computed with <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber()</code></a> and <a href="API.html#Rimu.DictVectors.UniformProjector"><code>UniformProjector()</code></a>. When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdate" href="#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)-\frac{ξ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^\text{target}}\right)\]</p><p>When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkers" href="#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, ξ = 0.0016) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FciqmcRunStrategy" href="#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> FciqmcRunStrategy{T}</code></pre><p>Abstract type representing the strategy for running and terminating <a href="@ref"><code>fciqmc!()</code></a>. The type parameter <code>T</code> is relevant for reporting the shift and the norm.</p><p>Implemented strategies:</p><ul><li><a href="API.html#Rimu.RunTillLastStep"><code>RunTillLastStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/fciqmcrunstrategy.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdate" href="#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogUpdate(ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdateAfterTargetWalkers" href="#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code>. See <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MemoryStrategy" href="#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:</p><ul><li><a href="API.html#Rimu.NoMemory"><code>NoMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>DeltaMemory</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>ShiftMemory</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MultiScalar" href="#Rimu.MultiScalar"><code>Rimu.MultiScalar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiScalar</code></pre><p>Wrapper over a tuple that supports <code>+</code>, <code>-</code>, <code>min</code>, and <code>max</code>. Used with MPI communication because <code>SVector</code>s are treated as arrays by <code>MPI.Allreduce</code> and <code>Tuples</code> do not support scalar operations.</p><p><strong>Example</strong></p><p>Suppose you want to compute the sum of a vector <code>dv</code> and also get the number of positive elements it has in a single pass. You can use <code>MultiScalar</code>:</p><pre><code class="language-julia hljs">julia&gt; dv = DVec(:a =&gt; 1, :b =&gt; -2, :c =&gt; 1);

julia&gt; s, p = mapreduce(+, values(dv)) do v
    Rimu.MultiScalar(v, Int(sign(v) == 1))
end;

julia&gt; s, p
(0, 2)</code></pre><p>This will work with <code>MPIData</code>.</p><p>Note that only <code>MultiScalar</code>s with the same types can be operated on. This is a feature, as it forces type stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/helpers.jl#L38-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoMemory" href="#Rimu.NoMemory"><code>Rimu.NoMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoMemory &lt;: MemoryStrategy</code></pre><p>Default strategy for <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a> indicating that no memory noise will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoStats" href="#Rimu.NoStats"><code>Rimu.NoStats</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoStats(N=1) &lt;: ReplicaStrategy{N}</code></pre><p>The default <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a>. <code>N</code> replicas are run, but no statistics are collected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/replicastrategy.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.PostStepStrategy" href="#Rimu.PostStepStrategy"><code>Rimu.PostStepStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PostStepStrategy</code></pre><p>Subtypes of <code>PostStepStrategy</code> can be used to perform arbitrary computation on a replica after an FCIQMC step is finished and report the results.</p><p><strong>Implemented strategies:</strong></p><ul><li><a href="API.html#Rimu.ProjectedEnergy"><code>ProjectedEnergy</code></a></li><li><a href="API.html#Rimu.Projector"><code>Projector</code></a></li><li><a href="API.html#Rimu.SignCoherence"><code>SignCoherence</code></a></li><li><a href="API.html#Rimu.WalkerLoneliness"><code>WalkerLoneliness</code></a></li></ul><p>Note: A tuple of multiple strategies can be passed to <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a>. In that case, all reported column names must be distinct.</p><p><strong>Interface:</strong></p><p>A subtype of this type must implement <a href="API.html#Rimu.post_step"><code>post_step(::PostStepStrategy, ::ReplicaState)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/poststepstrategy.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectedEnergy" href="#Rimu.ProjectedEnergy"><code>Rimu.ProjectedEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedEnergy(hamiltonian, projector; hproj=:vproj, vproj=:vproj) &lt;: PostStepStrategy</code></pre><p>After every step, compute <code>hproj = dot(projector, hamiltonian, dv)</code> and <code>vproj = dot(projector, dv)</code>, where <code>dv</code> is the instantaneous coefficient vector.  <code>projector</code> can be an <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>, or an <a href="API.html#Rimu.DictVectors.AbstractProjector"><code>AbstractProjector</code></a>.</p><p>Reports to columns <code>hproj</code> and <code>vproj</code>, which can be used to compute projective energy, e.g. with <a href="statstools.html#Rimu.StatsTools.projected_energy-Tuple{DataFrames.DataFrame}"><code>Rimu.StatsTools.projected_energy</code></a>. The keyword arguments <code>hproj</code> and <code>vproj</code> can be used to change the names of these columns. This can be used to make the names unique when computing projected energies with different projectors in the same run.</p><p>See also <a href="statstools.html#Rimu.StatsTools.ratio_of_means-Tuple{Any, Any}"><code>Rimu.StatsTools.ratio_of_means</code></a>, <a href="statstools.html#Rimu.StatsTools.mixed_estimator-NTuple{5, Any}"><code>Rimu.StatsTools.mixed_estimator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/poststepstrategy.jl#L60-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectedMemory" href="#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedMemory(Δ::Int, projector, pp::Number) &lt;: MemoryStrategy
ProjectedMemory(Δ::Int, projector, v::AbstractDVec)</code></pre><p>Before updating the shift, apply memory noise to minimize the fluctuations of the overlap of the coefficient vector with <code>projector</code>. Averaging over <code>Δ</code> time steps is applied, where <code>Δ = 1</code> means no memory noise is applied. Use <code>pp</code> to initialise the value of the projection or pass <code>v</code> in order to initialise the projection with <code>pp = projector.v</code>.</p><pre><code class="nohighlight hljs">r̃ = (projector⋅v - projector⋅w)/projector⋅v + dτ*shift
r = r̃ - &lt;r̃&gt;</code></pre><p>where <code>v</code> is the coefficient vector before and <code>w</code> after applying a regular FCIQMC step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L91-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Projector" href="#Rimu.Projector"><code>Rimu.Projector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Projector(name=projector) &lt;: PostStepStrategy</code></pre><p>After each step, compute <code>dot(projector, dv)</code> and report it in the <code>DataFrame</code> under <code>name</code>. <code>projector</code> can be an <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>, or an <a href="API.html#Rimu.DictVectors.AbstractProjector"><code>AbstractProjector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/poststepstrategy.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.PurgeNegatives" href="#Rimu.PurgeNegatives"><code>Rimu.PurgeNegatives</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PurgeNegatives &lt;: MemoryStrategy</code></pre><p>Purge all negative sign walkers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.QMCState" href="#Rimu.QMCState"><code>Rimu.QMCState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QMCState</code></pre><p>Holds all information needed to run FCIQMC, except the data frame. Holds a <code>NTuple</code> of <code>ReplicaState</code>s and various strategies that control the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/lomc.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReplicaState" href="#Rimu.ReplicaState"><code>Rimu.ReplicaState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReplicaState(v, w, pnorm, params, id)</code></pre><p>Struct that holds all information needed for an independent run of the algorithm.</p><p>Can be advanced a step forward with <a href="API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T"><code>advance!</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>hamiltonian</code>: the model Hamiltonian.</li><li><code>v</code>: vector.</li><li><code>w</code>: working memory.</li><li><code>pnorm</code>: previous walker number (see <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber</code></a>).</li><li><code>params</code>: the <a href="@ref"><code>FCIQMCRunStrategy</code></a>.</li><li><code>id</code>: appended to reported columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/lomc.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReplicaStrategy" href="#Rimu.ReplicaStrategy"><code>Rimu.ReplicaStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReplicaStrategy{N}</code></pre><p>An abstract type that controles how <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> uses replicas. A subtype of <code>ReplicaStrategy{N}</code> operates on <code>N</code> replicas and must implement the following function:</p><ul><li><a href="@ref"><code>replica_stats(::ReplicaStrategy{N}, ::NTuple{N,ReplicaState})</code></a> - return a tuple of <code>String</code>s or <code>Symbols</code> of replica statistic names and a tuple of the values.  These will be reported to the <code>DataFrame</code> returned by <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a></li></ul><p>Concrete implementations:</p><ul><li><a href="API.html#Rimu.NoStats"><code>NoStats</code></a>: run (possibly one) replica(s), but don&#39;t report any additional info.</li><li><a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>: report overlaps between all pairs of replica vectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/replicastrategy.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Report" href="#Rimu.Report"><code>Rimu.Report</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Report</code></pre><p>Internal structure that holds the temporary reported values. See <a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>report!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportDFAndInfo" href="#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReportDFAndInfo(; k=1, i=100, io=stdout, writeinfo=false) &lt;: ReportingStrategy</code></pre><p>The default <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a>. Report every <code>k</code>th step to a <code>DataFrame</code> and write info message to <code>io</code> every <code>i</code>th step (unless <code>writeinfo == false</code>). The flag <code>writeinfo</code> is useful for controlling info messages in MPI codes, e.g. by setting <code>writeinfo =</code><a href="@ref"><code>is_mpi_root()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L155-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportToFile" href="#Rimu.ReportToFile"><code>Rimu.ReportToFile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReportToFile(; kwargs...) &lt;: ReportingStrategy</code></pre><p>Reporting strategy that writes the report directly to a file. Useful when dealing with long jobs or large numbers of replicas, when the report can incur a significant memory cost.</p><p><strong>Keyword arguments</strong></p><ul><li><code>filename</code>: the file to report to. If the file already exists, a new file is created.</li><li><code>chunk_size = 1000</code>: the size of each chunk that is written to the file. A <code>DataFrame</code> of this size is collected in memory and written to disk. When saving, an info message is also printed to <code>io</code>.</li><li><code>save_if =</code><a href="@ref"><code>is_mpi_root()</code></a>: if this value is true, save the report, otherwise ignore it.</li><li><code>return_df = false</code>: if this value is true, read the file and return the data frame at the end of computation. Otherwise, an empty <code>DataFrame</code> is returned.</li><li><code>io = stdout</code>: The <code>IO</code> to print messages to. Set to <code>devnull</code> if you don&#39;t want to see messages printed out.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L179-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportingStrategy" href="#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReportingStrategy</code></pre><p>Abstract type for strategies for reporting data in a DataFrame with <a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>report!()</code></a>.</p><p><strong>Implemented strategies:</strong></p><ul><li><a href="API.html#Rimu.ReportDFAndInfo"><code>ReportDFAndInfo</code></a></li><li><a href="API.html#Rimu.ReportToFile"><code>ReportToFile</code></a></li></ul><p><strong>Interface:</strong></p><p>A <code>ReportingStrategy</code> can define any of the following:</p><ul><li><a href="API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy}"><code>refine_r_strat</code></a></li><li><a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>report!</code></a></li><li><a href="API.html#Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>report_after_step</code></a></li><li><a href="API.html#Rimu.finalize_report!-Tuple{ReportingStrategy, Any}"><code>finalize_report!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L79-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RunTillLastStep" href="#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RunTillLastStep(step::Int = 0 # number of current/starting timestep
             laststep::Int = 100 # number of final timestep
             shiftMode::Bool = false # whether to adjust shift
             shift = 0.0 # starting/current value of shift
             dτ::Float64 = 0.01 # current value of time step
) &lt;: FciqmcRunStrategy</code></pre><p>Parameters for running <a href="@ref"><code>fciqmc!()</code></a> for a fixed number of time steps. For alternative strategies, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/fciqmcrunstrategy.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftMemory" href="#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Effectively replaces the fluctuating <code>shift</code> update procedure for the coefficient vector by an averaged <code>shift</code> over <code>Δ</code> timesteps, where <code>Δ = 1</code> means no averaging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/memorystrategy.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftStrategy" href="#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for updating the <code>shift</code> with <a href="API.html#Rimu.update_shift"><code>update_shift()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.DontUpdate"><code>DontUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a> - default in <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!()</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>LogUpdateAfterTargetWalkers</code></a> - FCIQMC standard</li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>DoubleLogUpdateAfterTargetWalkers</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.SignCoherence" href="#Rimu.SignCoherence"><code>Rimu.SignCoherence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SignCoherence(reference[; name=:coherence]) &lt;: PostStepStrategy</code></pre><p>After each step, compute the proportion of configurations that have the same sign as they do in the <code>reference_dvec</code>. Reports to a column named <code>name</code>, which defaults to <code>coherence</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/poststepstrategy.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TimeStepStrategy" href="#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeStepStrategy</code></pre><p>Abstract type for strategies for updating the time step with <a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>update_dτ()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.ConstantTimeStep"><code>ConstantTimeStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/timestepstrategy.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TripleLogUpdate" href="#Rimu.TripleLogUpdate"><code>Rimu.TripleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TripleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, η = 0.01) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the extended log formula with damping parameters <code>ζ</code>, <code>ξ</code>, and <code>η</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^n}\right)
- \frac{ξ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^\text{target}}\right)
- \frac{η}{dτ}\ln\left(\frac{\|ℜ(Ψ^{n+1})\|_1^2 + \|ℑ(Ψ^{n+1})\|_1^2}
{\|ℜ(Ψ^{n})\|_1^2 + \|ℑ(Ψ^{n})\|_1^2}\right),\]</p><p>where <span>$N_\mathrm{w}$</span> is the <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber()</code></a>. When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L165-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.WalkerLoneliness" href="#Rimu.WalkerLoneliness"><code>Rimu.WalkerLoneliness</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WalkerLoneliness(threshold=1) &lt;: PostStepStrategy</code></pre><p>After each step, compute the proportion of configurations that are occupied by at most <code>threshold</code> walkers. Reports to a column named <code>loneliness</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/poststepstrategy.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu._n_walkers-Tuple{Any, Any}" href="#Rimu._n_walkers-Tuple{Any, Any}"><code>Rimu._n_walkers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_n_walkers(v, s_strat)</code></pre><p>Returns an estimate of the expected number of walkers as an integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/lomc.jl#L70-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T" href="#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T"><code>Rimu.advance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">advance!(report::Report, state::QMCState, replica::ReplicaState)</code></pre><p>Advance the <code>replica</code> by one step. The <code>state</code> is used only to access the various strategies involved. Steps, stats, and computed quantities are written to the <code>report</code>.</p><p>Returns <code>true</code> if the step was successful and calculation should proceed, <code>false</code> when it should terminate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/lomc.jl#L302-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.all_overlaps-Union{Tuple{N}, Tuple{Tuple, Tuple{Vararg{AbstractDVec, N}}}} where N" href="#Rimu.all_overlaps-Union{Tuple{N}, Tuple{Tuple, Tuple{Vararg{AbstractDVec, N}}}} where N"><code>Rimu.all_overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_overlaps(operators, vectors)</code></pre><p>Get all overlaps between vectors and operators. This function is overlpaded for <code>MPIData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/replicastrategy.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}" href="#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.apply_memory_noise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r = apply_memory_noise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)</code></pre><p>Apply memory noise to <code>w</code>, i.e. <code>w .+= r.*v</code>, computing the noise <code>r</code> according to <code>m_strat</code>. Note that <code>m_strat</code> needs to be compatible with <code>StochasticStyle(w)</code>. Otherwise, an error exception is thrown. See <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a>.</p><p><code>w</code> is the walker array after fciqmc step, <code>v</code> the previous one, <code>pnorm</code> the norm of <code>v</code>, and <code>r</code> the instantaneously applied noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/apply_memory_noise.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}" href="#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.fciqmc_col!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fciqmc_col!(w, ham, add, num, shift, dτ)
fciqmc_col!(::Type{T}, args...)
-&gt; spawns, deaths, clones, antiparticles, annihilations</code></pre><p>Spawning and diagonal step of FCIQMC for single column of <code>ham</code>. In essence it computes</p><p><code>w .+= (1 .+ dτ.*(shift .- ham[:,add])).*num</code>.</p><p>Depending on <code>T ==</code><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle(w)</code></a>, a stochastic or deterministic algorithm will be chosen. The possible values for <code>T</code> are:</p><ul><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>IsDeterministic()</code></a> deteministic algorithm</li><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>IsStochasticInteger()</code></a> stochastic version where the changes added to <code>w</code> are purely integer, according to the FCIQMC algorithm</li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold(c)</code></a> stochastic algorithm with floating point walkers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/fciqmc_col.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_step!" href="#Rimu.fciqmc_step!"><code>Rimu.fciqmc_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;
                      m_strat::MemoryStrategy = NoMemory()) -&gt; ṽ, w̃, stats</code></pre><p>Perform a single matrix(/operator)-vector multiplication:</p><p class="math-container">\[\tilde{v} = [1 - dτ(\hat{H} - S)]⋅v ,\]</p><p>where <code>Ĥ == ham</code> and <code>S == shift</code>. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait <code>StochasticStyle(w)</code>. See <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>. <code>w</code> is a local data structure with the same size and type as <code>v</code> and used for working. Both <code>v</code> and <code>w</code> are modified.</p><p>Returns the result <code>ṽ</code>, a (possibly changed) reference to working memory <code>w̃</code>,  and the array <code>stats = [spawns, deaths, clones, antiparticles, annihilations]</code>. Stats will contain zeros when running in deterministic mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/fciqmc_step.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.finalize_report!-Tuple{ReportingStrategy, Any}" href="#Rimu.finalize_report!-Tuple{ReportingStrategy, Any}"><code>Rimu.finalize_report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finalize_report!(::ReportingStrategy, report)</code></pre><p>Finalize the report. This function is called after all steps in <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> have finished.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L137-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.lomc!-Tuple{Any, Any}" href="#Rimu.lomc!-Tuple{Any, Any}"><code>Rimu.lomc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lomc!(ham::AbstractHamiltonian, [v]; kwargs...) -&gt; df, state
lomc!(state::QMCState, [df]; kwargs...) -&gt; df, state</code></pre><p>Linear operator Monte Carlo: Perform a projector quantum Monte Carlo simulation for determining the lowest eigenvalue of <code>ham</code>. <code>v</code> can be a single starting vector. The default choice is</p><pre><code class="language-julia hljs">v = DVec(starting_address(ham) =&gt; 10; style=IsStochasticInteger())</code></pre><p>and triggers the integer walker FCIQMC algorithm. See <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a> and <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p><p><strong>Keyword arguments, defaults, and precedence:</strong></p><ul><li><code>params::FciqmcRunStrategy = RunTillLastStep(laststep = 100, dτ = 0.01, shift = diagonal_element(ham, starting_address(ham)))</code> - basic parameters of simulation state, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>; is mutated</li><li><code>laststep</code> - can be used to override information otherwise contained in <code>params</code></li><li><code>s_strat::ShiftStrategy = DoubleLogUpdate(targetwalkers = 100, ζ = 0.08, ξ = ζ^2/4)</code> - how to update the <code>shift</code>, see <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a></li><li><code>maxlength = 2 * s_strat.targetwalkers + 100</code> - upper limit on the length of <code>v</code>; when reached, <code>lomc!</code> will abort</li><li><code>style = IsStochasticInteger()</code> - set <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> for default <code>v</code>; unused if <code>v</code> is specified.</li><li><code>post_step::NTuple{N,&lt;:PostStepStrategy} = ()</code> - extract observables (e.g. <a href="API.html#Rimu.ProjectedEnergy"><code>ProjectedEnergy</code></a>), see <a href="API.html#Rimu.PostStepStrategy"><code>PostStepStrategy</code></a>.</li><li><code>replica::ReplicaStrategy = NoStats(1)</code> - run several synchronised simulation, see <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a>.</li><li><code>r_strat::ReportingStrategy = ReportDFAndInfo()</code> - how and when to report results, see <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a></li><li><code>τ_strat::TimeStepStrategy = ConstantTimeStep()</code> - adjust time step dynamically, see <a href="API.html#Rimu.TimeStepStrategy"><code>TimeStepStrategy</code></a></li><li><code>m_strat::MemoryStrategy = NoMemory()</code> - experimental: inject memory noise, see <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a></li><li><code>threading = :auto</code> - can be used to control the use of multithreading (overridden by <code>wm</code>)<ul><li><code>:auto</code> - use multithreading if <code>s_strat.targetwalkers ≥ 500</code></li><li><code>true</code> - use multithreading if available (set shell variable <code>JULIA_NUM_THREADS</code>!)</li><li><code>false</code> - run on single thread</li></ul></li><li><code>wm</code> - working memory; if set, it controls the use of multithreading and overrides <code>threading</code>; is mutated</li><li><code>df = DataFrame()</code> - when called with <code>AbstractHamiltonian</code> argument, a <code>DataFrame</code> can be passed into <code>lomc!</code> that will be pushed into.</li></ul><p><strong>Return values</strong></p><p><code>lomc!</code> returns a named tuple with the following fields:</p><ul><li><code>df</code>: a <code>DataFrame</code> with all statistics being reported.</li><li><code>state</code>: a <code>QMCState</code> that can be used for continuations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; add = BoseFS((1,2,3));


julia&gt; hamiltonian = HubbardReal1D(add);


julia&gt; df1, state = lomc!(hamiltonian);


julia&gt; df2, _ = lomc!(state, df1; laststep=200); # Continuation run


julia&gt; size(df1)
(100, 12)

julia&gt; size(df2)
(200, 12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/lomc.jl#L190-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.post_step" href="#Rimu.post_step"><code>Rimu.post_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">post_step(::PostStepStrategy, ::ReplicaState) -&gt; kvpairs</code></pre><p>Compute statistics after FCIQMC step. Should return a tuple of <code>:key =&gt; value</code> pairs. See also <a href="API.html#Rimu.PostStepStrategy"><code>PostStepStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/poststepstrategy.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.refine_r_strat-Tuple{ReportingStrategy}" href="#Rimu.refine_r_strat-Tuple{ReportingStrategy}"><code>Rimu.refine_r_strat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine_r_strat(r_strat::ReportingStrategy) -&gt; r_strat</code></pre><p>Initialize the reporting strategy. This can be used to set up filenames or other attributes that need to be unique for a run of FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.replica_stats" href="#Rimu.replica_stats"><code>Rimu.replica_stats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replica_stats(::ReplicaStrategy{N}, replicas::NTuple{N,ReplicaState}) -&gt; (names, values)</code></pre><p>Return the names and values of statistics reported by <code>ReplicaStrategy</code>. <code>names</code> should be a tuple of <code>Symbol</code>s or <code>String</code>s and <code>values</code> should be a tuple of the same length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/replicastrategy.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}" href="#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> report!(::ReportingStrategy, step, report::Report, keys, values, id=&quot;&quot;)
 report!(::ReportingStrategy, step, report::Report, nt, id=&quot;&quot;)</code></pre><p>Report <code>keys</code> and <code>values</code> to <code>report</code>, which will be converted to a <code>DataFrame</code> before <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> exits. Alternatively, a <code>nt::NamedTuple</code> can be passed in place of <code>keys</code> and <code>values</code>. If <code>id</code> is specified, it is appended to all <code>keys</code>. This is used to differentiate between values reported by different replicas.</p><p>To overload this function for a new <code>ReportingStrategy</code>, overload <code>report!(::ReportingStrategy, step, args...)</code> and apply the report by calling <code>report!(args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L109-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{Rimu.Report, Union{AbstractString, Symbol}, Any}" href="#Rimu.report!-Tuple{Rimu.Report, Union{AbstractString, Symbol}, Any}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">report!(report, keys, values, id=&quot;&quot;)
report!(report, pairs, id=&quot;&quot;)</code></pre><p>Write <code>keys</code>, <code>values</code> pairs to <code>report</code> that will be converted to a <code>DataFrame</code> later. Alternatively, a named tuple or a collection of pairs can be passed instead of <code>keys</code> and <code>values</code>.</p><p>The value of <code>id</code> is appended to the name of the column, e.g. <code>report!(report, :key, value, :_1)</code> will report <code>value</code> to a column named <code>:key_1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}" href="#Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>Rimu.report_after_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">report_after_step(::ReportingStrategy, step, report, state)</code></pre><p>This function is called exactly once at the very end of a step. For example, it can be used to print some information to <code>stdout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/reportingstrategy.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.sort_into_targets!-Tuple{Any, Any, Any}" href="#Rimu.sort_into_targets!-Tuple{Any, Any, Any}"><code>Rimu.sort_into_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_into_targets!(target, source, stats) -&gt; agg, wm, agg_stats</code></pre><p>Aggregate coefficients from <code>source</code> to <code>agg</code> and from <code>stats</code> to <code>agg_stats</code> according to thread- or MPI-level parallelism. <code>wm</code> passes back a reference to working memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/helpers.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.step_stats-Tuple{StochasticStyle}" href="#Rimu.step_stats-Tuple{StochasticStyle}"><code>Rimu.step_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step_stats(::StochasticStyle)</code></pre><p>Return a tuple of names (<code>Symbol</code> or <code>String</code>) and a zeros of values of the same length. These will be reported as columns in the <code>DataFrame</code> returned by <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/fciqmc_col.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s488&quot;, false} where var&quot;#s488&quot;, Any, Any, Any, Any}" href="#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s488&quot;, false} where var&quot;#s488&quot;, Any, Any, Any, Any}"><code>Rimu.threshold_projected_deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">threshold_projected_deposit!</code></pre><p>This function performs threshold projection before spawning, but only for <code>IsDynamicSemistochastic</code> with the <code>project_later</code> parameter set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/fciqmc_col.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dvec!-Tuple{StochasticStyle, Any}" href="#Rimu.update_dvec!-Tuple{StochasticStyle, Any}"><code>Rimu.update_dvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_dvec!([::StochasticStyle,] dvec) -&gt; dvec, nt</code></pre><p>Perform an arbitrary transformation on <code>dvec</code> after the spawning step is completed and report statistics to the <code>DataFrame</code>.</p><p>Returns the new <code>dvec</code> and a <code>NamedTuple</code> <code>nt</code> of statistics to be reported.</p><p>When extending this function for a custom <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>, define a method  for the two-argument call signature!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/update_dvec.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}" href="#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.update_dτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_dτ(s&lt;:TimeStepStrategy, dτ, tnorm) -&gt; new dτ</code></pre><p>Update the time step according to the strategy <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/timestepstrategy.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_shift" href="#Rimu.update_shift"><code>Rimu.update_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_shift(s &lt;: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df, v_new, v_old)</code></pre><p>Update the shift according to strategy <code>s</code>. See <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/strategies_and_params/shiftstrategy.jl#L13-L16">source</a></section></article><h1 id="Reexported-Submodules"><a class="docs-heading-anchor" href="#Reexported-Submodules">Reexported Submodules</a><a id="Reexported-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Reexported-Submodules" title="Permalink"></a></h1><h2 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h2><p>Link to <a href="hamiltonians.html#Module-Hamiltionians.jl">Module <code>Hamiltionians.jl</code></a></p><h2 id="BitStringAddresses"><a class="docs-heading-anchor" href="#BitStringAddresses">BitStringAddresses</a><a id="BitStringAddresses-1"></a><a class="docs-heading-anchor-permalink" href="#BitStringAddresses" title="Permalink"></a></h2><p>Link to <a href="addresses.html#Module-BitStringAddresses.jl">Module <code>BitStringAddresses.jl</code></a></p><h2 id="DictVectors"><a class="docs-heading-anchor" href="#DictVectors">DictVectors</a><a id="DictVectors-1"></a><a class="docs-heading-anchor-permalink" href="#DictVectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors" href="#Rimu.DictVectors"><code>Rimu.DictVectors</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to <code>AbstractVector</code> nor to <code>AbstractDict</code> and are suitable for use with <code>KrylovKit.jl</code>. For this, the abstract type and interface <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a> is provided, with the concrete implementation of <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/DictVectors.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractDVec" href="#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DictVectors.AbstractDVec{K,V}</code></pre><p>Abstract type for sparse vectors with <code>valtype</code> <code>V</code> based on dictionary-like structures. The vectors are designed to work well with FCIQMC and <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a>.</p><p>They lie somewhere between <code>AbstractDict</code>s and sparse <code>AbstractVector</code>s, generally behaving like a dictionary, while supportting various linear algebra functionality. Indexing with a value not stored in the dictionary returns <code>zero(V)</code>. Setting a stored value to 0 or below <code>eps(V::AbstractFloat)</code> removes the value from the dictionary. Their <code>length</code> signals the number of stored elements, not the size of the vector space.</p><p>They have a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> which selects the spawning algorithm in <code>FCIQMC</code>.</p><p>To iterate over an <code>AbstractDVec</code>, use <code>pairs</code> or <code>values</code>.</p><p><strong>Interface</strong></p><p>The interface is similar to the <code>AbstractDict</code> interface.</p><p>Implement what would be needed for the <code>AbstractDict</code> interface (<code>pairs</code>, <code>keys</code>, <code>values</code>, <code>setindex!, getindex, delete!, length, haskey, empty!, isempty</code>) and, in addition:</p><ul><li><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a></li><li><a href="API.html#Rimu.DictVectors.storage"><code>storage(dv)</code></a> returns an <code>AbstractDict</code> storing the raw data with possibly different <code>valtype</code> than <code>V</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractProjector" href="#Rimu.DictVectors.AbstractProjector"><code>Rimu.DictVectors.AbstractProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for projectors to be used in in lieu of DVecs or Vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L214-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.CoherentInitiator" href="#Rimu.DictVectors.CoherentInitiator"><code>Rimu.DictVectors.CoherentInitiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoherentInitiator(threshold) &lt;: InitiatorRule</code></pre><p>Initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li><p>Initiators can spawn anywhere.</p></li><li><p>Non-initiators can spawn to initiators.</p></li><li><p>Multiple non-initiators can spawn to a single non-initiator if their contributions add up to a value greater than the initiator threshold.</p><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L98-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.DVec" href="#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DVec{K,V,D&lt;:AbstractDict{K,V},S}</code></pre><p>Dictionary-based vector-like data structure for use with FCIQMC and <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a>. While mostly behaving like a <code>Dict</code>, it supports various linear algebra operations such as <code>norm</code> and <code>dot</code>. It has a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> that is used to select an appropriate spawning strategy in the FCIQMC algorithm.</p><p>See also: <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>.</p><p><strong>Constructors</strong></p><ul><li><p><code>DVec(dict::AbstractDict[; style, capacity])</code>: create a <code>DVec</code> with <code>dict</code> for storage. Note that the data may or may not be copied.</p></li><li><p><code>DVec(args...[; style, capacity])</code>: <code>args...</code> are passed to the <code>Dict</code> constructor. The <code>Dict</code> is used for storage.</p></li><li><p><code>DVec{K,V}([; style, capacity])</code>: create an empty <code>DVec{K,V}</code>.</p></li><li><p><code>DVec(dv::AbstractDVec[; style, capacity])</code>: create a <code>DVec</code> with the same contents as  <code>adv</code>. The <code>style</code> is inherited from <code>dv</code> by default.</p></li></ul><p>The default <code>style</code> is selected based on the <code>DVec</code>&#39;s <code>valtype</code> (see <a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>default_style</code></a>). If a style is given and the <code>valtype</code> does not match the <code>style</code>&#39;s <code>eltype</code>, the values are converted to an appropriate type.</p><p>The capacity argument is optional and sets the initial size of the <code>DVec</code> via <code>sizehint!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dv = DVec(:a =&gt; 1)
DVec{Symbol,Int64} with 1 entries, style = IsStochasticInteger{Int64}()
  :a =&gt; 1

julia&gt; dv = DVec(:a =&gt; 2, :b =&gt; 3; style=IsDynamicSemistochastic())
DVec{Symbol,Float64} with 2 entries, style = IsDynamicSemistochastic{Float64, true}(1.0, Inf, 1.0)
  :a =&gt; 2.0
  :b =&gt; 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/dvec.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.FrozenDVec" href="#Rimu.DictVectors.FrozenDVec"><code>Rimu.DictVectors.FrozenDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FrozenDVec</code></pre><p>See: <a href="API.html#OrderedCollections.freeze-Tuple{Any}"><code>freeze</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Initiator" href="#Rimu.DictVectors.Initiator"><code>Rimu.DictVectors.Initiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Initiator(threshold) &lt;: InitiatorRule</code></pre><p>Initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li>Initiators can spawn anywhere.</li><li>Non-initiators can spawn to initiators.</li></ul><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorDVec" href="#Rimu.DictVectors.InitiatorDVec"><code>Rimu.DictVectors.InitiatorDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorDVec{K,V} &lt;: AbstractDVec{K,V}</code></pre><p>Dictionary-based vector-like data structure for use with <a href="@ref"><code>lomc!</code></a> and <a href="https://github.com/Jutho/KrylovKit.jl"><code>KrylovKit.jl</code></a>. See <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>. Functionally identical to <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a>, but contains <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a>s internally in order to facilitate initiator methods. How the initiators are handled is controlled by the <code>initiator</code> keyword argument (see below).</p><p><strong>Constructors</strong></p><ul><li><p><code>InitiatorDVec(dict::AbstractDict[; style, initiator, capacity])</code>: create an <code>InitiatorDVec</code> with <code>dict</code> for storage.  Note that the data may or may not be copied.</p></li><li><p><code>InitiatorDVec(args...[; style, initiator, capacity])</code>: <code>args...</code> are passed to the <code>Dict</code> constructor. The <code>Dict</code> is used for storage.</p></li><li><p><code>InitiatorDVec{K,V}([; style, initiator, capacity])</code>: create an empty <code>InitiatorDVec{K,V}</code>.</p></li><li><p><code>InitiatorDVec(dv::AbstractDVec[; style, initiator, capacity])</code>: create an <code>InitiatorDVec</code>  with the same contents as <code>dv</code>. The <code>style</code> is inherited from <code>dv</code> by default.</p></li></ul><p><strong>Keyword  arguments</strong></p><ul><li><p><code>style</code>: A valid <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.  The default is selected based on the <code>InitiatorDVec</code>&#39;s <a href="@ref"><code>valtype</code></a> (see <a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>default_style</code></a>). If a style is given and the <code>valtype</code> does not match the <code>style</code>&#39;s <code>eltype</code>, the values are converted to an appropriate type.</p></li><li><p><code>initiator = Initiator(1)</code>: A valid <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>. See <a href="API.html#Rimu.DictVectors.Initiator"><code>Initiator</code></a>.</p></li><li><p><code>capacity</code>: Indicative size as <code>Int</code>. Optional. Sets the initial size of the <code>InitiatorDVec</code> via <a href="@ref"><code>sizehint!</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L125-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorIterator" href="#Rimu.DictVectors.InitiatorIterator"><code>Rimu.DictVectors.InitiatorIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorIterator</code></pre><p>Iterator over pairs or values of an <code>InitiatorDVec</code>. Supports the <code>SplittablesBase</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L304-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorRule" href="#Rimu.DictVectors.InitiatorRule"><code>Rimu.DictVectors.InitiatorRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorRule{V}</code></pre><p>Abstract type for defining initiator rules for <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. Concrete implementations:</p><ul><li><a href="API.html#Rimu.DictVectors.Initiator"><code>Initiator</code></a></li><li><a href="API.html#Rimu.DictVectors.SimpleInitiator"><code>SimpleInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.CoherentInitiator"><code>CoherentInitiator</code></a></li></ul><p>When defining a new <code>InitiatorRule</code>, also define a corresponding method for <a href="API.html#Rimu.DictVectors.value"><code>value</code></a>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorValue" href="#Rimu.DictVectors.InitiatorValue"><code>Rimu.DictVectors.InitiatorValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorValue{V}(; safe::V, unsafe::V, initiator::V) where V</code></pre><p>Composite &quot;walker&quot; with three fields. For use with <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsDeterministic" href="#Rimu.DictVectors.IsDeterministic"><code>Rimu.DictVectors.IsDeterministic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsDeterministic{T=Float64}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configuration indicating deterministic propagation of walkers.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsDynamicSemistochastic" href="#Rimu.DictVectors.IsDynamicSemistochastic"><code>Rimu.DictVectors.IsDynamicSemistochastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsDynamicSemistochastic{T=Float64}(rel_threshold=1, abs_threshold=Inf, proj_threshold=1) &lt;: StochasticStyle{T}</code></pre><p>QMC propagation with non-integer walker numbers and reduced noise. All possible spawns are performed deterministically when number of walkers in a configuration is high. Stochastic vector compression with threshold <code>proj_threshold</code> is applied after spawning and diagonal death steps.</p><p>Unlike with <a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a>, when <code>late_projection</code> is set to <code>true</code>, walker annihilation is done before the stochastic vector compression.</p><p><strong>Parameters:</strong></p><ul><li><p><code>late_projection = true</code>: If set to true, threshold projection is done after all spawns are collected, otherwise, values are projected as they are being spawned.</p></li><li><p><code>rel_threshold = 1.0</code>: If the walker number on a configuration times this threshold is greater than the number of offdiagonals, spawning is done deterministically. Should be set to 1 or more for best performance.</p></li><li><p><code>abs_threshold = Inf</code>: If the walker number on a configuration is greater than this value, spawning is done deterministically. Can be set to e.g <code>abs_threshold = 0.1 * target_walkers</code>.</p></li><li><p><code>proj_threshold = 1.0</code>: Values below this number are stochastically projected to this value or zero. See also <a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a>.</p></li></ul><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L86-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochastic2Pop" href="#Rimu.DictVectors.IsStochastic2Pop"><code>Rimu.DictVectors.IsStochastic2Pop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsStochastic2Pop{T=Complex{Int}}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of integer walkers.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochasticInteger" href="#Rimu.DictVectors.IsStochasticInteger"><code>Rimu.DictVectors.IsStochasticInteger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsStochasticInteger{T=Int}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation as seen in the original FCIQMC algorithm.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochasticWithThreshold" href="#Rimu.DictVectors.IsStochasticWithThreshold"><code>Rimu.DictVectors.IsStochasticWithThreshold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsStochasticWithThreshold(threshold=1.0) &lt;: StochasticStyle</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff <code>threshold</code>.</p><p>During stochastic propagation, walker numbers small than <code>threshold</code> will be stochastically projected to either zero or <code>threshold</code>.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Norm1ProjectorPPop" href="#Rimu.DictVectors.Norm1ProjectorPPop"><code>Rimu.DictVectors.Norm1ProjectorPPop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Norm1ProjectorPPop()</code></pre><p>Results in computing the one-norm per population when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(Norm1ProjectorPPop(),x)
-&gt; norm(real.(x),1) + im*norm(imag.(x),1)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L271-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Norm2Projector" href="#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Norm2Projector()</code></pre><p>Results in computing the two-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(NormProjector(),x)
-&gt; norm(x,2) # with type Float64</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L254-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.NormProjector" href="#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormProjector()</code></pre><p>Results in computing the one-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(NormProjector(),x)
-&gt; norm(x,1)</code></pre><p><code>NormProjector()</code> thus represents the vector <code>sign.(x)</code>.</p><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L238-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.PopsProjector" href="#Rimu.DictVectors.PopsProjector"><code>Rimu.DictVectors.PopsProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PopsProjector()</code></pre><p>Results in computing the projection of one population on the other when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(PopsProjector(),x)
-&gt; real(x) ⋅ imag(x)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L299-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.SimpleInitiator" href="#Rimu.DictVectors.SimpleInitiator"><code>Rimu.DictVectors.SimpleInitiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleInitiator(threshold) &lt;: InitiatorRule</code></pre><p>Simplified initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li>Initiators can spawn anywhere.</li><li>Non-initiators cannot spawn.</li></ul><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L78-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.StochasticStyle" href="#Rimu.DictVectors.StochasticStyle"><code>Rimu.DictVectors.StochasticStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochasticStyle(v)</code></pre><p>Abstract type. When called as a function it returns the native style of the generalised vector <code>v</code> that determines how simulations are to proceed.</p><p><strong>Implemented styles</strong></p><ul><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>IsStochasticInteger</code></a> - integer walker FCIQMC</li><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>IsDeterministic</code></a> - perform deterministic variant of power method</li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a> - floating point walker FCIQMC</li><li><a href="API.html#Rimu.DictVectors.IsDynamicSemistochastic"><code>IsDynamicSemistochastic</code></a></li></ul><p><strong>Usage</strong></p><p>Concrete <code>StochasticStyle</code>s can be used for the <code>style</code> keyword argument of <a href="@ref"><code>lomc!</code></a> and <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a>.</p><p><strong>Interface</strong></p><p>When defining a new <code>StochasticStyle</code>, subtype it as <code>MyStyle&lt;:StochasticStyle{T}</code> where <code>T</code> is the concrete value type the style is designed to work with.</p><p>For it to work with <a href="@ref"><code>lomc!</code></a>, a <code>StochasticStyle</code> must define the following:</p><ul><li><a href="@ref"><code>fciqmc_col!(::StochasticStyle, w, H, address, value, shift, dτ)</code></a></li><li><a href="@ref"><code>step_stats(::StochasticStyle)</code></a></li></ul><p>Optionally, it can also define <a href="@ref"><code>update_dvec!</code></a>, which can be used to perform arbitrary transformations on the generalised vector after the spawning step is complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.StyleUnknown" href="#Rimu.DictVectors.StyleUnknown"><code>Rimu.DictVectors.StyleUnknown</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StyleUnknown{T}() &lt;: StochasticStyle</code></pre><p>Trait for value types not (currently) compatible with FCIQMC. This style makes it possible to construct dict vectors with unsupported <code>valtype</code>s.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.UniformProjector" href="#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformProjector()</code></pre><p>Represents a vector with all elements 1. To be used with <a href="@ref"><code>dot()</code></a>. Minimizes memory allocations.</p><pre><code class="language-julia hljs">UniformProjector()⋅v == sum(v)
dot(UniformProjector(), LO, v) == sum(LO*v)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L219-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OrderedCollections.freeze-Tuple{Any}" href="#OrderedCollections.freeze-Tuple{Any}"><code>OrderedCollections.freeze</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freeze(dv)</code></pre><p>Create a &quot;frozen&quot; version of <code>dv</code> which can no longer be modified or used in the conventional manner, but supports faster dot products.</p><p>If <code>dv</code> is an <a href="@ref"><code>MPIData</code></a>, synchronize its contents among the ranks first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L356-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K" href="#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K"><code>Rimu.DictVectors.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add!(x::AbstractDVec,y::AbstactDVec)</code></pre><p>Inplace add <code>x+y</code> and store result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer" href="#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Rimu.DictVectors.default_style</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_style(::Type)</code></pre><p>Pick a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> based on the value type. Throws an error if no known default style is known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/stochasticstyle.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.deposit!-NTuple{4, Any}" href="#Rimu.DictVectors.deposit!-NTuple{4, Any}"><code>Rimu.DictVectors.deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deposit!(w::AbstractDVec, add, val, parent::Pair)</code></pre><p>Add <code>val</code> into <code>w</code> at address <code>add</code>, taking into account initiator rules if applicable. <code>parent</code> contains the <code>address =&gt; value</code> pair from which the pair <code>add =&gt; val</code> was created. <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a> can intercept this and add its own functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V" href="#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V"><code>Rimu.DictVectors.deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deposit!(w::InitiatorDVec, add, val, p_add=&gt;p_val)</code></pre><p>Add <code>val</code> into <code>w</code> at address <code>add</code> as an <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L266-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.localpart-Tuple{Any}" href="#Rimu.DictVectors.localpart-Tuple{Any}"><code>Rimu.DictVectors.localpart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localpart(dv) -&gt; AbstractDVec</code></pre><p>Get the part of <code>dv</code> that is located on this MPI rank. Returns <code>dv</code> itself for <code>DictVector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L336-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.storage" href="#Rimu.DictVectors.storage"><code>Rimu.DictVectors.storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">storage(dvec) -&gt; AbstractDict</code></pre><p>Return the raw storage associated with <code>dvec</code> as an <code>AbstractDict</code>. Used in MPI communication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.value" href="#Rimu.DictVectors.value"><code>Rimu.DictVectors.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value(i::InitiatorRule, v::InitiatorValue)</code></pre><p>Convert the <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a> <code>v</code> into a scalar value according to the <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a> <code>i</code>.</p><p>Internal function that implements functionality of <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/initiators.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.walkernumber-Tuple{Any}" href="#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>Rimu.DictVectors.walkernumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">walkernumber(w)</code></pre><p>Compute the number of walkers in <code>w</code>. It is used for updating the shift. Overload this function for modifying population control.</p><p>In most cases <code>walkernumber(w)</code> is identical to <code>norm(w,1)</code>. For <code>AbstractDVec</code>s with complex coefficients it reports the one norm separately for the real and the imaginary part as a <code>ComplexF64</code>. See <a href="API.html#Rimu.DictVectors.Norm1ProjectorPPop"><code>Norm1ProjectorPPop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L320-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.zero!-Tuple{AbstractDVec}" href="#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero!(v)</code></pre><p>Replace <code>v</code> by a zero vector as an inplace operation. For <code>AbstractDVec</code> types it means removing all non-zero elements. For <code>AbstractArrays</code>, it sets all of the values to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/DictVectors/abstractdvec.jl#L78-L83">source</a></section></article><h2 id="ConsistentRNG"><a class="docs-heading-anchor" href="#ConsistentRNG">ConsistentRNG</a><a id="ConsistentRNG-1"></a><a class="docs-heading-anchor-permalink" href="#ConsistentRNG" title="Permalink"></a></h2><p>Link to <a href="consistentrng.html#Module-ConsistentRNG.jl">Module <code>ConsistentRNG.jl</code></a></p><h1 id="Unexported-Submodules"><a class="docs-heading-anchor" href="#Unexported-Submodules">Unexported Submodules</a><a id="Unexported-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Unexported-Submodules" title="Permalink"></a></h1><h2 id="StatsTools"><a class="docs-heading-anchor" href="#StatsTools">StatsTools</a><a id="StatsTools-1"></a><a class="docs-heading-anchor-permalink" href="#StatsTools" title="Permalink"></a></h2><p>Link to <a href="statstools.html#Module-Rimu/StatsTools">Module <code>Rimu/StatsTools</code></a></p><h2 id="Blocking"><a class="docs-heading-anchor" href="#Blocking">Blocking</a><a id="Blocking-1"></a><a class="docs-heading-anchor-permalink" href="#Blocking" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking" href="#Rimu.Blocking"><code>Rimu.Blocking</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>Blocking</code></p><p>Module that contains functions performing the Flyvbjerg-Petersen (J. Chem. Phys. 91, 461 (1989)) blocking analysis for evaluating the standard error on a correlated data set. A &quot;M-test&quot; is also implemented based on Jonsson (Phys. Rev. E 98, 043304, (2018)).</p><p>Note: This module is deprecated and will be removed soon. Use <a href="@ref"><code>StatsTools</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.autoblock-Tuple{DataFrames.DataFrame}" href="#Rimu.Blocking.autoblock-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.autoblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoblock(df::DataFrame; start = 1, stop = size(df)[1])
-&gt; s̄, σs, ē, σe, k</code></pre><p>Determine mean shift <code>s̄</code> and projected energy <code>ē</code> with respective standard errors <code>σs</code> and <code>σe</code> by blocking analsis from the <code>DataFrame</code> <code>df</code> returned from <code>fciqmc!()</code>. The number <code>k</code> of blocking steps and decorrelation time <code>2^k</code> are obtained from the M-test for the shift and also applied to the projected energy, assuming that the projected quantities decorrelate on the same time scale. Only the real part of the shift is considered. Returns a named tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L409-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.autoblock-Tuple{Tuple}" href="#Rimu.Blocking.autoblock-Tuple{Tuple}"><code>Rimu.Blocking.autoblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autoblock(dftup::Tuple; start = 1, stop = size(dftup[1])[1])
-&gt; s̄1, σs1, s̄2, σs2, ē1, σe1, ē2, σe2, ēH, σeH, k</code></pre><p>Replica version. <code>dftup</code> is the tuple of <code>DataFrame</code>s returned from replica <code>fciqmc!()</code>. Returns a named tuple with shifts and three variational energy estimators and respective errors obtained from blocking analysis. The larger of the <code>k</code> values from M-tests on the two shift time series is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L434-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.autocovariance-Tuple{Vector{T} where T, Int64}" href="#Rimu.Blocking.autocovariance-Tuple{Vector{T} where T, Int64}"><code>Rimu.Blocking.autocovariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">autocovariance(v::Vector,h::Int; corrected::Bool=true)</code></pre><p><span>$\hat{\gamma}(h) =\frac{1}{n}\sum_{t=1}^{n-h}(v_{t+h}-\bar{v})(v_t-\bar{v})^*$</span> Calculate the autocovariance of dataset <code>v</code> with a delay <code>h</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-h</code>, whereas the sum is scaled with <code>n</code> if corrected is <code>false</code> where <code>n = length(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L107-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blockAndMTest-Tuple{Vector{T} where T}" href="#Rimu.Blocking.blockAndMTest-Tuple{Vector{T} where T}"><code>Rimu.Blocking.blockAndMTest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">v̄, σ, σσ, k, df = blockAndMTest(v::Vector)</code></pre><p>Perform a blocking analysis and M-test on <code>v</code> returning the mean <code>v̄</code>, standard error <code>σ</code>, its error <code>σσ</code>, the number of blocking steps <code>k</code>, and the <code>DataFrame</code> <code>df</code> with blocking data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L377-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocker-Union{Tuple{Vector{T}}, Tuple{T}} where T" href="#Rimu.Blocking.blocker-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>Rimu.Blocking.blocker</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blocker(v::Vector) -&gt; new_v::Vector</code></pre><p>Reblock the data by successively taking the mean of two adjacent data points to form a new vector with a half of the <code>length(v)</code>. The last data point will be discarded if <code>length(v)</code> is odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1, T2}" href="#Rimu.Blocking.blocking-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1, T2}"><code>Rimu.Blocking.blocking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blocking(x::Vector,y::Vector) -&gt; df::DataFrame</code></pre><p>Perform a blocking analysis for the quotient of means <code>x̄/ȳ</code> from two data sets. If <code>corrected</code> is <code>true</code> (the default) then the sums in both variance and covariance are scaled with <code>n-1</code>, whereas the sums are scaled with <code>n</code> if corrected is <code>false</code>  where <code>n = length(x) = length(y)</code>. Entries in returned dataframe:</p><ul><li><code>blocks</code> = number of blocks in current blocking step;</li><li><code>mean_x</code>, <code>SD_x</code>, <code>SE_x</code>, <code>SE_SE_x</code> = the mean, standard deviation, standard error and error on standard error estimated for dataset <code>x</code>;</li><li><code>mean_y</code>, <code>SD_y</code>, <code>SE_y</code>, <code>SE_SE_y</code> = ditto. for dataset <code>y</code>;</li><li><code>Covariance</code> = the covariance between data in <code>x</code> and <code>y</code>;</li><li><code>mean_f</code> = <code>x̄/ȳ</code>;</li><li><code>SE_f</code> = standard error estimated for <code>x̄/ȳ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L213-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking-Union{Tuple{Vector{T}}, Tuple{T}} where T" href="#Rimu.Blocking.blocking-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>Rimu.Blocking.blocking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blocking(v::Vector; corrected::Bool=true) -&gt; df</code></pre><p>Perform a blocking analysis according to Flyvberg and Peterson <a href="http://aip.scitation.org/doi/10.1063/1.457480">JCP (1989)</a> for single data set and return a <code>DataFrame</code> with statistical data for each blocking step. M-test data according to Jonsson <a href="https://link.aps.org/doi/10.1103/PhysRevE.98.043304">PRE (2018)</a> is also provided. If <code>corrected</code> is <code>true</code> (the default) then the sum in <code>var</code> is scaled with <code>n-1</code> and in <code>autocovariance</code> is scaled with <code>n-h</code>, whereas the sum is scaled with <code>n</code> for both if corrected is <code>false</code> where <code>n = length(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L125-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking_old-Tuple{Vector{T} where T}" href="#Rimu.Blocking.blocking_old-Tuple{Vector{T} where T}"><code>Rimu.Blocking.blocking_old</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">blocking(v::Vector; typos = nothing) -&gt; df</code></pre><p>Perform a blocking analysis according to Flyvberg and Peterson <a href="http://aip.scitation.org/doi/10.1063/1.457480">JCP (1989)</a> for single data set and return a <code>DataFrame</code> with statistical data for each blocking step. M-test data according to Jonsson <a href="https://link.aps.org/doi/10.1103/PhysRevE.98.043304">PRE (2018)</a> is also provided.</p><p>Keyword argument <code>typos</code></p><ul><li><code>typos = nothing</code> - correct all presumed typos.</li><li><code>typos = :FP</code> - use Flyvberg and Peterson (correct) standard error and Jonsson formul for M.</li><li><code>typos = :Jonsson</code> - calculate <code>M</code> and standard error as written in Jonsson.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L63-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.combination_division-Tuple{Vector{T} where T, Vector{T} where T}" href="#Rimu.Blocking.combination_division-Tuple{Vector{T} where T, Vector{T} where T}"><code>Rimu.Blocking.combination_division</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combination_division(x::Vector,y::Vector; corrected::Bool=true)</code></pre><p>Find the standard error on the quotient of means <code>x̄/ȳ</code> from two data sets, note that the standard errors are different on <span>$(x̄/ȳ) \neq \bar{(\frac{x}{y})}$</span>. If <code>corrected</code> is <code>true</code> (the default) then the sums in both variance and covariance are scaled with <code>n-1</code>, whereas the sums are scaled with <code>n</code> if corrected is <code>false</code>  where <code>n = length(x) = length(y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L184-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.covariance-Tuple{Vector{T} where T, Vector{T} where T}" href="#Rimu.Blocking.covariance-Tuple{Vector{T} where T, Vector{T} where T}"><code>Rimu.Blocking.covariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">covariance(x::Vector,y::Vector; corrected::Bool=true)</code></pre><p>Calculate the covariance between the two data sets <code>x</code> and <code>y</code> with equal length. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with  <code>n-1</code>, whereas the sum is scaled with <code>n</code> if corrected is <code>false</code>  where <code>n = length(x) = length(y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.gW-Tuple{AbstractArray, AbstractArray, Any}" href="#Rimu.Blocking.gW-Tuple{AbstractArray, AbstractArray, Any}"><code>Rimu.Blocking.gW</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gW(norm::AbstractArray, shift::AbstractArray, dt, [b]; pad = :true) -&gt; g
gW(df::DataFrame, [b]; pad = :true) -&gt; g</code></pre><p>Compute the growth witness</p><p class="math-container">\[G^{(n)} = S^{(n)} - \frac{\vert\mathbf{c}^{(n+1)}\vert - \vert\mathbf{c}^{(n)}\vert}{\vert\mathbf{c}^{(n)}\vert d\tau},\]</p><p>where <code>S</code> is the <code>shift</code> and <span>$\vert\mathbf{c}^{(n)}\vert ==$</span> <code>norm[n, 1]</code>. Setting <code>b ≥ 1</code> a sliding average over <code>b</code> time steps is computed.</p><p>If <code>pad</code> is set to <code>:false</code> then the returned array <code>g</code> has the length <code>length(norm) - b</code>. If set to <code>:true</code> then <code>g</code> will be padded up to the same length as <code>norm</code> and <code>shift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L514-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.growthWitness-Tuple{AbstractArray, AbstractArray, Any}" href="#Rimu.Blocking.growthWitness-Tuple{AbstractArray, AbstractArray, Any}"><code>Rimu.Blocking.growthWitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">growthWitness(norm::AbstractArray, shift::AbstractArray, dt; b = 30, pad = :true) -&gt; g
growthWitness(df::DataFrame; b = 30, pad = :true) -&gt; g</code></pre><p>Compute the growth witness</p><p class="math-container">\[G_b^{(n)} = S̄^{(n)} - \frac{\log\vert\mathbf{c}^{(n+b)}\vert - \log\vert\mathbf{c}^{(n)}\vert}{b d\tau},\]</p><p>where <code>S̄</code> is an average of the <code>shift</code> over <code>b</code> time steps and <span>$\vert\mathbf{c}^{(n)}\vert ==$</span> <code>norm[n]</code>. The parameter <code>b ≥ 1</code> averages the derivative quantity over <code>b</code> time steps and helps suppress noise.</p><p>If <code>pad</code> is set to <code>:false</code> then the returned array <code>g</code> has the length <code>length(norm) - b</code>. If set to <code>:true</code> then <code>g</code> will be padded up to the same length as <code>norm</code> and <code>shift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L463-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}" href="#Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.mtest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mtest(df::DataFrame; warn = true) -&gt; k</code></pre><p>The &quot;M test&quot; based on Jonsson, M. Physical Review E, 98(4), 043304, (2018). Expects <code>df</code> to be output of a blocking analysis with column <code>df.M</code> containing relevant M_j values, which are compared to a χ^2 distribution. Returns the row number <code>k</code> where the M-test is passed. If the M-test has failed <code>mtest()</code> returns the value <code>-1</code> and optionally prints a warning message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L302-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.se-Tuple{Vector{T} where T}" href="#Rimu.Blocking.se-Tuple{Vector{T} where T}"><code>Rimu.Blocking.se</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">se(v::Vector;corrected::Bool=true)</code></pre><p>Calculate the standard error of the dataset <code>v</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum in <code>std</code> is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if corrected is <code>false</code> where <code>n = length(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.smoothen-Tuple{AbstractVector{T} where T, Any}" href="#Rimu.Blocking.smoothen-Tuple{AbstractVector{T} where T, Any}"><code>Rimu.Blocking.smoothen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">smoothen(noisy::AbstractVector, b; pad = :true)</code></pre><p>Smoothen the array <code>noisy</code> by averaging over a sliding window of length <code>b</code>. Pad to <code>length(noisy)</code> if <code>pad == true</code>. Otherwise, the returned array will have the length <code>length(noisy) - b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/Blocking.jl#L493-L498">source</a></section></article><h2 id="RMPI"><a class="docs-heading-anchor" href="#RMPI">RMPI</a><a id="RMPI-1"></a><a class="docs-heading-anchor-permalink" href="#RMPI" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI" href="#Rimu.RMPI"><code>Rimu.RMPI</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module for providing MPI functionality for <code>Rimu</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/RMPI.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_root" href="#Rimu.RMPI.mpi_root"><code>Rimu.RMPI.mpi_root</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Default MPI root for <code>RMPI</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L2">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.MPIAllToAll" href="#Rimu.RMPI.MPIAllToAll"><code>Rimu.RMPI.MPIAllToAll</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> MPIAllToAll</code></pre><p>All-to-all communication strategy. The communication works in two steps: first <code>MPI.Alltoall!</code> is used to communicate the number of walkers each rank wants to send to other ranks, then <code>MPI.Alltoallv!</code> is used to send the walkers around.</p><p><strong>Constructor</strong></p><ul><li><code>MPIAllToAll(Type{P}, np, id, comm)</code>: Construct an instance with pair type <code>P</code> on <code>np</code> processes with current rank <code>id</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/alltoall.jl#L16-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.MPIData" href="#Rimu.RMPI.MPIData"><code>Rimu.RMPI.MPIData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPIData(data; kwargs...)</code></pre><p>Wrapper used for signaling that this data is part of a distributed data structure and communication should happen with MPI.</p><p>Keyword arguments:</p><ul><li><code>setup = mpi_point_to_point</code> - controls the communication stratgy<ul><li><a href="API.html#Rimu.RMPI.mpi_one_sided"><code>mpi_one_sided</code></a> uses one-sided communication with remote memory access (RMA), sets <a href="API.html#Rimu.RMPI.MPIOneSided"><code>MPIOneSided</code></a> strategy.</li><li><a href="API.html#Rimu.RMPI.mpi_point_to_point"><code>mpi_point_to_point</code></a> uses <a href="@ref"><code>MPIPointTOPoint</code></a> strategy.</li><li><a href="API.html#Rimu.RMPI.mpi_all_to_all"><code>mpi_all_to_all</code></a> uses <a href="API.html#Rimu.RMPI.MPIAllToAll"><code>MPIAllToAll</code></a> strategy.</li><li><a href="API.html#Rimu.RMPI.mpi_no_exchange"><code>mpi_no_exchange</code></a> sets <a href="API.html#Rimu.RMPI.MPINoWalkerExchange"><code>MPINoWalkerExchange</code></a> strategy. Experimental. Use with caution!</li></ul></li><li><code>comm = mpi_comm()</code></li><li><code>root = mpi_root</code></li><li>The rest of the keyword arguments are passed to <code>setup</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.MPIDataIterator" href="#Rimu.RMPI.MPIDataIterator"><code>Rimu.RMPI.MPIDataIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPIDataIterator{I,M&lt;:MPIData}</code></pre><p>Iterator over <code>keys</code>, <code>values</code>, or <code>pairs</code> of a <code>dv::MPIData</code>. Unlike its name would suggest, it does not actually support iteration. To perform computations with it, use <code>mapreduce</code>, or its derivatives (<code>sum</code>, <code>prod</code>, <code>reduce</code>...), which will perform the reduction accross MPI ranks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L62-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.MPINoWalkerExchange" href="#Rimu.RMPI.MPINoWalkerExchange"><code>Rimu.RMPI.MPINoWalkerExchange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPINoWalkerExchange(nprocs, my_rank, comm)</code></pre><p>Strategy for for not exchanging walkers between ranks. Consequently there will be no cross-rank annihilations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/noexchange.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.MPIOneSided" href="#Rimu.RMPI.MPIOneSided"><code>Rimu.RMPI.MPIOneSided</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPIOneSided(nprocs, myrank, comm, ::Type{T}, capacity)</code></pre><p>Communication buffer for use with MPI one-sided communication (remote memory access). Up to <code>capacity</code> elements of type <code>T</code> can be exchanged between MPI ranks via <a href="API.html#Rimu.RMPI.put-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Rimu.RMPI.MPIOneSided{T}}} where T"><code>put</code></a>. It is important that <code>isbitstype(T) == true</code>. Objects of type <code>MPIOneSided</code> have to be freed manually with a (blocking) call to <a href="API.html#Rimu.RMPI.free-Tuple{Rimu.RMPI.MPIOneSided}"><code>free()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/onesided.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.MPIPointToPoint" href="#Rimu.RMPI.MPIPointToPoint"><code>Rimu.RMPI.MPIPointToPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MPIPointToPoint{N,A}</code></pre><p>Point-to-point communication strategy. Uses circular communication using <code>MPI.Send</code> and <code>MPI.Recv!</code>.</p><p><strong>Constructor</strong></p><ul><li><code>MPIPointToPoint(::Type{P}, np, id, comm)</code>: Construct an instance with pair type <code>P</code> on <code>np</code> processes with current rank <code>id</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/pointtopoint.jl#L16-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Any, Rimu.RMPI.MPIData}" href="#Base.:*-Tuple{Any, Rimu.RMPI.MPIData}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">*(lop::AbstractHamiltonian, md::MPIData)</code></pre><p>Allocating &quot;Matrix&quot;-&quot;vector&quot; multiplication with MPI-distributed &quot;vector&quot; <code>md</code>. The result is similar to <a href="API.html#Rimu.DictVectors.localpart-Tuple{Any}"><code>localpart(md)</code></a> with all content having been communicated to the correct <a href="API.html#Rimu.RMPI.targetrank-Tuple{Union{Integer, AbstractFockAddress}, Any}"><code>targetrank</code></a>. MPI communicating.</p><p>See <a href="API.html#Rimu.RMPI.MPIData"><code>MPIData</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L184-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{Rimu.RMPI.MPIData}" href="#Base.length-Tuple{Rimu.RMPI.MPIData}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(md::MPIData)</code></pre><p>Compute the length of the distributed data on every MPI rank with <code>MPI.Allreduce</code>. MPI syncronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">norm(md::MPIData, p=2)</code></pre><p>Compute the norm of the distributed data on every MPI rank with <code>MPI.Allreduce</code>. MPI syncronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ConsistentRNG.check_crng_independence-Tuple{Rimu.RMPI.MPIData}" href="#Rimu.ConsistentRNG.check_crng_independence-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.ConsistentRNG.check_crng_independence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ConsistentRNGs.check_crng_independence(dv::MPIData)</code></pre><p>Does a sanity check to detect dependence of random number generators across all MPI ranks. Returns the size of the combined RNG state, i.e. <code>mpi_size()*Threads.nthreads()*fieldcount(ConsistentRNG.CRNG)</code>. MPI syncronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L120-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ConsistentRNG.sync_cRandn-Tuple{Rimu.RMPI.MPIData}" href="#Rimu.ConsistentRNG.sync_cRandn-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.ConsistentRNG.sync_cRandn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sync_cRandn(md::MPIData)</code></pre><p>Generate one random number with <a href="consistentrng.html#Rimu.ConsistentRNG.cRandn-Tuple"><code>cRandn()</code></a> in a synchronous way such that all MPI ranks have the same random number. The argument is ignored unless it is of type <code>MPIData</code>, in which case a random number from the root rank is broadcasted to all MPI ranks. MPI syncronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.walkernumber-Tuple{Rimu.RMPI.MPIData}" href="#Rimu.DictVectors.walkernumber-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.DictVectors.walkernumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">walkernumber(md::MPIData)</code></pre><p>Compute the walkernumber of the distributed data on every MPI rank with <code>MPI.Allreduce</code>. MPI syncronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L120-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.copy_to_local!-Tuple{Any, Rimu.RMPI.MPIData}" href="#Rimu.RMPI.copy_to_local!-Tuple{Any, Rimu.RMPI.MPIData}"><code>Rimu.RMPI.copy_to_local!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_to_local!(target, md::MPIData)</code></pre><p>Collect all pairs in <code>md</code> from all ranks and store them in <code>target</code>. In-place version of <a href="API.html#Rimu.RMPI.copy_to_local-Tuple{Rimu.RMPI.MPIData}"><code>copy_to_local</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L243-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.copy_to_local-Tuple{Rimu.RMPI.MPIData}" href="#Rimu.RMPI.copy_to_local-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.RMPI.copy_to_local</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_to_local(md::MPIData)</code></pre><p>Collect all pairs in <code>md</code> from all ranks and store them in a local <code>AbstractDVec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.free-Tuple{Rimu.RMPI.MPIOneSided}" href="#Rimu.RMPI.free-Tuple{Rimu.RMPI.MPIOneSided}"><code>Rimu.RMPI.free</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">free(obj::MPIOneSided)</code></pre><p>De-reference the object, call finalizer and the garbage collector immediately. This is a syncronizing MPI call. Make sure that the object is not used later. MPI syncronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/onesided.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.is_mpi_root" href="#Rimu.RMPI.is_mpi_root"><code>Rimu.RMPI.is_mpi_root</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_mpi_root(root = mpi_root)</code></pre><p>Returns <code>true</code> if called from the root rank</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L31-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_all_to_all" href="#Rimu.RMPI.mpi_all_to_all"><code>Rimu.RMPI.mpi_all_to_all</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_all_to_all(data, comm = mpi_comm(), root = mpi_root)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to all-to-all.</p><p>Sets up the <a href="API.html#Rimu.RMPI.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.RMPI.MPIAllToAll"><code>MPIAllToAll</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/alltoall.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_allprintln-Tuple" href="#Rimu.RMPI.mpi_allprintln-Tuple"><code>Rimu.RMPI.mpi_allprintln</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mpi_allprintln(args...)</code></pre><p>Print a message to <code>stdout</code> from each rank separately, in order. MPI synchronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L158-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_barrier" href="#Rimu.RMPI.mpi_barrier"><code>Rimu.RMPI.mpi_barrier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_barrier(comm = mpi_comm())</code></pre><p>The MPI barrier with optional argument. MPI syncronizing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L59-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_combine_walkers!-Tuple{Rimu.RMPI.MPIData, AbstractDVec}" href="#Rimu.RMPI.mpi_combine_walkers!-Tuple{Rimu.RMPI.MPIData, AbstractDVec}"><code>Rimu.RMPI.mpi_combine_walkers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mpi_combine_walkers!(target, source, [strategy])</code></pre><p>Distribute the entries of <code>source</code> to the <code>target</code> data structure such that all entries in the <code>target</code> are on the process with the correct mpi rank as controlled by <a href="API.html#Rimu.RMPI.targetrank-Tuple{Union{Integer, AbstractFockAddress}, Any}"><code>targetrank()</code></a>. MPI syncronizing.</p><p>Note: the <a href="API.html#Rimu.DictVectors.storage"><code>storage</code></a> of the <code>source</code> is communicated rather than the <code>source</code> itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L72-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_comm-Tuple{}" href="#Rimu.RMPI.mpi_comm-Tuple{}"><code>Rimu.RMPI.mpi_comm</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Default MPI communicator for <code>RMPI</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_communicate_buffers!-Tuple{Any, Any, Any}" href="#Rimu.RMPI.mpi_communicate_buffers!-Tuple{Any, Any, Any}"><code>Rimu.RMPI.mpi_communicate_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mpi_communicate_buffers!(target::AbstractDVec{K,V}, buffers::Vector{&lt;:Vector{V}})</code></pre><p>Use MPI to communicate the contents of <code>buffers</code> and sort them into <code>target</code>. The length of <code>buffers</code> should be equal to <a href="API.html#Rimu.RMPI.mpi_size"><code>mpi_size</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_no_exchange" href="#Rimu.RMPI.mpi_no_exchange"><code>Rimu.RMPI.mpi_no_exchange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_no_exchange(data, comm = mpi_comm(), root = mpi_root)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to <code>MPINoWalkerExchange</code>. Sets up the <a href="API.html#Rimu.RMPI.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.RMPI.MPINoWalkerExchange"><code>MPINoWalkerExchange</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/noexchange.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_one_sided" href="#Rimu.RMPI.mpi_one_sided"><code>Rimu.RMPI.mpi_one_sided</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_one_sided(data, comm = mpi_comm(), root = mpi_root; capacity)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to one-sided with remote memory access (RMA). <code>capacity</code> sets the capacity of the RMA windows.</p><p>Sets up the <a href="API.html#Rimu.RMPI.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.RMPI.MPIOneSided"><code>MPIOneSided</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/onesided.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_point_to_point" href="#Rimu.RMPI.mpi_point_to_point"><code>Rimu.RMPI.mpi_point_to_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_point_to_point(data, comm = mpi_comm(), root = mpi_root)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to point-to-point.</p><p>Sets up the <a href="API.html#Rimu.RMPI.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.RMPI.MPIPointToPoint"><code>MPIPointToPoint</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/pointtopoint.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_rank" href="#Rimu.RMPI.mpi_rank"><code>Rimu.RMPI.mpi_rank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_rank(comm = mpi_comm())</code></pre><p>Return the current MPI rank.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L25-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_seed_CRNGs!" href="#Rimu.RMPI.mpi_seed_CRNGs!"><code>Rimu.RMPI.mpi_seed_CRNGs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_seed_CRNGs!(seed = rand(Random.RandomDevice(), UInt))</code></pre><p>Re-seed the random number generators in an MPI-safe way. If seed is provided, the random numbers from <a href="consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple"><code>cRand()</code></a> will follow a deterministic sequence.</p><p>Independence of the random number generators on different MPI ranks is achieved by adding <code>hash(mpi_rank())</code> to <code>seed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L144-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_size" href="#Rimu.RMPI.mpi_size"><code>Rimu.RMPI.mpi_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mpi_size(comm = mpi_comm())</code></pre><p>Size of MPI communicator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L8-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.mpi_synchronize!-Tuple{Rimu.RMPI.MPIData}" href="#Rimu.RMPI.mpi_synchronize!-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.RMPI.mpi_synchronize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mpi_synchronize!(md::MPIData)</code></pre><p>Synchronize <code>md</code>, ensuring its contents are distributed among ranks correctly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/mpidata.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.next_mpiID" href="#Rimu.RMPI.next_mpiID"><code>Rimu.RMPI.next_mpiID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">next_mpiID()</code></pre><p>Produce a new ID number for MPI distributed objects. Uses an internal counter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.put-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Rimu.RMPI.MPIOneSided{T}}} where T" href="#Rimu.RMPI.put-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Rimu.RMPI.MPIOneSided{T}}} where T"><code>Rimu.RMPI.put</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">put(buf::Vector{T}, [len,] targetrank, s::MPIOneSided{T})</code></pre><p>Deposit a vector <code>buf</code> into the MPI window <code>s</code> on rank <code>targetrank</code>. If <code>len</code> is given, only the first <code>len</code> elements are transmitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/onesided.jl#L106-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.receive!-Union{Tuple{P}, Tuple{Any, Rimu.RMPI.MPIPointToPoint{P, N} where N, Any}} where P" href="#Rimu.RMPI.receive!-Union{Tuple{P}, Tuple{Any, Rimu.RMPI.MPIPointToPoint{P, N} where N, Any}} where P"><code>Rimu.RMPI.receive!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">receive!(target, s::MPIPointToPoint, id)</code></pre><p>Recieve from rank with <code>id</code> and move recieved values to <code>target</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/pointtopoint.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.recvbuff-Tuple{Rimu.RMPI.MPIPointToPoint}" href="#Rimu.RMPI.recvbuff-Tuple{Rimu.RMPI.MPIPointToPoint}"><code>Rimu.RMPI.recvbuff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recvbuff(s::MPIPointToPoint)</code></pre><p>Get the receive buffer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/pointtopoint.jl#L40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.send!-Union{Tuple{Rimu.RMPI.MPIPointToPoint{var&quot;#s487&quot;, N} where var&quot;#s487&quot;}, Tuple{N}} where N" href="#Rimu.RMPI.send!-Union{Tuple{Rimu.RMPI.MPIPointToPoint{var&quot;#s487&quot;, N} where var&quot;#s487&quot;}, Tuple{N}} where N"><code>Rimu.RMPI.send!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">send!(s::MPIPointToPoint{P})</code></pre><p>Send the contents of the send buffers to all other ranks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/pointtopoint.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.sendbuff-Tuple{Rimu.RMPI.MPIPointToPoint, Any}" href="#Rimu.RMPI.sendbuff-Tuple{Rimu.RMPI.MPIPointToPoint, Any}"><code>Rimu.RMPI.sendbuff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sendbuff(s::MPIPointToPoint, id)</code></pre><p>Get the send buffer associated with <code>id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/pointtopoint.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.sort_and_count!" href="#Rimu.RMPI.sort_and_count!"><code>Rimu.RMPI.sort_and_count!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sort_and_count!(counts, displs, vec, order, (lo, hi), i_start, j_start)</code></pre><p>Sort new spawns by target rank. While this is done, also count the values and calculate the offsets needed for <code>MPI.Alltoallv!</code>.</p><p><code>counts</code>, <code>displs</code>, <code>vec</code>, and <code>order</code> are modified in-place. <code>order</code> should contain the values you want to sort vec by. (i.e. <code>targetrank.(vec, s.np)</code>)</p><pre><code class="nohighlight hljs">sort_and_count!(s::MPIAllToAll)</code></pre><p>As above, but operating on the internal buffers of <code>s</code>. Note that <code>s.targets</code> is expected to contain the correct values to sort by.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/alltoall.jl#L64-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.targetrank-Tuple{Union{Integer, AbstractFockAddress}, Any}" href="#Rimu.RMPI.targetrank-Tuple{Union{Integer, AbstractFockAddress}, Any}"><code>Rimu.RMPI.targetrank</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">targetrank(key, np)</code></pre><p>Compute the rank where the <code>key</code> belongs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.@mpi_root-Tuple" href="#Rimu.RMPI.@mpi_root-Tuple"><code>Rimu.RMPI.@mpi_root</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mpi_root expr</code></pre><p>Evaluate expression only on the root rank. Extra care needs to be taken as <code>expr</code> <em>must not</em> contain any code that involves syncronising MPI operations, i.e. actions that would require syncronous action of all MPI ranks.</p><p>Example:</p><pre><code class="language-julia hljs">wn = walkernumber(dv)   # an MPI syncronising function call that gathers
                        # information from all MPI ranks
@mpi_root @info &quot;The current walker number is&quot; wn # print info message on root only</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/helpers.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RMPI.@swap!-Tuple{Any, Any, Any}" href="#Rimu.RMPI.@swap!-Tuple{Any, Any, Any}"><code>Rimu.RMPI.@swap!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@swap! arr i j</code></pre><p>Swap the <code>i</code>-th and <code>j</code>-th indices in <code>arr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08733186d16f05411a676a65e1966c1569d9cb16/src/RMPI/alltoall.jl#L50-L54">source</a></section></article><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="API.html#Rimu.Blocking"><code>Rimu.Blocking</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG"><code>Rimu.ConsistentRNG</code></a></li><li><a href="API.html#Rimu.DictVectors"><code>Rimu.DictVectors</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a></li><li><a href="API.html#Rimu.RMPI"><code>Rimu.RMPI</code></a></li><li><a href="API.html#Rimu.Rimu"><code>Rimu.Rimu</code></a></li><li><a href="statstools.html#Rimu.StatsTools"><code>Rimu.StatsTools</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNGs"><code>Rimu.ConsistentRNG.CRNGs</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_root"><code>Rimu.RMPI.mpi_root</code></a></li><li><a href="statstools.html#Core.NamedTuple-Tuple{Rimu.StatsTools.BlockingResult}"><code>Core.NamedTuple</code></a></li><li><a href="statstools.html#MonteCarloMeasurements.Particles-Tuple{Rimu.StatsTools.BlockingResult{var&quot;#s233&quot;} where var&quot;#s233&quot;&lt;:Real}"><code>MonteCarloMeasurements.Particles</code></a></li><li><a href="API.html#Rimu.AllOverlaps"><code>Rimu.AllOverlaps</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>Rimu.BitStringAddresses.AbstractFockAddress</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.BitString"><code>Rimu.BitStringAddresses.BitString</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS2C"><code>Rimu.BitStringAddresses.BoseFS2C</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.CompositeFS"><code>Rimu.BitStringAddresses.CompositeFS</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.FermiFS"><code>Rimu.BitStringAddresses.FermiFS</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>Rimu.BitStringAddresses.SingleComponentFockAddress</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNG"><code>Rimu.ConsistentRNG.CRNG</code></a></li><li><a href="API.html#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a></li><li><a href="API.html#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractProjector"><code>Rimu.DictVectors.AbstractProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.CoherentInitiator"><code>Rimu.DictVectors.CoherentInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FrozenDVec"><code>Rimu.DictVectors.FrozenDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.Initiator"><code>Rimu.DictVectors.Initiator</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>Rimu.DictVectors.InitiatorDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorIterator"><code>Rimu.DictVectors.InitiatorIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorRule"><code>Rimu.DictVectors.InitiatorRule</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorValue"><code>Rimu.DictVectors.InitiatorValue</code></a></li><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>Rimu.DictVectors.IsDeterministic</code></a></li><li><a href="API.html#Rimu.DictVectors.IsDynamicSemistochastic"><code>Rimu.DictVectors.IsDynamicSemistochastic</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochastic2Pop"><code>Rimu.DictVectors.IsStochastic2Pop</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>Rimu.DictVectors.IsStochasticInteger</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>Rimu.DictVectors.IsStochasticWithThreshold</code></a></li><li><a href="API.html#Rimu.DictVectors.Norm1ProjectorPPop"><code>Rimu.DictVectors.Norm1ProjectorPPop</code></a></li><li><a href="API.html#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a></li><li><a href="API.html#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.PopsProjector"><code>Rimu.DictVectors.PopsProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.SimpleInitiator"><code>Rimu.DictVectors.SimpleInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>Rimu.DictVectors.StochasticStyle</code></a></li><li><a href="API.html#Rimu.DictVectors.StyleUnknown"><code>Rimu.DictVectors.StyleUnknown</code></a></li><li><a href="API.html#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a></li><li><a href="API.html#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a></li><li><a href="API.html#Rimu.DoubleLogSumUpdate"><code>Rimu.DoubleLogSumUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian"><code>Rimu.Hamiltonians.AbstractHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>Rimu.Hamiltonians.BoseHubbardMom1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>Rimu.Hamiltonians.BoseHubbardReal1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>Rimu.Hamiltonians.ExtendedHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>Rimu.Hamiltonians.HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>Rimu.Hamiltonians.HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>Rimu.Hamiltonians.HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>Rimu.Hamiltonians.HubbardRealSpace</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LOStructure"><code>Rimu.Hamiltonians.LOStructure</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>Rimu.Hamiltonians.LadderBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>Rimu.Hamiltonians.LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian"><code>Rimu.Hamiltonians.MatrixHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>Rimu.Hamiltonians.PeriodicBoundaries</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a></li><li><a href="API.html#Rimu.MultiScalar"><code>Rimu.MultiScalar</code></a></li><li><a href="API.html#Rimu.NoMemory"><code>Rimu.NoMemory</code></a></li><li><a href="API.html#Rimu.NoStats"><code>Rimu.NoStats</code></a></li><li><a href="API.html#Rimu.PostStepStrategy"><code>Rimu.PostStepStrategy</code></a></li><li><a href="API.html#Rimu.ProjectedEnergy"><code>Rimu.ProjectedEnergy</code></a></li><li><a href="API.html#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a></li><li><a href="API.html#Rimu.Projector"><code>Rimu.Projector</code></a></li><li><a href="API.html#Rimu.PurgeNegatives"><code>Rimu.PurgeNegatives</code></a></li><li><a href="API.html#Rimu.QMCState"><code>Rimu.QMCState</code></a></li><li><a href="API.html#Rimu.RMPI.MPIAllToAll"><code>Rimu.RMPI.MPIAllToAll</code></a></li><li><a href="API.html#Rimu.RMPI.MPIData"><code>Rimu.RMPI.MPIData</code></a></li><li><a href="API.html#Rimu.RMPI.MPIDataIterator"><code>Rimu.RMPI.MPIDataIterator</code></a></li><li><a href="API.html#Rimu.RMPI.MPINoWalkerExchange"><code>Rimu.RMPI.MPINoWalkerExchange</code></a></li><li><a href="API.html#Rimu.RMPI.MPIOneSided"><code>Rimu.RMPI.MPIOneSided</code></a></li><li><a href="API.html#Rimu.RMPI.MPIPointToPoint"><code>Rimu.RMPI.MPIPointToPoint</code></a></li><li><a href="API.html#Rimu.ReplicaState"><code>Rimu.ReplicaState</code></a></li><li><a href="API.html#Rimu.ReplicaStrategy"><code>Rimu.ReplicaStrategy</code></a></li><li><a href="API.html#Rimu.Report"><code>Rimu.Report</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a></li><li><a href="API.html#Rimu.ReportToFile"><code>Rimu.ReportToFile</code></a></li><li><a href="API.html#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a></li><li><a href="API.html#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a></li><li><a href="API.html#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a></li><li><a href="API.html#Rimu.SignCoherence"><code>Rimu.SignCoherence</code></a></li><li><a href="statstools.html#Rimu.StatsTools.BlockingResult"><code>Rimu.StatsTools.BlockingResult</code></a></li><li><a href="statstools.html#Rimu.StatsTools.RatioBlockingResult"><code>Rimu.StatsTools.RatioBlockingResult</code></a></li><li><a href="API.html#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a></li><li><a href="API.html#Rimu.TripleLogUpdate"><code>Rimu.TripleLogUpdate</code></a></li><li><a href="API.html#Rimu.WalkerLoneliness"><code>Rimu.WalkerLoneliness</code></a></li><li><a href="API.html#Base.:*-Tuple{Any, Rimu.RMPI.MPIData}"><code>Base.:*</code></a></li><li><a href="API.html#Base.length-Tuple{Rimu.RMPI.MPIData}"><code>Base.length</code></a></li><li><a href="API.html#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li><li><a href="statstools.html#Measurements.measurement-Tuple{Rimu.StatsTools.BlockingResult{var&quot;#s236&quot;} where var&quot;#s236&quot;&lt;:Real}"><code>Measurements.measurement</code></a></li><li><a href="API.html#OrderedCollections.freeze-Tuple{Any}"><code>OrderedCollections.freeze</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.chunk_bits"><code>Rimu.BitStringAddresses.chunk_bits</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.chunk_type"><code>Rimu.BitStringAddresses.chunk_type</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.find_mode"><code>Rimu.BitStringAddresses.find_mode</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.find_occupied_mode"><code>Rimu.BitStringAddresses.find_occupied_mode</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.is_occupied"><code>Rimu.BitStringAddresses.is_occupied</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.move_particle"><code>Rimu.BitStringAddresses.move_particle</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.near_uniform"><code>Rimu.BitStringAddresses.near_uniform</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.num_bits"><code>Rimu.BitStringAddresses.num_bits</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.num_chunks"><code>Rimu.BitStringAddresses.num_chunks</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.num_components"><code>Rimu.BitStringAddresses.num_components</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.num_modes"><code>Rimu.BitStringAddresses.num_modes</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.num_occupied_modes"><code>Rimu.BitStringAddresses.num_occupied_modes</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.num_particles"><code>Rimu.BitStringAddresses.num_particles</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.occupied_modes"><code>Rimu.BitStringAddresses.occupied_modes</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.onr"><code>Rimu.BitStringAddresses.onr</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.top_chunk_bits"><code>Rimu.BitStringAddresses.top_chunk_bits</code></a></li><li><a href="API.html#Rimu.Blocking.autoblock-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.autoblock</code></a></li><li><a href="API.html#Rimu.Blocking.autoblock-Tuple{Tuple}"><code>Rimu.Blocking.autoblock</code></a></li><li><a href="API.html#Rimu.Blocking.autocovariance-Tuple{Vector{T} where T, Int64}"><code>Rimu.Blocking.autocovariance</code></a></li><li><a href="API.html#Rimu.Blocking.blockAndMTest-Tuple{Vector{T} where T}"><code>Rimu.Blocking.blockAndMTest</code></a></li><li><a href="API.html#Rimu.Blocking.blocker-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>Rimu.Blocking.blocker</code></a></li><li><a href="API.html#Rimu.Blocking.blocking-Union{Tuple{T2}, Tuple{T1}, Tuple{Vector{T1}, Vector{T2}}} where {T1, T2}"><code>Rimu.Blocking.blocking</code></a></li><li><a href="API.html#Rimu.Blocking.blocking-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>Rimu.Blocking.blocking</code></a></li><li><a href="API.html#Rimu.Blocking.blocking_old-Tuple{Vector{T} where T}"><code>Rimu.Blocking.blocking_old</code></a></li><li><a href="API.html#Rimu.Blocking.combination_division-Tuple{Vector{T} where T, Vector{T} where T}"><code>Rimu.Blocking.combination_division</code></a></li><li><a href="API.html#Rimu.Blocking.covariance-Tuple{Vector{T} where T, Vector{T} where T}"><code>Rimu.Blocking.covariance</code></a></li><li><a href="API.html#Rimu.Blocking.gW-Tuple{AbstractArray, AbstractArray, Any}"><code>Rimu.Blocking.gW</code></a></li><li><a href="API.html#Rimu.Blocking.growthWitness-Tuple{AbstractArray, AbstractArray, Any}"><code>Rimu.Blocking.growthWitness</code></a></li><li><a href="API.html#Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.mtest</code></a></li><li><a href="API.html#Rimu.Blocking.se-Tuple{Vector{T} where T}"><code>Rimu.Blocking.se</code></a></li><li><a href="API.html#Rimu.Blocking.smoothen-Tuple{AbstractVector{T} where T, Any}"><code>Rimu.Blocking.smoothen</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple"><code>Rimu.ConsistentRNG.cRand</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRandn-Tuple"><code>Rimu.ConsistentRNG.cRandn</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.check_crng_independence-Tuple{Any}"><code>Rimu.ConsistentRNG.check_crng_independence</code></a></li><li><a href="API.html#Rimu.ConsistentRNG.check_crng_independence-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.ConsistentRNG.check_crng_independence</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.newChildRNG"><code>Rimu.ConsistentRNG.newChildRNG</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Vector{T} where T}"><code>Rimu.ConsistentRNG.seedCRNG!</code></a></li><li><a href="API.html#Rimu.ConsistentRNG.sync_cRandn-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.ConsistentRNG.sync_cRandn</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.sync_cRandn-Tuple{Any}"><code>Rimu.ConsistentRNG.sync_cRandn</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}"><code>Rimu.ConsistentRNG.trng</code></a></li><li><a href="API.html#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K"><code>Rimu.DictVectors.add!</code></a></li><li><a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Rimu.DictVectors.default_style</code></a></li><li><a href="API.html#Rimu.DictVectors.deposit!-NTuple{4, Any}"><code>Rimu.DictVectors.deposit!</code></a></li><li><a href="API.html#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V"><code>Rimu.DictVectors.deposit!</code></a></li><li><a href="API.html#Rimu.DictVectors.localpart-Tuple{Any}"><code>Rimu.DictVectors.localpart</code></a></li><li><a href="API.html#Rimu.DictVectors.storage"><code>Rimu.DictVectors.storage</code></a></li><li><a href="API.html#Rimu.DictVectors.value"><code>Rimu.DictVectors.value</code></a></li><li><a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.DictVectors.walkernumber</code></a></li><li><a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>Rimu.DictVectors.walkernumber</code></a></li><li><a href="API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.diagonal_element"><code>Rimu.Hamiltonians.diagonal_element</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>Rimu.Hamiltonians.dimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.get_offdiagonal"><code>Rimu.Hamiltonians.get_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>Rimu.Hamiltonians.neighbour_site</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>Rimu.Hamiltonians.num_neighbours</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_offdiagonals"><code>Rimu.Hamiltonians.num_offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.offdiagonals"><code>Rimu.Hamiltonians.offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.random_offdiagonal"><code>Rimu.Hamiltonians.random_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.starting_address"><code>Rimu.Hamiltonians.starting_address</code></a></li><li><a href="API.html#Rimu.RMPI.copy_to_local-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.RMPI.copy_to_local</code></a></li><li><a href="API.html#Rimu.RMPI.copy_to_local!-Tuple{Any, Rimu.RMPI.MPIData}"><code>Rimu.RMPI.copy_to_local!</code></a></li><li><a href="API.html#Rimu.RMPI.free-Tuple{Rimu.RMPI.MPIOneSided}"><code>Rimu.RMPI.free</code></a></li><li><a href="API.html#Rimu.RMPI.is_mpi_root"><code>Rimu.RMPI.is_mpi_root</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_all_to_all"><code>Rimu.RMPI.mpi_all_to_all</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_allprintln-Tuple"><code>Rimu.RMPI.mpi_allprintln</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_barrier"><code>Rimu.RMPI.mpi_barrier</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_combine_walkers!-Tuple{Rimu.RMPI.MPIData, AbstractDVec}"><code>Rimu.RMPI.mpi_combine_walkers!</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_comm-Tuple{}"><code>Rimu.RMPI.mpi_comm</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_communicate_buffers!-Tuple{Any, Any, Any}"><code>Rimu.RMPI.mpi_communicate_buffers!</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_no_exchange"><code>Rimu.RMPI.mpi_no_exchange</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_one_sided"><code>Rimu.RMPI.mpi_one_sided</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_point_to_point"><code>Rimu.RMPI.mpi_point_to_point</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_rank"><code>Rimu.RMPI.mpi_rank</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_seed_CRNGs!"><code>Rimu.RMPI.mpi_seed_CRNGs!</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_size"><code>Rimu.RMPI.mpi_size</code></a></li><li><a href="API.html#Rimu.RMPI.mpi_synchronize!-Tuple{Rimu.RMPI.MPIData}"><code>Rimu.RMPI.mpi_synchronize!</code></a></li><li><a href="API.html#Rimu.RMPI.next_mpiID"><code>Rimu.RMPI.next_mpiID</code></a></li><li><a href="API.html#Rimu.RMPI.put-Union{Tuple{T}, Tuple{Vector{T}, Any, Any, Rimu.RMPI.MPIOneSided{T}}} where T"><code>Rimu.RMPI.put</code></a></li><li><a href="API.html#Rimu.RMPI.receive!-Union{Tuple{P}, Tuple{Any, Rimu.RMPI.MPIPointToPoint{P, N} where N, Any}} where P"><code>Rimu.RMPI.receive!</code></a></li><li><a href="API.html#Rimu.RMPI.recvbuff-Tuple{Rimu.RMPI.MPIPointToPoint}"><code>Rimu.RMPI.recvbuff</code></a></li><li><a href="API.html#Rimu.RMPI.send!-Union{Tuple{Rimu.RMPI.MPIPointToPoint{var&quot;#s487&quot;, N} where var&quot;#s487&quot;}, Tuple{N}} where N"><code>Rimu.RMPI.send!</code></a></li><li><a href="API.html#Rimu.RMPI.sendbuff-Tuple{Rimu.RMPI.MPIPointToPoint, Any}"><code>Rimu.RMPI.sendbuff</code></a></li><li><a href="API.html#Rimu.RMPI.sort_and_count!"><code>Rimu.RMPI.sort_and_count!</code></a></li><li><a href="API.html#Rimu.RMPI.targetrank-Tuple{Union{Integer, AbstractFockAddress}, Any}"><code>Rimu.RMPI.targetrank</code></a></li><li><a href="statstools.html#Rimu.StatsTools.autocovariance-Tuple{AbstractVector{T} where T, Int64}"><code>Rimu.StatsTools.autocovariance</code></a></li><li><a href="statstools.html#Rimu.StatsTools.blocker-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>Rimu.StatsTools.blocker</code></a></li><li><a href="statstools.html#Rimu.StatsTools.blocking_analysis-Tuple{AbstractVector{T} where T}"><code>Rimu.StatsTools.blocking_analysis</code></a></li><li><a href="statstools.html#Rimu.StatsTools.blocks_with_m-Tuple{Any}"><code>Rimu.StatsTools.blocks_with_m</code></a></li><li><a href="statstools.html#Rimu.StatsTools.errs-Tuple"><code>Rimu.StatsTools.errs</code></a></li><li><a href="statstools.html#Rimu.StatsTools.growth_estimator-NTuple{4, Any}"><code>Rimu.StatsTools.growth_estimator</code></a></li><li><a href="statstools.html#Rimu.StatsTools.growth_witness-Tuple{AbstractArray, AbstractArray, Any}"><code>Rimu.StatsTools.growth_witness</code></a></li><li><a href="statstools.html#Rimu.StatsTools.mean_and_se-Tuple{Rimu.StatsTools.BlockingResult}"><code>Rimu.StatsTools.mean_and_se</code></a></li><li><a href="statstools.html#Rimu.StatsTools.med_and_errs-Tuple{Any}"><code>Rimu.StatsTools.med_and_errs</code></a></li><li><a href="statstools.html#Rimu.StatsTools.mixed_estimator-NTuple{5, Any}"><code>Rimu.StatsTools.mixed_estimator</code></a></li><li><a href="statstools.html#Rimu.StatsTools.mtest-Tuple{AbstractVector{T} where T}"><code>Rimu.StatsTools.mtest</code></a></li><li><a href="statstools.html#Rimu.StatsTools.particles-Tuple{Any, Any}"><code>Rimu.StatsTools.particles</code></a></li><li><a href="statstools.html#Rimu.StatsTools.particles-Tuple{Any, Distributions.Distribution}"><code>Rimu.StatsTools.particles</code></a></li><li><a href="statstools.html#Rimu.StatsTools.projected_energy-Tuple{DataFrames.DataFrame}"><code>Rimu.StatsTools.projected_energy</code></a></li><li><a href="statstools.html#Rimu.StatsTools.pseudo_cov-Tuple{Any, Any}"><code>Rimu.StatsTools.pseudo_cov</code></a></li><li><a href="statstools.html#Rimu.StatsTools.ratio_estimators-Tuple{Any, Any}"><code>Rimu.StatsTools.ratio_estimators</code></a></li><li><a href="statstools.html#Rimu.StatsTools.ratio_of_means-Tuple{Any, Any}"><code>Rimu.StatsTools.ratio_of_means</code></a></li><li><a href="statstools.html#Rimu.StatsTools.ratio_with_errs-Tuple{Rimu.StatsTools.RatioBlockingResult}"><code>Rimu.StatsTools.ratio_with_errs</code></a></li><li><a href="statstools.html#Rimu.StatsTools.replica_fidelity-Tuple{DataFrames.DataFrame}"><code>Rimu.StatsTools.replica_fidelity</code></a></li><li><a href="statstools.html#Rimu.StatsTools.shift_estimator-Tuple{DataFrames.DataFrame}"><code>Rimu.StatsTools.shift_estimator</code></a></li><li><a href="statstools.html#Rimu.StatsTools.smoothen-Tuple{AbstractVector{T} where T, Integer}"><code>Rimu.StatsTools.smoothen</code></a></li><li><a href="statstools.html#Rimu.StatsTools.to_measurement-Tuple{MonteCarloMeasurements.Particles}"><code>Rimu.StatsTools.to_measurement</code></a></li><li><a href="statstools.html#Rimu.StatsTools.val-Tuple{Any}"><code>Rimu.StatsTools.val</code></a></li><li><a href="statstools.html#Rimu.StatsTools.val_and_errs-Tuple{Any}"><code>Rimu.StatsTools.val_and_errs</code></a></li><li><a href="statstools.html#Rimu.StatsTools.w_exp-Tuple{Any, Any, Any}"><code>Rimu.StatsTools.w_exp</code></a></li><li><a href="statstools.html#Rimu.StatsTools.w_lin-Tuple{Any, Any, Any}"><code>Rimu.StatsTools.w_lin</code></a></li><li><a href="statstools.html#Rimu.StatsTools.x_by_y_linear-NTuple{5, Any}"><code>Rimu.StatsTools.x_by_y_linear</code></a></li><li><a href="API.html#Rimu._n_walkers-Tuple{Any, Any}"><code>Rimu._n_walkers</code></a></li><li><a href="API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T"><code>Rimu.advance!</code></a></li><li><a href="API.html#Rimu.all_overlaps-Union{Tuple{N}, Tuple{Tuple, Tuple{Vararg{AbstractDVec, N}}}} where N"><code>Rimu.all_overlaps</code></a></li><li><a href="API.html#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.apply_memory_noise!</code></a></li><li><a href="API.html#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.fciqmc_col!</code></a></li><li><a href="API.html#Rimu.fciqmc_step!"><code>Rimu.fciqmc_step!</code></a></li><li><a href="API.html#Rimu.finalize_report!-Tuple{ReportingStrategy, Any}"><code>Rimu.finalize_report!</code></a></li><li><a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>Rimu.lomc!</code></a></li><li><a href="API.html#Rimu.post_step"><code>Rimu.post_step</code></a></li><li><a href="API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy}"><code>Rimu.refine_r_strat</code></a></li><li><a href="API.html#Rimu.replica_stats"><code>Rimu.replica_stats</code></a></li><li><a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.report!-Tuple{Rimu.Report, Union{AbstractString, Symbol}, Any}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>Rimu.report_after_step</code></a></li><li><a href="API.html#Rimu.sort_into_targets!-Tuple{Any, Any, Any}"><code>Rimu.sort_into_targets!</code></a></li><li><a href="API.html#Rimu.step_stats-Tuple{StochasticStyle}"><code>Rimu.step_stats</code></a></li><li><a href="API.html#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s488&quot;, false} where var&quot;#s488&quot;, Any, Any, Any, Any}"><code>Rimu.threshold_projected_deposit!</code></a></li><li><a href="API.html#Rimu.update_dvec!-Tuple{StochasticStyle, Any}"><code>Rimu.update_dvec!</code></a></li><li><a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.update_dτ</code></a></li><li><a href="API.html#Rimu.update_shift"><code>Rimu.update_shift</code></a></li><li><a href="statstools.html#Statistics.cov-Tuple{Rimu.StatsTools.BlockingResult{var&quot;#s236&quot;} where var&quot;#s236&quot;&lt;:Complex}"><code>Statistics.cov</code></a></li><li><a href="API.html#Rimu.RMPI.@mpi_root-Tuple"><code>Rimu.RMPI.@mpi_root</code></a></li><li><a href="API.html#Rimu.RMPI.@swap!-Tuple{Any, Any, Any}"><code>Rimu.RMPI.@swap!</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="testing.html">« Code testing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Tuesday 7 September 2021 11:50">Tuesday 7 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
