<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hamiltonians · Rimu.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Rimu.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="generated/BHM-example.html">1D Bose-Hubbard Model</a></li><li><a class="tocitem" href="generated/BHM-example-mpi.html">Rimu with MPI</a></li><li><a class="tocitem" href="generated/G2-example.html">Calculating observables</a></li><li><a class="tocitem" href="generated/exact-example.html">Exact diagonalisation</a></li></ul></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="statstools.html">StatsTools</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li class="is-active"><a class="tocitem" href="hamiltonians.html">Hamiltonians</a><ul class="internal"><li><a class="tocitem" href="#Usage-with-FCIQMC-and-exact-diagonalisation"><span>Usage with FCIQMC and exact diagonalisation</span></a></li><li><a class="tocitem" href="#Model-Hamiltonians"><span>Model Hamiltonians</span></a></li><li><a class="tocitem" href="#Hamiltonian-wrappers"><span>Hamiltonian wrappers</span></a></li><li><a class="tocitem" href="#Observables"><span>Observables</span></a></li><li><a class="tocitem" href="#Hamiltonians-interface"><span>Hamiltonians interface</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="dictvectors.html">Dict vectors</a></li><li><a class="tocitem" href="addresses.html">BitString addresses</a></li><li><a class="tocitem" href="stochasticstyles.html">Stochastic styles</a></li><li><a class="tocitem" href="RMPI.html">RMPI</a></li><li><a class="tocitem" href="rimuio.html">I/O</a></li><li><a class="tocitem" href="randomnumbers.html">Random numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li><a class="tocitem" href="API.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer documentation</a></li><li class="is-active"><a href="hamiltonians.html">Hamiltonians</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hamiltonians.html">Hamiltonians</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/develop/docs/src/hamiltonians.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-Hamiltonians"><a class="docs-heading-anchor" href="#Module-Hamiltonians">Module <code>Hamiltonians</code></a><a id="Module-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Hamiltonians" title="Permalink"></a></h1><p>This module contains definitions of Hamiltonians, in particular specific physical models of interest. These are organised by means of an interface around the abstract type <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>, in the spirit of the <code>AbstractArray</code> interface as discussed in the <a href="https://docs.julialang.org/en/v1/manual/interfaces/">Julia Documentation</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians" href="#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Hamiltonians</code></pre><p>This module defines Hamiltonian types and functions for working with Hamiltonians.</p><p><strong><a href="#Model-Hamiltonians">Exported concrete Hamiltonian types</a></strong></p><p>Real space Hubbard models</p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>BoseHubbardReal1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul><p>Momentum space Hubbard models</p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></li></ul><p>Other</p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian"><code>MatrixHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Transcorrelated1D"><code>Transcorrelated1D</code></a></li></ul><p><strong><a href="#Hamiltonian-wrappers">Wrappers</a></strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.GutzwillerSampling"><code>GutzwillerSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.GuidingVectorSampling"><code>GuidingVectorSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>ParitySymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.TimeReversalSymmetry"><code>TimeReversalSymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Stoquastic"><code>Stoquastic</code></a></li></ul><p><strong><a href="#Observables">Observables</a></strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2MomCorrelator"><code>G2MomCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.DensityMatrixDiagonal"><code>DensityMatrixDiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Momentum"><code>Momentum</code></a></li></ul><p><strong><a href="#Hamiltonians-interface">Interface for working with Hamiltonians</a></strong></p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>: defined in the module <a href="interfaces.html#Rimu.Interfaces"><code>Interfaces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/Hamiltonians.jl#L1-L40">source</a></section></article><h2 id="Usage-with-FCIQMC-and-exact-diagonalisation"><a class="docs-heading-anchor" href="#Usage-with-FCIQMC-and-exact-diagonalisation">Usage with FCIQMC and exact diagonalisation</a><a id="Usage-with-FCIQMC-and-exact-diagonalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-with-FCIQMC-and-exact-diagonalisation" title="Permalink"></a></h2><p>In order to define a specific model Hamiltonian with relevant parameters for the model, instantiate the model like this in the input file:</p><pre><code class="language-julia-repl hljs">hubb = HubbardReal1D(BoseFS((1,2,0,3)); u=1.0, t=1.0)</code></pre><p>The Hamiltonian <code>hubb</code> is now ready to be used for FCIQMC in <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> and for exact diagonalisation with <a href="https://github.com/Jutho/KrylovKit.jl"><code>KrylovKit.jl</code></a> directly, or after transforming into a sparse matrix first with</p><pre><code class="language-julia-repl hljs">using SparseArrays
sh = sparse(hubb)</code></pre><p>or into a full matrix with</p><pre><code class="language-julia-repl hljs">using LinearAlgebra
fh = Matrix(hubb)</code></pre><p>This functionality relies on</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.BasisSetRep" href="#Rimu.Hamiltonians.BasisSetRep"><code>Rimu.Hamiltonians.BasisSetRep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisSetRep(
    h::AbstractHamiltonian, addr=starting_address(h);
    sizelim=10^6, nnzs, cutoff, filter, sort, kwargs...
)</code></pre><p>Eagerly construct the basis set representation of the operator <code>h</code> with all addresses reachable from <code>addr</code>.</p><p>An <code>ArgumentError</code> is thrown if <code>dimension(h) &gt; sizelim</code> in order to prevent memory overflow. Set <code>sizelim = Inf</code> in order to disable this behaviour.</p><p>Providing the number <code>nnzs</code> of expected calculated matrix elements may improve performance. The default estimates for <code>nnzs</code> is <code>dimension(ham)</code>.</p><p>Providing an energy cutoff will skip the columns and rows with diagonal elements greater than <code>cutoff</code>. Alternatively, an arbitrary <code>filter</code> function can be used instead. These are not enabled by default.</p><p>Setting <code>sort</code> to <code>true</code> will sort the matrix rows and columns. This is useful when the order of the columns matters, e.g. when comparing matrices. Any additional keyword arguments are passed on to <code>Base.sortperm</code>.</p><p><strong>Fields</strong></p><ul><li><code>sm</code>: sparse matrix representing <code>h</code> in the basis <code>basis</code></li><li><code>basis</code>: vector of addresses</li><li><code>h</code>: the Hamiltonian</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = HubbardReal1D(BoseFS((1,0,0)));

julia&gt; bsr = BasisSetRep(h)
BasisSetRep(HubbardReal1D(BoseFS{1,3}((1, 0, 0)); u=1.0, t=1.0)) with dimension 3 and 9 stored entries:3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:
  0.0  -1.0  -1.0
 -1.0   0.0  -1.0
 -1.0  -1.0   0.0</code></pre><pre><code class="language-julia-repl hljs"> julia&gt; using LinearAlgebra; eigvals(Matrix(bsr))
 3-element Vector{Float64}:
  -2.0
   1.0
   1.0

julia&gt; ev = eigvecs(Matrix(bsr))[:,1] # ground state eigenvector
3-element Vector{Float64}:
 -0.5773502691896
 -0.5773502691896
 -0.5773502691896

julia&gt; DVec(zip(bsr.basis,ev)) # ground state as DVec
DVec{BoseFS{1, 3, BitString{3, 1, UInt8}},Float64} with 3 entries, style = IsDeterministic{Float64}()
  BoseFS{1,3}((0, 0, 1)) =&gt; -0.5773502691896
  BoseFS{1,3}((0, 1, 0)) =&gt; -0.5773502691896
  BoseFS{1,3}((1, 0, 0)) =&gt; -0.5773502691896</code></pre><p>Has methods for <a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>dimension</code></a>, <a href="hamiltonians.html#SparseArrays.sparse"><code>sparse</code></a>, <a href="hamiltonians.html#Base.Matrix"><code>Matrix</code></a>, <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L298-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse(h::AbstractHamiltonian, addr=starting_address(h); kwargs...)
sparse(bsr::BasisSetRep)</code></pre><p>Return a sparse matrix representation of <code>h</code> or <code>bsr</code>. <code>kwargs</code> are passed to <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p><p>See <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L547-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matrix(h::AbstractHamiltonian, addr=starting_address(h); sizelim=10^4, kwargs...)
Matrix(bsr::BasisSetRep)</code></pre><p>Return a dense matrix representation of <code>h</code> or <code>bsr</code>. <code>kwargs</code> are passed to <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p><p>See <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L561-L569">source</a></section></article><p>If only the basis is required and not the matrix representation it is more efficient to use</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.build_basis" href="#Rimu.Hamiltonians.build_basis"><code>Rimu.Hamiltonians.build_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basis = build_basis(
    ham, address=starting_address(ham); 
    cutoff=nothing, filter=nothing, sort=false, max_size=Inf, kwargs...
)</code></pre><p>Get all basis element of a linear operator <code>ham</code> that are reachable (via  non-zero matrix elements) from the address <code>address</code>, returned as a vector.  Does not return the matrix, for that purpose use <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p><p>Providing an energy cutoff will skip addresses with diagonal elements greater than <code>cutoff</code>. Alternatively, an arbitrary <code>filter</code> function can be used instead.  A maximum basis size <code>max_size</code> can be set which will throw an error if the expected dimension of <code>ham</code> is larger than <code>max_size</code>. This may be useful when memory may be a concern.  These options are disabled by default.</p><p>Setting <code>sort</code> to <code>true</code> will sort the basis. Any additional keyword arguments are passed on to <code>Base.sort!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L240-L258">source</a></section></article><h2 id="Model-Hamiltonians"><a class="docs-heading-anchor" href="#Model-Hamiltonians">Model Hamiltonians</a><a id="Model-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Hamiltonians" title="Permalink"></a></h2><p>Here is a list of fully implemented model Hamiltonians. There are several variants of the Hubbard model in real and momentum space, as well as some other models.</p><h3 id="Real-space-Hubbard-models"><a class="docs-heading-anchor" href="#Real-space-Hubbard-models">Real space Hubbard models</a><a id="Real-space-Hubbard-models-1"></a><a class="docs-heading-anchor-permalink" href="#Real-space-Hubbard-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardReal1D" href="#Rimu.Hamiltonians.HubbardReal1D"><code>Rimu.Hamiltonians.HubbardReal1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardReal1D(address; u=1.0, t=1.0)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in real space.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \frac{u}{2}\sum_i n_i (n_i-1)\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardReal1D.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.BoseHubbardReal1D2C" href="#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>Rimu.Hamiltonians.BoseHubbardReal1D2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseHubbardReal1D2C(address::BoseFS2C; ua=1.0, ub=1.0, ta=1.0, tb=1.0, v=1.0)</code></pre><p>Implements a two-component one-dimensional Bose Hubbard chain in real space.</p><p class="math-container">\[\hat{H} = \hat{H}_a + \hat{H}_b + V\sum_{i} n_{a_i}n_{b_i}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>ua</code>: the on-site interaction parameter parameter for Hamiltonian a.</li><li><code>ub</code>: the on-site interaction parameter parameter for Hamiltonian b.</li><li><code>ta</code>: the hopping strength for Hamiltonian a.</li><li><code>tb</code>: the hopping strength for Hamiltonian b.</li><li><code>v</code>: the inter-species interaction parameter V.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/BoseHubbardReal1D2C.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardReal1DEP" href="#Rimu.Hamiltonians.HubbardReal1DEP"><code>Rimu.Hamiltonians.HubbardReal1DEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardReal1DEP(address; u=1.0, t=1.0, v_ho=1.0)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in real space with external potential.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \sum_i ϵ_i n_i
+ \frac{u}{2}\sum_i n_i (n_i-1)\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li><li><code>v_ho</code>: strength of the external harmonic oscillator potential <span>$ϵ_i = v_{ho} i^2$</span>.</li></ul><p>The first index is <code>i=0</code> and the maximum of the potential occurs in the centre of the lattice.</p><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardReal1DEP.jl#L21-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardRealSpace" href="#Rimu.Hamiltonians.HubbardRealSpace"><code>Rimu.Hamiltonians.HubbardRealSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardRealSpace(address; geometry=PeriodicBoundaries(M,), t=ones(C), u=ones(C, C), v=zeros(C, D))</code></pre><p>Hubbard model in real space. Supports single or multi-component Fock state addresses (with <code>C</code> components) and various (rectangular) lattice geometries in <code>D</code> dimensions.</p><p class="math-container">\[  \hat{H} = -\sum_{\langle i,j\rangle,σ} t_σ a^†_{iσ} a_{jσ} +
  \frac{1}{2}\sum_{i,σ} u_{σσ} n_{iσ} (n_{iσ} - 1) +
  \frac{1}{2}\sum_{i,σ≠τ}u_{στ} n_{iσ} n_{iτ}\]</p><p>If <code>v</code> is nonzero then this calculates <span>$\hat{H} + \hat{V}$</span> by adding the harmonic trapping potential</p><p class="math-container">\[    \hat{V} = \sum_{i,σ,d} v_{σd} x_{di}^2 n_{iσ}\]</p><p>where <span>$x_{di}$</span> is the distance of site <span>$i$</span> from the centre of the trap along dimension <span>$d$</span>.</p><p><strong>Address types</strong></p><ul><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>: Single-component Bose-Hubbard model.</li><li><a href="addresses.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>: Single-component Fermi-Hubbard model.</li><li><a href="addresses.html#Rimu.BitStringAddresses.CompositeFS"><code>CompositeFS</code></a>: For multi-component models.</li></ul><p>Note that a single component of fermions cannot interact with itself. A warning is produced if <code>address</code>is incompatible with the interaction parameters <code>u</code>.</p><p><strong>Geometries</strong></p><p>Implemented <a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a>s for keyword <code>geometry</code></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul><p>Default is <code>geometry=PeriodicBoundaries(M,)</code>, i.e. a one-dimensional lattice with the number of sites <code>M</code> inferred from the number of modes in <code>address</code>.</p><p><strong>Other parameters</strong></p><ul><li><code>t</code>: the hopping strengths. Must be a vector of length <code>C</code>. The <code>i</code>-th element of the vector corresponds to the hopping strength of the <code>i</code>-th component.</li><li><code>u</code>: the on-site interaction parameters. Must be a symmetric matrix. <code>u[i, j]</code> corresponds to the interaction between the <code>i</code>-th and <code>j</code>-th component. <code>u[i, i]</code> corresponds to the interaction of a component with itself. Note that <code>u[i,i]</code> must be zero for fermionic components.</li><li><code>v</code>: the trap potential strengths. Must be a matrix of size <code>C × D</code>. <code>v[i,j]</code> is the strength of the trap for component <code>i</code> in the <code>j</code>th dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardRealSpace.jl#L111-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.ExtendedHubbardReal1D" href="#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>Rimu.Hamiltonians.ExtendedHubbardReal1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExtendedHubbardReal1D(address; u=1.0, v=1.0, t=1.0)</code></pre><p>Implements the extended Hubbard model on a one-dimensional chain in real space.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \frac{u}{2}\sum_i n_i (n_i-1) + v \sum_{\langle i,j\rangle} n_i n_j\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address.</li><li><code>u</code>: on-site interaction parameter</li><li><code>v</code>: the next-neighbor interaction</li><li><code>t</code>: the hopping strength</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/ExtendedHubbardReal1D.jl#L1-L17">source</a></section></article><h3 id="Momentum-space-Hubbard-models"><a class="docs-heading-anchor" href="#Momentum-space-Hubbard-models">Momentum space Hubbard models</a><a id="Momentum-space-Hubbard-models-1"></a><a class="docs-heading-anchor-permalink" href="#Momentum-space-Hubbard-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardMom1D" href="#Rimu.Hamiltonians.HubbardMom1D"><code>Rimu.Hamiltonians.HubbardMom1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardMom1D(address; u=1.0, t=1.0, dispersion=hubbard_dispersion)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space.</p><p class="math-container">\[\hat{H} =  \sum_{k} ϵ_k n_k + \frac{u}{M}\sum_{kpqr} a^†_{r} a^†_{q} a_p a_k δ_{r+q,p+k}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li><li><code>dispersion</code>: defines <span>$ϵ_k =$</span><code>t*dispersion(k)</code><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>hubbard_dispersion</code></a>: <span>$ϵ_k = -2t \cos(k)$</span></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>continuum_dispersion</code></a>: <span>$ϵ_k = tk^2$</span></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardMom1D.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.BoseHubbardMom1D2C" href="#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>Rimu.Hamiltonians.BoseHubbardMom1D2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseHubbardMom1D2C(add::BoseFS2C; ua=1.0, ub=1.0, ta=1.0, tb=1.0, v=1.0, kwargs...)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space with a two-component Bose gas.</p><p class="math-container">\[\hat{H} = \hat{H}_a + \hat{H}_b + \frac{V}{M}\sum_{kpqr} b^†_{r} a^†_{q} b_p a_k δ_{r+q,p+k}\]</p><p><strong>Arguments</strong></p><ul><li><code>add</code>: the starting address.</li><li><code>ua</code>: the <code>u</code> parameter for Hamiltonian a.</li><li><code>ub</code>: the <code>u</code> parameter for Hamiltonian b.</li><li><code>ta</code>: the <code>t</code> parameter for Hamiltonian a.</li><li><code>tb</code>: the <code>t</code> parameter for Hamiltonian b.</li><li><code>v</code>: the inter-species interaction parameter V.</li></ul><p>Further keyword arguments are passed on to the constructor of <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>.</p><p><strong>See also</strong></p><ul><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS2C"><code>BoseFS2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>BoseHubbardReal1D2C</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/BoseHubbardMom1D2C.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardMom1DEP" href="#Rimu.Hamiltonians.HubbardMom1DEP"><code>Rimu.Hamiltonians.HubbardMom1DEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardMom1DEP(address; u=1.0, t=1.0, v_ho=1.0, dispersion=hubbard_dispersion)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space with harmonic external potential.</p><p class="math-container">\[Ĥ = \sum_{k} ϵ_k n_k + \frac{u}{M}\sum_{kpqr} a^†_{r} a^†_{q} a_p a_k δ_{r+q,p+k}
            + V̂_\mathrm{ho} ,\]</p><p>where</p><p class="math-container">\[\begin{aligned}
V̂_\mathrm{ho} &amp; = \frac{1}{M} \sum_{p,q}  \mathrm{DFT}[V_{ext}]_{p-q} \,
                    a^†_{p} a_q ,\\
V_\mathrm{ext}(x) &amp;= v_\mathrm{ho} \,x^2 ,
\end{aligned}\]</p><p>is an external harmonic potential in momentum space, <span>$\mathrm{DFT}[…]_k$</span> is a discrete Fourier transform performed by <code>fft()[k%M + 1]</code>, and <code>M == num_modes(address)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li><li><code>dispersion</code>: defines <span>$ϵ_k =$</span><code>t*dispersion(k)</code><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>hubbard_dispersion</code></a>: <span>$ϵ_k = -2t \cos(k)$</span></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>continuum_dispersion</code></a>: <span>$ϵ_k = tk^2$</span></li></ul></li><li><code>v_ho</code>: strength of the external harmonic oscillator potential <span>$v_\mathrm{ho}$</span>.</li></ul><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.Transcorrelated1D"><code>Transcorrelated1D</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians"><code>Hamiltonians</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardMom1DEP.jl#L33-L67">source</a></section></article><h3 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.MatrixHamiltonian" href="#Rimu.Hamiltonians.MatrixHamiltonian"><code>Rimu.Hamiltonians.MatrixHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixHamiltonian(
    mat::AbstractMatrix{T};
    starting_address::Int = starting_address(mat)
) &lt;: AbstractHamiltonian{T}</code></pre><p>Wrap an abstract matrix <code>mat</code> as an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> object for use with regular <code>Vector</code>s indexed by integers. Works with stochastic methods of <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!()</code></a>. Optionally, a <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a> can be provided.</p><p>Specialised methods are implemented for sparse matrices of type <code>AbstractSparseMatrixCSC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/MatrixHamiltonian.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.Transcorrelated1D" href="#Rimu.Hamiltonians.Transcorrelated1D"><code>Rimu.Hamiltonians.Transcorrelated1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Transcorrelated1D(address; t=1.0, v=1.0, v_ho=0.0, cutoff=1, three_body_term=true)</code></pre><p>Implements a transcorrelated Hamiltonian for contact interactions in one dimensional momentum space from <a href="http://arxiv.org/abs/1806.11268">Jeszenski <em>et al.</em> (2018)</a>. Currently limited to two component fermionic addresses.</p><p class="math-container">\[\begin{aligned}

\tilde{H} &amp;= t \sum_{kσ}k^2 n_{k,σ} \\
    &amp;\quad + \sum_{pqkσσ&#39;} T_{pqk} a^†_{p-k,σ} a^†_{q+k,σ&#39;} a_{q,σ&#39;} a_{p,σ} \\
    &amp;\quad + \sum_{pqskk&#39;σσ&#39;} Q_{kk&#39;}a^†_{p-k,σ} a^†_{q+k,σ} a^†_{s+k-k&#39;,σ&#39;}
                                       a_{s,σ&#39;} a_{q,σ} a_{p,σ} \\
    &amp;\quad + V̂_\mathrm{ho}
\end{aligned}\]</p><p>where</p><p class="math-container">\[\begin{aligned}
\tilde{u}(k) &amp;= \begin{cases} -\frac{2}{k^2} &amp;\mathrm{if\ } |k| ≥ k_c\\
0 &amp; \mathrm{otherwise}
\end{cases}
\\

T_{pqk} &amp;= \frac{v}{M} + \frac{2v}{M}\left[k^2\tilde{u}(k)
          - (p - q)k\tilde{u}(k)\right] + \frac{2v^2}{t}W(k)\\
W(k) &amp;= \frac{1}{M^2}\sum_{q} (k - q)q\, \tilde{u}(q)\,\tilde{u}(k - q) \\
Q_{kl} &amp;= -\frac{v^2}{t M^2}k \tilde{u}(k)\,l\tilde{u}(l),
\end{aligned}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: The starting address, defines number of particles and sites.</li><li><code>v</code>: The interaction parameter.</li><li><code>t</code>: The kinetic energy prefactor.</li><li><code>v_ho</code>: Strength of the external harmonic oscillator potential <span>$V̂_\mathrm{ho}$</span>. See <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a>.</li><li><code>cutoff</code> controls <span>$k_c$</span> in equations above. Note: skipping generating off-diagonal elements below the cutoff is not implemented - zero-valued elements are returned instead.</li><li><code>three_body_term</code>: If set to false, generating three body excitations is skipped. Note: when disabling three body terms, cutoff should be set to a higher value for best results.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/Transcorrelated1D.jl#L2-L54">source</a></section></article><h3 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.rayleigh_quotient" href="#Rimu.Hamiltonians.rayleigh_quotient"><code>Rimu.Hamiltonians.rayleigh_quotient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rayleigh_quotient(H, v)</code></pre><p class="math-container">\[\frac{⟨ v | H | v ⟩}{⟨ v|v ⟩}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L86-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.momentum" href="#Rimu.Hamiltonians.momentum"><code>Rimu.Hamiltonians.momentum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">momentum(ham::AbstractHamiltonian)</code></pre><p>Momentum as a linear operator in Fock space. Pass a Hamiltonian <code>ham</code> in order to convey information about the Fock basis.</p><p>Note: <code>momentum</code> is currently only defined on <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; add = BoseFS((1, 0, 2, 1, 2, 1, 1, 3));


julia&gt; ham = HubbardMom1D(add; u = 2.0, t = 1.0);


julia&gt; mom = momentum(ham);


julia&gt; diagonal_element(mom, add) # calculate the momentum of a single configuration
-1.5707963267948966

julia&gt; v = DVec(add =&gt; 10; capacity=1000);


julia&gt; rayleigh_quotient(mom, v) # momentum expectation value for state vector `v`
-1.5707963267948966</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L114-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.hubbard_dispersion" href="#Rimu.Hamiltonians.hubbard_dispersion"><code>Rimu.Hamiltonians.hubbard_dispersion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hubbard_dispersion(k)</code></pre><p>Dispersion relation for <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>. Returns <code>-2cos(k)</code>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>continuum_dispersion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardMom1D.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.continuum_dispersion" href="#Rimu.Hamiltonians.continuum_dispersion"><code>Rimu.Hamiltonians.continuum_dispersion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuum_dispersion(k)</code></pre><p>Dispersion relation for <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>. Returns <code>k^2</code>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>hubbard_dispersion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardMom1D.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.shift_lattice" href="#Rimu.Hamiltonians.shift_lattice"><code>Rimu.Hamiltonians.shift_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift_lattice(is)</code></pre><p>Circular shift contiguous indices <code>is</code> in interval <code>[M÷2, M÷2)</code> such that set starts with 0, where <code>M=length(is)</code>.</p><p>Inverse operation: <a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice_inv"><code>shift_lattice_inv</code></a>. Used in <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardReal1DEP.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.shift_lattice_inv" href="#Rimu.Hamiltonians.shift_lattice_inv"><code>Rimu.Hamiltonians.shift_lattice_inv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift_lattice_inv(js)</code></pre><p>Circular shift indices starting with 0 into a contiguous set in interval <code>[M÷2, M÷2)</code>, where <code>M=length(js)</code>.</p><p>Inverse operation of <a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice"><code>shift_lattice</code></a>. Used in <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/HubbardReal1DEP.jl#L11-L18">source</a></section></article><h2 id="Hamiltonian-wrappers"><a class="docs-heading-anchor" href="#Hamiltonian-wrappers">Hamiltonian wrappers</a><a id="Hamiltonian-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-wrappers" title="Permalink"></a></h2><p>The following Hamiltonians are constructed from an existing Hamiltonian instance and change its behaviour:</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.GutzwillerSampling" href="#Rimu.Hamiltonians.GutzwillerSampling"><code>Rimu.Hamiltonians.GutzwillerSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GutzwillerSampling(::AbstractHamiltonian; g)</code></pre><p>Wrapper over any <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> that implements Gutzwiller sampling. In this importance sampling scheme the Hamiltonian is modified as follows</p><p class="math-container">\[\tilde{H}_{ij} = H_{ij} e^{-g(H_{ii} - H_{jj})} .\]</p><p>This way off-diagonal spawns to higher-energy configurations are discouraged and spawns to lower-energy configurations encouraged for positive <code>g</code>.</p><p><strong>Constructor</strong></p><ul><li><code>GutzwillerSampling(::AbstractHamiltonian, g)</code></li><li><code>GutzwillerSampling(::AbstractHamiltonian; g)</code></li></ul><p>After construction, we can access the underlying Hamiltonian with <code>G.hamiltonian</code> and the <code>g</code> parameter with <code>G.g</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H = HubbardMom1D(BoseFS((1,1,1)); u=6.0, t=1.0)
HubbardMom1D(BoseFS{3,3}((1, 1, 1)); u=6.0, t=1.0)

julia&gt; G = GutzwillerSampling(H, g=0.3)
GutzwillerSampling(HubbardMom1D(BoseFS{3,3}((1, 1, 1)); u=6.0, t=1.0); g=0.3)

julia&gt; get_offdiagonal(H, BoseFS((2, 1, 0)), 1)
(BoseFS{3,3}((1, 0, 2)), 2.0)

julia&gt; get_offdiagonal(G, BoseFS((2, 1, 0)), 1)
(BoseFS{3,3}((1, 0, 2)), 0.8131393194811987)</code></pre><p><strong>Observables</strong></p><p>To calculate observables, pass the transformed Hamiltonian <code>G</code> to <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a> with keyword argument <code>transform=G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/GutzwillerSampling.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.GuidingVectorSampling" href="#Rimu.Hamiltonians.GuidingVectorSampling"><code>Rimu.Hamiltonians.GuidingVectorSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GuidingVectorSampling</code></pre><p>Wrapper over any <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> that implements guided vector a.k.a. guided wave function sampling. In this importance sampling scheme the Hamiltonian is modified as follows.</p><p class="math-container">\[\tilde{H}_{ij} = v_i H_{ij} v_j^{-1}\]</p><p>and where <code>v</code> is the guiding vector. <code>v_i</code> and <code>v_j</code> are also thresholded to avoid dividing by zero (see below).</p><p><strong>Constructors</strong></p><ul><li><code>GuidingVectorSampling(::AbstractHamiltonian, vector, eps)</code></li><li><code>GuidingVectorSampling(::AbstractHamiltonian; vector, eps)</code></li></ul><p><code>eps</code> is a thresholding parameter used to avoid dividing by zero; all values below <code>eps</code> are set to <code>eps</code>. It is recommended that <code>eps</code> is in the same value range as the guiding vector. The default value is set to <code>eps=norm(v, Inf) * 1e-2</code></p><p>After construction, we can access the underlying hamiltonian with <code>G.hamiltonian</code>, the <code>eps</code> parameter with <code>G.eps</code>, and the guiding vector with <code>G.vector</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H = HubbardReal1D(BoseFS((1,1,1)); u=6.0, t=1.0);


julia&gt; v = DVec(starting_address(H) =&gt; 10; capacity=1);


julia&gt; G = GuidingVectorSampling(H, v, 0.1);


julia&gt; get_offdiagonal(H, starting_address(H), 4)
(BoseFS{3,3}((2, 0, 1)), -1.4142135623730951)

julia&gt; get_offdiagonal(G, starting_address(G), 4)
(BoseFS{3,3}((2, 0, 1)), -0.014142135623730952)</code></pre><p><strong>Observables</strong></p><p>To calculate observables, pass the transformed Hamiltonian <code>G</code> to  <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a> with keyword argument <code>transform=G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/GuidingVectorSampling.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.ParitySymmetry" href="#Rimu.Hamiltonians.ParitySymmetry"><code>Rimu.Hamiltonians.ParitySymmetry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParitySymmetry(ham::AbstractHamiltonian{T}; even=true) &lt;: AbstractHamiltonian{T}</code></pre><p>Impose even or odd parity on all states and the Hamiltonian <code>ham</code> as controlled by the keyword argument <code>even</code>. Parity symmetry of the Hamiltonian is assumed. For some Hamiltonians, <code>ParitySymmetry</code> reduces the size of the Hilbert space by half.</p><p><code>ParitySymmetry</code> performs a unitary transformation, leaving the eigenvalues unchanged and preserving the <a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>LOStructure</code></a>. This is achieved by changing the basis set to states with defined parity. Effectively, a non-even address <span>$|α⟩$</span> is replaced by <span>$\frac{1}{√2}(|α⟩ ± |ᾱ⟩)$</span> for even and odd parity, respectively, where <code>ᾱ == reverse(α)</code>.</p><p><strong>Notes</strong></p><ul><li>This modifier currently only works on <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a>s with an odd number of modes.</li><li>For odd parity, the <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a> of the underlying Hamiltonian cannot be symmetric.</li><li>If parity is not a symmetry of the Hamiltonian <code>ham</code> then the result is undefined.</li><li><code>ParitySymmetry</code> works by modifying the <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a> iterator.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; ham = HubbardReal1D(BoseFS((0,2,1)))
HubbardReal1D(BoseFS{3,3}((0, 2, 1)); u=1.0, t=1.0)

julia&gt; size(Matrix(ham))
(10, 10)

julia&gt; size(Matrix(ParitySymmetry(ham)))
(6, 6)

julia&gt; size(Matrix(ParitySymmetry(ham; odd=true)))
(4, 4)

julia&gt; eigvals(Matrix(ham))[1] ≈ eigvals(Matrix(ParitySymmetry(ham)))[1]
true</code></pre><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.TimeReversalSymmetry"><code>TimeReversalSymmetry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/ParitySymmetry.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.TimeReversalSymmetry" href="#Rimu.Hamiltonians.TimeReversalSymmetry"><code>Rimu.Hamiltonians.TimeReversalSymmetry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeReversalSymmetry(ham::AbstractHamiltonian{T}; even=true) &lt;: AbstractHamiltonian{T}</code></pre><p>Impose even or odd time reversal on all states and the Hamiltonian <code>ham</code> as controlled by the keyword argument <code>even</code>. If time reversal is a symmetry of the Hamiltonian it will block (reducing Hilbert space dimension) preserving the eigenvalues and <a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>LOStructure</code></a>.</p><p><strong>Notes</strong></p><ul><li>This modifier only works two component <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a>es.</li><li>For odd time reversal symmetry, the <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a> of the underlying Hamiltonian must not be symmetric.</li><li>If time reversal is not a symmetry of the Hamiltonian <code>ham</code> then the result is undefined.</li><li><code>TimeReversalSymmetry</code> works by modifying the <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a> iterator.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; ham = HubbardMom1D(FermiFS2C((1,0,1),(0,1,1)));

julia&gt; size(Matrix(ham))
(3, 3)

julia&gt; size(Matrix(TimeReversalSymmetry(ham)))
(2, 2)

julia&gt; size(Matrix(TimeReversalSymmetry(ham, even=false)))
(1, 1)

julia&gt; eigvals(Matrix(TimeReversalSymmetry(ham)))[1] ≈ eigvals(Matrix(ham))[1]
true</code></pre><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>ParitySymmetry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/TRSymmetry.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.Stoquastic" href="#Rimu.Hamiltonians.Stoquastic"><code>Rimu.Hamiltonians.Stoquastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stoquastic(ham &lt;: AbstractHamiltonian) &lt;: AbstractHamiltonian</code></pre><p>A wrapper for an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> that replaces all off-diagonal matrix elements <code>v</code> by <code>-abs(v)</code>, thus making the new Hamiltonian <em>stoquastic</em>.</p><p>A stoquastic Hamiltonian does not have a Monte Carlo sign problem. For a hermitian <code>ham</code> the smallest eigenvalue of <code>Stoquastic(ham)</code> is ≤ the smallest eigenvalue of <code>ham</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/Stoquastic.jl#L1-L8">source</a></section></article><h2 id="Observables"><a class="docs-heading-anchor" href="#Observables">Observables</a><a id="Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Observables" title="Permalink"></a></h2><p>Observables are <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>s that represent a physical observable. Their ground state expectation values can be sampled by passing them into <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.G2MomCorrelator" href="#Rimu.Hamiltonians.G2MomCorrelator"><code>Rimu.Hamiltonians.G2MomCorrelator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">G2MomCorrelator(d::Int,c=:cross) &lt;: AbstractHamiltonian{ComplexF64}</code></pre><p>Two-body correlation operator representing the density-density correlation at distance <code>d</code> of a two component system in a momentum-space Fock-state basis. It returns a <code>Complex</code> value.</p><p>Correlation across two components:</p><p class="math-container">\[\hat{G}^{(2)}(d) = \frac{1}{M}\sum_{spqr=1}^M e^{-id(p-q)2π/M} a^†_{s} b^†_{p}  b_q a_r δ_{s+p,q+r}\]</p><p>Correlation within a single component:</p><p class="math-container">\[\hat{G}^{(2)}(d) = \frac{1}{M}\sum_{spqr=1}^M e^{-id(p-q)2π/M} a^†_{s} a^†_{p}  a_q a_r δ_{s+p,q+r}\]</p><p>The diagonal element, where <code>(p-q)=0</code>, is</p><p class="math-container">\[\frac{1}{M}\sum_{k,p=1}^M a^†_{k} b^†_{p}  b_p a_k .\]</p><p><strong>Arguments</strong></p><ul><li><code>d::Integer</code>: the distance between two particles.</li><li><code>c</code>: possible instructions: <code>:cross</code>: default instruction, computing correlation between particles across two components; <code>:first</code>: computing correlation between particles within the first component; <code>:second</code>: computing correlation between particles within the second component. These are the only defined instructions, using anything else will produce errors.</li></ul><p><strong>To use on a one-component system</strong></p><p>For a system with only one component, e.g. with <code>BoseFS</code>, the second argument <code>c</code> is irrelevant and can be any of the above instructions, one could simply skip this argument and let it be the default value.</p><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS2C"><code>BoseFS2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a></li><li><a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/correlation_functions.jl#L87-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.G2RealCorrelator" href="#Rimu.Hamiltonians.G2RealCorrelator"><code>Rimu.Hamiltonians.G2RealCorrelator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">G2RealCorrelator(d::Int) &lt;: AbstractHamiltonian{Float64}</code></pre><p>Two-body operator for density-density correlation between sites separated by <code>d</code> with <code>0 ≤ d &lt; M</code>.</p><p class="math-container">\[    \hat{G}^{(2)}(d) = \frac{1}{M} \sum_i^M \hat{n}_i (\hat{n}_{i+d} - \delta_{0d}).\]</p><p>Assumes a one-dimensional lattice with periodic boundary conditions where</p><p class="math-container">\[    \hat{G}^{(2)}(-M/2 \leq d &lt; 0) = \hat{G}^{(2)}(|d|),\]</p><p class="math-container">\[    \hat{G}^{(2)}(M/2 &lt; d &lt; M) = \hat{G}^{(2)}(M - d),\]</p><p>and normalisation</p><p class="math-container">\[    \sum_{d=0}^{M-1} \langle \hat{G}^{(2)}(d) \rangle = \frac{N (N-1)}{M}.\]</p><p>For multicomponent basis, calculates correlations between all particles equally,  equivalent to stacking all components into a single Fock state.</p><p><strong>Arguments</strong></p><ul><li><code>d::Integer</code>: distance between sites.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2MomCorrelator"><code>G2MomCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a></li><li><a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/correlation_functions.jl#L2-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.DensityMatrixDiagonal" href="#Rimu.Hamiltonians.DensityMatrixDiagonal"><code>Rimu.Hamiltonians.DensityMatrixDiagonal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityMatrixDiagonal(mode; component=0) &lt;: AbstractHamiltonian</code></pre><p>Represent a diagonal element of the single-particle density:</p><p class="math-container">\[\hat{n}_{i,σ} = \hat a^†_{i,σ} \hat a_{i,σ}\]</p><p>where <span>$i$</span> is the <code>mode</code> and <span>$σ$</span> is the <code>component</code>. If <code>component</code> is zero, the sum over all components is computed.</p><p><strong>See also</strong></p><ul><li><a href="API.html#Rimu.single_particle_density-Tuple{Any}"><code>single_particle_density</code></a></li><li><a href="API.html#Rimu.SingleParticleDensity"><code>SingleParticleDensity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/DensityMatrixDiagonal.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.Momentum" href="#Rimu.Hamiltonians.Momentum"><code>Rimu.Hamiltonians.Momentum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Momentum(component=0; fold=true) &lt;: AbstractHamiltonian</code></pre><p>The momentum operator <span>$\hat{p}$</span>.</p><p>The component argument controls which component of the address is taken into consideration. A value of 0 sums the contributions of all components. If <code>fold</code> is true, the momentum is folded into the Brillouin zone.</p><pre><code class="language-julia-repl hljs">julia&gt; add = BoseFS((1, 0, 2, 1, 2, 1, 1, 3))
BoseFS{11,8}((1, 0, 2, 1, 2, 1, 1, 3))

julia&gt; v = DVec(add =&gt; 10);

julia&gt; rayleigh_quotient(Momentum(), DVec(add =&gt; 1))
-2.0

julia&gt; rayleigh_quotient(Momentum(fold=false), DVec(add =&gt; 1))
14.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/Momentum.jl#L1-L22">source</a></section></article><h2 id="Hamiltonians-interface"><a class="docs-heading-anchor" href="#Hamiltonians-interface">Hamiltonians interface</a><a id="Hamiltonians-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians-interface" title="Permalink"></a></h2><p>Behind the implementation of a particular model is a more abstract interface for defining Hamiltonians. If you want to define a new model you should make use of this interface. The most general form of a model Hamiltonian should subtype to <code>AbstractHamiltonian</code> and implement the relevant methods.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.AbstractHamiltonian" href="#Rimu.Interfaces.AbstractHamiltonian"><code>Rimu.Interfaces.AbstractHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHamiltonian{T}</code></pre><p>Supertype that provides an interface for linear operators over a linear space with scalar type <code>T</code> that are suitable for FCIQMC (with <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a>). Indexing is done with addresses (typically not integers) from an address space that may be large (and will not need to be completely generated).</p><p><code>AbstractHamiltonian</code> instances operate on vectors of type <a href="dictvectors.html#Rimu.Interfaces.AbstractDVec"><code>AbstractDVec</code></a> from the module <code>DictVectors</code> and work well with addresses of type <a href="addresses.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>AbstractFockAddress</code></a> from the module <code>BitStringAddresses</code>. The type works well with the external package <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit.jl</a>.</p><p>For available implementations see <a href="hamiltonians.html#Rimu.Hamiltonians"><code>Hamiltonians</code></a>.</p><p><strong>Interface</strong></p><p>Methods that need to be implemented:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>num_offdiagonals(::AbstractHamiltonian, address)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>get_offdiagonal(::AbstractHamiltonian, address, chosen::Integer)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.diagonal_element"><code>diagonal_element(::AbstractHamiltonian, address)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address(::AbstractHamiltonian)</code></a></li></ul><p>Optional methods to implement:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>LOStructure(::Type{typeof(lo)})</code></a>: defaults to <code>AdjointUnknown</code></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>dimension(::Type{T}, ::AbstractHamiltonian)</code></a>: defaults to dimension of address space</li><li><a href="hamiltonians.html#Rimu.Hamiltonians.momentum"><code>momentum(::AbstractHamiltonian)</code></a>: no default</li></ul><p>Provides:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>: iterator over reachable off-diagonal matrix elements</li><li><a href="hamiltonians.html#Rimu.Interfaces.random_offdiagonal"><code>random_offdiagonal</code></a>: function to generate random off-diagonal matrix element</li><li><code>*(H, v)</code>: deterministic matrix-vector multiply (allocating)</li><li><code>H(v)</code>: equivalent to <code>H * v</code>.</li><li><code>mul!(w, H, v)</code>: mutating matrix-vector multiply.</li><li><a href="hamiltonians.html#LinearAlgebra.dot"><code>dot(x, H, v)</code></a>: compute <code>x⋅(H*v)</code> minimizing allocations.</li><li><code>H[address1, address2]</code>: indexing with <code>getindex()</code> - mostly for testing purposes (slow!)</li><li><a href="hamiltonians.html#SparseArrays.sparse"><code>BasisSetRep</code></a>: construct a basis set repesentation</li><li><a href="hamiltonians.html#SparseArrays.sparse"><code>sparse</code></a>, <a href="hamiltonians.html#Base.Matrix"><code>Matrix</code></a>: construct a (sparse) matrix representation</li></ul><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians"><code>Hamiltonians</code></a>, <a href="interfaces.html#Rimu.Interfaces"><code>Interfaces</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L4-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.offdiagonals" href="#Rimu.Interfaces.offdiagonals"><code>Rimu.Interfaces.offdiagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offdiagonals(h::AbstractHamiltonian, address)</code></pre><p>Return an iterator over reachable off-diagonal matrix elements of type <code>&lt;:AbstractOffdiagonals</code>. Defaults to returning <code>Offdiagonals(h, a)</code></p><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.Offdiagonals"><code>Offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AbstractOffdiagonals"><code>AbstractOffdiagonals</code></a></li></ul><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3,2,1));


julia&gt; H = HubbardReal1D(addr);


julia&gt; h = offdiagonals(H, addr)
6-element Rimu.Hamiltonians.Offdiagonals{BoseFS{6, 3, BitString{8, 1, UInt8}}, Float64, HubbardReal1D{Float64, BoseFS{6, 3, BitString{8, 1, UInt8}}, 1.0, 1.0}}:
 (fs&quot;|2 3 1⟩&quot;, -3.0)
 (fs&quot;|2 2 2⟩&quot;, -2.449489742783178)
 (fs&quot;|3 1 2⟩&quot;, -2.0)
 (fs&quot;|4 1 1⟩&quot;, -2.8284271247461903)
 (fs&quot;|4 2 0⟩&quot;, -2.0)
 (fs&quot;|3 3 0⟩&quot;, -1.7320508075688772)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L138-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.diagonal_element" href="#Rimu.Interfaces.diagonal_element"><code>Rimu.Interfaces.diagonal_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diagonal_element(ham, add)</code></pre><p>Compute the diagonal matrix element of the linear operator <code>ham</code> at address <code>add</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; diagonal_element(H, addr)
8.666666666666664</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.starting_address" href="#Rimu.Interfaces.starting_address"><code>Rimu.Interfaces.starting_address</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">starting_address(h)</code></pre><p>Return the starting address for Hamiltonian <code>h</code>. Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface. When called on an <code>AbstractMatrix</code> return the index of the lowest diagonal element.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; addr == starting_address(H)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L116-L135">source</a></section></article><p>The following functions may be implemented instead of <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.num_offdiagonals" href="#Rimu.Interfaces.num_offdiagonals"><code>Rimu.Interfaces.num_offdiagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_offdiagonals(ham, add)</code></pre><p>Compute the number of number of reachable configurations from address <code>add</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; num_offdiagonals(H, addr)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L74-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.get_offdiagonal" href="#Rimu.Interfaces.get_offdiagonal"><code>Rimu.Interfaces.get_offdiagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newadd, me = get_offdiagonal(ham, add, chosen)</code></pre><p>Compute value <code>me</code> and new address <code>newadd</code> of a single (off-diagonal) matrix element in a Hamiltonian <code>ham</code>. The off-diagonal element is in the same column as address <code>add</code> and is indexed by integer index <code>chosen</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; get_offdiagonal(H, addr, 3)
(BoseFS{6,3}((2, 1, 3)), 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L94-L113">source</a></section></article><p>The following functions come with default implementations, but may be customized.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.random_offdiagonal" href="#Rimu.Interfaces.random_offdiagonal"><code>Rimu.Interfaces.random_offdiagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_offdiagonal(offdiagonals::AbstractOffdiagonals)
random_offdiagonal(ham::AbstractHamiltonian, add)</code></pre><p>Generate a single random excitation, i.e. choose from one of the accessible off-diagonal elements in the column corresponding to address <code>add</code> of the Hamiltonian matrix represented by <code>ham</code>. Alternatively, pass as argument an iterator over the accessible matrix elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L173-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.LOStructure" href="#Rimu.Interfaces.LOStructure"><code>Rimu.Interfaces.LOStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LOStructure(op::AbstractHamiltonian)
LOStructure(typeof(op))</code></pre><p><code>LOStructure</code> speficies properties of the linear operator <code>op</code>. If a special structure is known this can speed up calculations. Implemented structures are:</p><ul><li><code>IsDiagonal</code>: The operator is diagonal.</li><li><code>IsHermitian</code>: The operator is complex and Hermitian or real and symmetric.</li><li><code>AdjointKnown</code>: The operator is not Hermitian, but its <a href="hamiltonians.html#Base.adjoint"><code>adjoint</code></a> is implemented.</li><li><code>AdjointUnknown</code>: <a href="hamiltonians.html#Base.adjoint"><code>adjoint</code></a> for this operator is not implemented.</li></ul><p>In order to define this trait for a new linear operator type, define a method for <code>LOStructure(::Type{&lt;:MyNewLOType}) = …</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L193-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.dimension" href="#Rimu.Hamiltonians.dimension"><code>Rimu.Hamiltonians.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimension([::Type{T}], h)</code></pre><p>Return the estimated dimension of Hilbert space as <code>T</code> (defaults to <code>Int</code>). If the result does not fit into <code>T</code>, return <code>nothing</code>. If <code>T&lt;:AbstractFloat</code>, an approximate value computed with the improved Stirling formula may be returned instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dimension(HubbardMom1D(BoseFS((1,2,3))))
28
julia&gt; dimension(HubbardMom1D(near_uniform(BoseFS{200,100})))


julia&gt; dimension(Float64, HubbardMom1D(near_uniform(BoseFS{200,100})))
1.3862737677578234e81
julia&gt; dimension(BigInt, HubbardMom1D(near_uniform(BoseFS{200,100})))
1386083821086188248261127842108801860093488668581216236221011219101585442774669540</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L21-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.has_adjoint" href="#Rimu.Interfaces.has_adjoint"><code>Rimu.Interfaces.has_adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_adjoint(op)</code></pre><p>Return true if <code>adjoint</code> is defined on <code>op</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Interfaces/hamiltonians.jl#L221-L225">source</a></section></article><p>This interface relies on unexported functionality, including</p><article class="docstring"><header><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjoint(::LOStructure, op::AbstractHamiltonian)</code></pre><p>Represent the adjoint of an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>. Extend this method to define custom adjoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/abstract.jl#L590-L595">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.dot" href="#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dot(w, op::AbstractHamiltonian, v)</code></pre><p>Evaluate <code>w⋅op(v)</code> minimizing memory allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/DictVectors/abstractdvec.jl#L234-L238">source</a></section><section><div><pre><code class="nohighlight hljs">dot(map::OccupiedModeMap, vec::AbstractVector)
dot(map1::OccupiedModeMap, map2::OccupiedModeMap)</code></pre><p>Dot product extracting mode occupation numbers from an <a href="addresses.html#Rimu.BitStringAddresses.OccupiedModeMap"><code>OccupiedModeMap</code></a> similar to <a href="addresses.html#Rimu.BitStringAddresses.onr-Union{Tuple{BoseFS{&lt;:Any, M}}, Tuple{M}} where M"><code>onr</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; b = BoseFS((10, 0, 0, 0, 2, 0, 1))
BoseFS{13,7}((10, 0, 0, 0, 2, 0, 1))

julia&gt; mb = OccupiedModeMap(b)
3-element OccupiedModeMap{7, BoseFSIndex}:
 BoseFSIndex(occnum=10, mode=1, offset=0)
 BoseFSIndex(occnum=2, mode=5, offset=14)
 BoseFSIndex(occnum=1, mode=7, offset=18)

julia&gt; dot(mb, 1:7)
27

julia&gt; mb⋅(1:7) == onr(b)⋅(1:7)
true</code></pre><p>See also <a href="addresses.html#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>SingleComponentFockAddress</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/BitStringAddresses/fockaddress.jl#L268-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.AbstractOffdiagonals" href="#Rimu.Hamiltonians.AbstractOffdiagonals"><code>Rimu.Hamiltonians.AbstractOffdiagonals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOffdiagonals{A,T}&lt;:AbstractVector{Tuple{A,T}}</code></pre><p>Iterator over new address and matrix elements for reachable off-diagonal matrix elements of a linear operator.</p><p>See <a href="hamiltonians.html#Rimu.Hamiltonians.Offdiagonals"><code>Offdiagonals</code></a> for a default implementation.</p><p><strong>Methods to define</strong></p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals(h, a)::AbstractOffdiagonals</code></a>: This function is used to construct the correct type of offdiagonals for a given combination of Hamiltonian <code>h</code> and Fock address <code>a</code>.</li><li><code>Base.getindex(::AbstractOffdiagonals, i)</code>: should be equivalent to <code>get_offdiagonal(h, a, i)</code>.</li><li><code>Base.size(::AbstractOffdiagonals)</code>: should be equivalent to <code>num_offdiagonals(h, a)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/offdiagonals.jl#L5-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.Offdiagonals" href="#Rimu.Hamiltonians.Offdiagonals"><code>Rimu.Hamiltonians.Offdiagonals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Offdiagonals(h, address)</code></pre><p>Iterator over new address and matrix element for reachable off-diagonal matrix elements of linear operator <code>h</code> from address <code>address</code>.  Represents an abstract vector containing the possibly non-zero off-diagonal matrix elements of the column of ham indexed by add.</p><p>This is the default implementation defined in terms of <a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>num_offdiagonals</code></a> and <a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>get_offdiagonal</code></a>.</p><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/offdiagonals.jl#L29-L43">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><p>Lattices in higher dimensions are defined here for <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.LatticeGeometry" href="#Rimu.Hamiltonians.LatticeGeometry"><code>Rimu.Hamiltonians.LatticeGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type LatticeGeometry{D}</code></pre><p>A <code>LatticeGeometry</code> controls which sites in an <a href="addresses.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>AbstractFockAddress</code></a> are considered to be neighbours.</p><p>Currently only supported by <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><p><strong>Available implementations</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul><p><strong>Interface to implement</strong></p><ul><li><code>Base.size</code>: return the lattice size.</li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site(::LatticeGeometry, ::Int, ::Int)</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_dimensions"><code>num_dimensions(::LatticeGeometry)</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>num_neighbours(::LatticeGeometry)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/geometry.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.PeriodicBoundaries" href="#Rimu.Hamiltonians.PeriodicBoundaries"><code>Rimu.Hamiltonians.PeriodicBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundaries(size...) &lt;: LatticeGeometry</code></pre><p>Rectangular lattice with periodic boundary conditions of size <code>size</code>.</p><p>The dimension of the lattice is controlled by the number of arguments given to its constructor.</p><p>This is the default geometry used by <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = PeriodicBoundaries(5, 4) # 2D lattice of size 5 × 4
PeriodicBoundaries(5, 4)

julia&gt; num_neighbours(lattice)
4

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
5

julia&gt; neighbour_site(lattice, 1, 3)
6

julia&gt; neighbour_site(lattice, 1, 4)
16</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>num_neighbours</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/geometry.jl#L67-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HardwallBoundaries" href="#Rimu.Hamiltonians.HardwallBoundaries"><code>Rimu.Hamiltonians.HardwallBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HardwallBoundaries</code></pre><p>Rectangular lattice with hard wall boundary conditions of size <code>size</code>. <a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site()</code></a> will return 0 for some neighbours of boundary sites.</p><p>The dimension of the lattice is controlled by the number of arguments given to its constructor.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = HardwallBoundaries(5) # 1D lattice of size 5
HardwallBoundaries(5)

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
0
</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/geometry.jl#L136-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.LadderBoundaries" href="#Rimu.Hamiltonians.LadderBoundaries"><code>Rimu.Hamiltonians.LadderBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LadderBoundaries(size...; subgeometry=PeriodicBoundaries) &lt;: LatticeGeometry</code></pre><p>Lattice geometry where the first dimension is of size 2 and has hardwall boundary conditions. Using this geometry is more efficient than using <a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a> with a size of 2, as it does not generate rejected neighbours.</p><p>In other dimensions, it behaves like its subgeometry, which can be any <a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = LadderBoundaries(2, 3, 4) # 3D lattice of size 2 × 3 × 4
LadderBoundaries(2, 3, 4)

julia&gt; num_neighbours(lattice)
5

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
3

julia&gt; neighbour_site(lattice, 1, 3)
5

julia&gt; neighbour_site(lattice, 1, 4)
7

julia&gt; neighbour_site(lattice, 1, 5)
19</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/geometry.jl#L190-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.num_neighbours" href="#Rimu.Hamiltonians.num_neighbours"><code>Rimu.Hamiltonians.num_neighbours</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_neighbours(geom::LatticeGeometry)</code></pre><p>Return the number of neighbours each lattice site has in this geometry.</p><p>Note that for efficiency reasons, all sites are expected to have the same number of neighbours. If some of the neighbours are invalid, this is handled by having <a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site</code></a> return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/geometry.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.num_dimensions" href="#Rimu.Hamiltonians.num_dimensions"><code>Rimu.Hamiltonians.num_dimensions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_dimensions(geom::LatticeGeometry)</code></pre><p>Return the number of dimensions of the lattice in this geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/geometry.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.neighbour_site" href="#Rimu.Hamiltonians.neighbour_site"><code>Rimu.Hamiltonians.neighbour_site</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighbour_site(geom::LatticeGeometry, site, i)</code></pre><p>Find the <code>i</code>-th neighbour of <code>site</code> in the geometry. If the move is illegal, return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/ed517bddae7d4e85653f36c9361bf733dec69eba/src/Hamiltonians/geometry.jl#L41-L45">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a></li><li><a href="hamiltonians.html#Base.Matrix"><code>Base.Matrix</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AbstractOffdiagonals"><code>Rimu.Hamiltonians.AbstractOffdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>Rimu.Hamiltonians.BasisSetRep</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>Rimu.Hamiltonians.BoseHubbardMom1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>Rimu.Hamiltonians.BoseHubbardReal1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.DensityMatrixDiagonal"><code>Rimu.Hamiltonians.DensityMatrixDiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>Rimu.Hamiltonians.ExtendedHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2MomCorrelator"><code>Rimu.Hamiltonians.G2MomCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>Rimu.Hamiltonians.G2RealCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.GuidingVectorSampling"><code>Rimu.Hamiltonians.GuidingVectorSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.GutzwillerSampling"><code>Rimu.Hamiltonians.GutzwillerSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>Rimu.Hamiltonians.HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>Rimu.Hamiltonians.HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>Rimu.Hamiltonians.HubbardMom1DEP</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>Rimu.Hamiltonians.HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>Rimu.Hamiltonians.HubbardReal1DEP</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>Rimu.Hamiltonians.HubbardRealSpace</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>Rimu.Hamiltonians.LadderBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>Rimu.Hamiltonians.LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian"><code>Rimu.Hamiltonians.MatrixHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Momentum"><code>Rimu.Hamiltonians.Momentum</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Offdiagonals"><code>Rimu.Hamiltonians.Offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>Rimu.Hamiltonians.ParitySymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>Rimu.Hamiltonians.PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Stoquastic"><code>Rimu.Hamiltonians.Stoquastic</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.TimeReversalSymmetry"><code>Rimu.Hamiltonians.TimeReversalSymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Transcorrelated1D"><code>Rimu.Hamiltonians.Transcorrelated1D</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>Rimu.Interfaces.AbstractHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>Rimu.Interfaces.LOStructure</code></a></li><li><a href="hamiltonians.html#Base.adjoint"><code>Base.adjoint</code></a></li><li><a href="hamiltonians.html#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.build_basis"><code>Rimu.Hamiltonians.build_basis</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>Rimu.Hamiltonians.continuum_dispersion</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>Rimu.Hamiltonians.dimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>Rimu.Hamiltonians.hubbard_dispersion</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.momentum"><code>Rimu.Hamiltonians.momentum</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>Rimu.Hamiltonians.neighbour_site</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_dimensions"><code>Rimu.Hamiltonians.num_dimensions</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>Rimu.Hamiltonians.num_neighbours</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.rayleigh_quotient"><code>Rimu.Hamiltonians.rayleigh_quotient</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice"><code>Rimu.Hamiltonians.shift_lattice</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice_inv"><code>Rimu.Hamiltonians.shift_lattice_inv</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.diagonal_element"><code>Rimu.Interfaces.diagonal_element</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>Rimu.Interfaces.get_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.has_adjoint"><code>Rimu.Interfaces.has_adjoint</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>Rimu.Interfaces.num_offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>Rimu.Interfaces.offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.random_offdiagonal"><code>Rimu.Interfaces.random_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>Rimu.Interfaces.starting_address</code></a></li><li><a href="hamiltonians.html#SparseArrays.sparse"><code>SparseArrays.sparse</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="interfaces.html">« Interfaces</a><a class="docs-footer-nextpage" href="dictvectors.html">Dict vectors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 9 March 2023 04:42">Thursday 9 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
