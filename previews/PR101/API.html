<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Rimu.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Rimu.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><a class="tocitem" href="BHM-example.html">Example: 1D Bose-Hubbard Model</a></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="statstools.html">StatsTools</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="consistentrng.html">Random Numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li class="is-active"><a class="tocitem" href="API.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rimu"><span>Rimu</span></a></li><li class="toplevel"><a class="tocitem" href="#Reexported-Submodules"><span>Reexported Submodules</span></a></li><li><a class="tocitem" href="#Hamiltonians"><span>Hamiltonians</span></a></li><li><a class="tocitem" href="#BitStringAddresses"><span>BitStringAddresses</span></a></li><li><a class="tocitem" href="#DictVectors"><span>DictVectors</span></a></li><li><a class="tocitem" href="#ConsistentRNG"><span>ConsistentRNG</span></a></li><li class="toplevel"><a class="tocitem" href="#Unexported-Submodules"><span>Unexported Submodules</span></a></li><li><a class="tocitem" href="#StatsTools"><span>StatsTools</span></a></li><li><a class="tocitem" href="#Blocking"><span>Blocking</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="API.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Rimu"><a class="docs-heading-anchor" href="#Rimu">Rimu</a><a id="Rimu-1"></a><a class="docs-heading-anchor-permalink" href="#Rimu" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.Rimu" href="#Rimu.Rimu"><code>Rimu.Rimu</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Rimu</code></pre><p>Random Integrator for Many-Body Quantum Systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/Rimu.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.AllOverlaps" href="#Rimu.AllOverlaps"><code>Rimu.AllOverlaps</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AllOverlaps(n=2, operator=nothing) &lt;: ReplicaStrategy{n}</code></pre><p>Run <code>n</code> replicas and report overlaps between all pairs of replica vectors. If operator is not <code>nothing</code>, the overlap <code>dot(c1, operator, c2)</code> is reported as well. If operator is a tuple of operators, the overlaps are computed for all operators.</p><p>Column names in the report are of the form c{i}<em>dot</em>c{j} for vector-vector overlaps, and c{i}<em>Op{k}</em>c{j} for operator overlaps.</p><p>See <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> (for an interface for implementing operators).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/replicastrategy.jl#L39-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ConstantTimeStep" href="#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantTimeStep &lt;: TimeStepStrategy</code></pre><p>Keep <code>dτ</code> constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/timestepstrategy.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory" href="#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeltaMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="nohighlight hljs">r̃ = (pnorm - tnorm)/(dτ*pnorm) + shift
r = r̃ - &lt;r̃&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory2" href="#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeltaMemory2(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="nohighlight hljs">r̃ = pnorm - tnorm + shift*dτ*pnorm
r = (r̃ - &lt;r̃&gt;)/(dτ*pnorm)</code></pre><p>The long-term average of <code>r</code> is not guaranteed to be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory3" href="#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeltaMemory3(Δ::Int, level::Float64) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, apply multiplicative memory noise with a memory length of <code>Δ</code> at level <code>level</code>, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="nohighlight hljs">r̃ = (pnorm - tnorm)/pnorm + dτ*shift
r = r̃ - &lt;r̃&gt;
w .*= 1 + level*r</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L59-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DontUpdate" href="#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DontUpdate(; targetwalkers = 1_000_000) &lt;: ShiftStrategy</code></pre><p>Don&#39;t update the <code>shift</code>.  Return when <code>targetwalkers</code> is reached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L19-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogProjected" href="#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogProjected(; target, projector, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> after projecting onto <code>projector</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{P⋅Ψ^{(n)}}\right)-\frac{ξ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{\text{target}}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L203-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogSumUpdate" href="#Rimu.DoubleLogSumUpdate"><code>Rimu.DoubleLogSumUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogSumUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, α = 1/2) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameters <code>ζ</code> and <code>ξ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^n}\right)
- \frac{ξ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^\text{target}}\right),\]</p><p>where <span>$N_\mathrm{w} =$</span> <code>(1-α)*walkernumber() + α*UniformProjector()⋅ψ</code> computed with <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber()</code></a> and <a href="API.html#Rimu.DictVectors.UniformProjector"><code>UniformProjector()</code></a>. When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdate" href="#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)-\frac{ξ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^\text{target}}\right)\]</p><p>When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L69-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkers" href="#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DoubleLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, ξ = 0.0016) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FciqmcRunStrategy" href="#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs"> FciqmcRunStrategy{T}</code></pre><p>Abstract type representing the strategy for running and terminating <a href="@ref"><code>fciqmc!()</code></a>. The type parameter <code>T</code> is relevant for reporting the shift and the norm.</p><p>Implemented strategies:</p><ul><li><a href="API.html#Rimu.RunTillLastStep"><code>RunTillLastStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/fciqmcrunstrategy.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdate" href="#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogUpdate(ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdateAfterTargetWalkers" href="#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code>. See <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MemoryStrategy" href="#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:</p><ul><li><a href="API.html#Rimu.NoMemory"><code>NoMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>DeltaMemory</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>ShiftMemory</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MultiScalar" href="#Rimu.MultiScalar"><code>Rimu.MultiScalar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiScalar</code></pre><p>Wrapper over a tuple that supports <code>+</code>, <code>-</code>, <code>min</code>, and <code>max</code>. Used with MPI communication because <code>SVector</code>s are treated as arrays by <code>MPI.Allreduce</code> and <code>Tuples</code> do not support scalar operations.</p><p><strong>Example</strong></p><p>Suppose you want to compute the sum of a vector <code>dv</code> and also get the number of positive elements it has in a single pass. You can use <code>MultiScalar</code>:</p><pre><code class="language-julia hljs">julia&gt; dv = DVec(:a =&gt; 1, :b =&gt; -2, :c =&gt; 1);

julia&gt; s, p = mapreduce(+, values(dv)) do v
    Rimu.MultiScalar(v, Int(sign(v) == 1))
end;

julia&gt; s, p
(0, 2)</code></pre><p>This will work with <code>MPIData</code>.</p><p>Note that only <code>MultiScalar</code>s with the same types can be operated on. This is a feature, as it forces type stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/helpers.jl#L38-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoMemory" href="#Rimu.NoMemory"><code>Rimu.NoMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoMemory &lt;: MemoryStrategy</code></pre><p>Default strategy for <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a> indicating that no memory noise will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoStats" href="#Rimu.NoStats"><code>Rimu.NoStats</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoStats(N=1) &lt;: ReplicaStrategy{N}</code></pre><p>The default <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a>. <code>N</code> replicas are run, but no statistics are collected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/replicastrategy.jl#L29-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.PostStepStrategy" href="#Rimu.PostStepStrategy"><code>Rimu.PostStepStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PostStepStrategy</code></pre><p>Subtypes of <code>PostStepStrategy</code> can be used to perform arbitrary computation on a replica after an FCIQMC step is finished and report the results.</p><p><strong>Implemented strategies:</strong></p><ul><li><a href="API.html#Rimu.ProjectedEnergy"><code>ProjectedEnergy</code></a></li><li><a href="API.html#Rimu.Projector"><code>Projector</code></a></li><li><a href="API.html#Rimu.SignCoherence"><code>SignCoherence</code></a></li><li><a href="API.html#Rimu.WalkerLoneliness"><code>WalkerLoneliness</code></a></li></ul><p>Note: A tuple of multiple strategies can be passed to <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a>. In that case, all reported column names must be distinct.</p><p><strong>Interface:</strong></p><p>A subtype of this type must implement <a href="API.html#Rimu.post_step"><code>post_step(::PostStepStrategy, ::ReplicaState)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/poststepstrategy.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectedEnergy" href="#Rimu.ProjectedEnergy"><code>Rimu.ProjectedEnergy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedEnergy(hamiltonian, projector; hproj=:vproj, vproj=:vproj) &lt;: PostStepStrategy</code></pre><p>After every step, compute <code>hproj = dot(projector, hamiltonian, dv)</code> and <code>vproj = dot(projector, dv)</code>, where <code>dv</code> is the instantaneous coefficient vector.  <code>projector</code> can be an <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>, or an <a href="API.html#Rimu.DictVectors.AbstractProjector"><code>AbstractProjector</code></a>.</p><p>Reports to columns <code>hproj</code> and <code>vproj</code>, which can be used to compute projective energy, e.g. with <a href="statstools.html#Rimu.StatsTools.ratio_of_means-Tuple{Any, Any}"><code>Rimu.StatsTools.ratio_of_means</code></a>. The keyword arguments <code>hproj</code> and <code>vproj</code> can be used to change the names of these columns. This can be used to make the names unique when computing projected energies with different projectors in the same run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/poststepstrategy.jl#L60-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectedMemory" href="#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectedMemory(Δ::Int, projector, pp::Number) &lt;: MemoryStrategy
ProjectedMemory(Δ::Int, projector, v::AbstractDVec)</code></pre><p>Before updating the shift, apply memory noise to minimize the fluctuations of the overlap of the coefficient vector with <code>projector</code>. Averaging over <code>Δ</code> time steps is applied, where <code>Δ = 1</code> means no memory noise is applied. Use <code>pp</code> to initialise the value of the projection or pass <code>v</code> in order to initialise the projection with <code>pp = projector.v</code>.</p><pre><code class="nohighlight hljs">r̃ = (projector⋅v - projector⋅w)/projector⋅v + dτ*shift
r = r̃ - &lt;r̃&gt;</code></pre><p>where <code>v</code> is the coefficient vector before and <code>w</code> after applying a regular FCIQMC step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L91-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Projector" href="#Rimu.Projector"><code>Rimu.Projector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Projector(name=projector) &lt;: PostStepStrategy</code></pre><p>After each step, compute <code>dot(projector, dv)</code> and report it in the <code>DataFrame</code> under <code>name</code>. <code>projector</code> can be an <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>, or an <a href="API.html#Rimu.DictVectors.AbstractProjector"><code>AbstractProjector</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/poststepstrategy.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.PurgeNegatives" href="#Rimu.PurgeNegatives"><code>Rimu.PurgeNegatives</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PurgeNegatives &lt;: MemoryStrategy</code></pre><p>Purge all negative sign walkers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.QMCState" href="#Rimu.QMCState"><code>Rimu.QMCState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QMCState</code></pre><p>Holds all information needed to run FCIQMC, except the data frame. Holds a <code>NTuple</code> of <code>ReplicaState</code>s and various strategies that control the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/lomc.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReplicaState" href="#Rimu.ReplicaState"><code>Rimu.ReplicaState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReplicaState(v, w, pnorm, params, id)</code></pre><p>Struct that holds all information needed for an independent run of the algorithm.</p><p>Can be advanced a step forward with <a href="API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T"><code>advance!</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>hamiltonian</code>: the model Hamiltonian.</li><li><code>v</code>: vector.</li><li><code>w</code>: working memory.</li><li><code>pnorm</code>: previous walker number (see <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber</code></a>).</li><li><code>params</code>: the <a href="@ref"><code>FCIQMCRunStrategy</code></a>.</li><li><code>id</code>: appended to reported columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/lomc.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReplicaStrategy" href="#Rimu.ReplicaStrategy"><code>Rimu.ReplicaStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReplicaStrategy{N}</code></pre><p>An abstract type that controles how <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> uses replicas. A subtype of <code>ReplicaStrategy{N}</code> operates on <code>N</code> replicas and must implement the following function:</p><ul><li><a href="@ref"><code>replica_stats(::ReplicaStrategy{N}, ::NTuple{N,ReplicaState})</code></a> - return a tuple of <code>String</code>s or <code>Symbols</code> of replica statistic names and a tuple of the values.  These will be reported to the <code>DataFrame</code> returned by <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a></li></ul><p>Concrete implementations:</p><ul><li><a href="API.html#Rimu.NoStats"><code>NoStats</code></a>: run (possibly one) replica(s), but don&#39;t report any additional info.</li><li><a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>: report overlaps between all pairs of replica vectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/replicastrategy.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Report" href="#Rimu.Report"><code>Rimu.Report</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Report</code></pre><p>Internal structure that holds the temporary reported values. See <a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>report!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportDFAndInfo" href="#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReportDFAndInfo(; k=1, i=100, io=stdout, writeinfo=false) &lt;: ReportingStrategy</code></pre><p>The default <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a>. Report every <code>k</code>th step to a <code>DataFrame</code> and write info message to <code>io</code> every <code>i</code>th step (unless <code>writeinfo == false</code>). The flag <code>writeinfo</code> is useful for controlling info messages in MPI codes, e.g. by setting <code>writeinfo=is_mpi_root()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportToFile" href="#Rimu.ReportToFile"><code>Rimu.ReportToFile</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReportToFile(; kwargs...) &lt;: ReportingStrategy</code></pre><p>Reporting strategy that writes the report directly to a file. Useful when dealing with long jobs or large numbers of replicas, when the report can incur a significant memory cost.</p><p><strong>Keyword arguments</strong></p><ul><li><code>filename</code>: the file to report to. If the file already exists, a new file is created.</li><li><code>chunk_size = 1000</code>: the size of each chunk that is written to the file. A <code>DataFrame</code> of this size is collected in memory and written to disk. When saving, an info message is also printed to <code>io</code>.</li><li><code>save_if = true</code>: if this value is true, save the report, otherwise ignore it. Use <code>save_if=is_mpi_root()</code> when running MPI jobs.</li><li><code>return_df</code>: if this value is true, read the file and return the data frame at the end of computation. Otherwise, an empty <code>DataFrame</code> is returned.</li><li><code>io=stdout</code>: The <code>IO</code> to print messages to. Set to <code>devnull</code> if you don&#39;t want to see messages printed out.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L178-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportingStrategy" href="#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ReportingStrategy</code></pre><p>Abstract type for strategies for reporting data in a DataFrame with <a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>report!()</code></a>.</p><p><strong>Implemented strategies:</strong></p><ul><li><a href="API.html#Rimu.ReportDFAndInfo"><code>ReportDFAndInfo</code></a></li><li><a href="API.html#Rimu.ReportToFile"><code>ReportToFile</code></a></li></ul><p><strong>Interface:</strong></p><p>A <code>ReportingStrategy</code> can define any of the following:</p><ul><li><a href="API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy}"><code>refine_r_strat</code></a></li><li><a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>report!</code></a></li><li><a href="API.html#Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>report_after_step</code></a></li><li><a href="API.html#Rimu.finalize_report!-Tuple{ReportingStrategy, Any}"><code>finalize_report!</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L79-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RunTillLastStep" href="#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RunTillLastStep(step::Int = 0 # number of current/starting timestep
             laststep::Int = 100 # number of final timestep
             shiftMode::Bool = false # whether to adjust shift
             shift = 0.0 # starting/current value of shift
             dτ::Float64 = 0.01 # current value of time step
) &lt;: FciqmcRunStrategy</code></pre><p>Parameters for running <a href="@ref"><code>fciqmc!()</code></a> for a fixed number of time steps. For alternative strategies, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/fciqmcrunstrategy.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftMemory" href="#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Effectively replaces the fluctuating <code>shift</code> update procedure for the coefficient vector by an averaged <code>shift</code> over <code>Δ</code> timesteps, where <code>Δ = 1</code> means no averaging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/memorystrategy.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftStrategy" href="#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for updating the <code>shift</code> with <a href="API.html#Rimu.update_shift"><code>update_shift()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.DontUpdate"><code>DontUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a> - default in <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!()</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>LogUpdateAfterTargetWalkers</code></a> - FCIQMC standard</li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>DoubleLogUpdateAfterTargetWalkers</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.SignCoherence" href="#Rimu.SignCoherence"><code>Rimu.SignCoherence</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SignCoherence(reference[; name=:coherence]) &lt;: PostStepStrategy</code></pre><p>After each step, compute the proportion of configurations that have the same sign as they do in the <code>reference_dvec</code>. Reports to a column named <code>name</code>, which defaults to <code>coherence</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/poststepstrategy.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TimeStepStrategy" href="#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeStepStrategy</code></pre><p>Abstract type for strategies for updating the time step with <a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>update_dτ()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.ConstantTimeStep"><code>ConstantTimeStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/timestepstrategy.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TripleLogUpdate" href="#Rimu.TripleLogUpdate"><code>Rimu.TripleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TripleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, η = 0.01) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the extended log formula with damping parameters <code>ζ</code>, <code>ξ</code>, and <code>η</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^n}\right)
- \frac{ξ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^\text{target}}\right)
- \frac{η}{dτ}\ln\left(\frac{\|ℜ(Ψ^{n+1})\|_1^2 + \|ℑ(Ψ^{n+1})\|_1^2}
{\|ℜ(Ψ^{n})\|_1^2 + \|ℑ(Ψ^{n})\|_1^2}\right),\]</p><p>where <span>$N_\mathrm{w}$</span> is the <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber()</code></a>. When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L165-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.WalkerLoneliness" href="#Rimu.WalkerLoneliness"><code>Rimu.WalkerLoneliness</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WalkerLoneliness(threshold=1) &lt;: PostStepStrategy</code></pre><p>After each step, compute the proportion of configurations that are occupied by at most <code>threshold</code> walkers. Reports to a column named <code>loneliness</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/poststepstrategy.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu._n_walkers-Tuple{Any, Any}" href="#Rimu._n_walkers-Tuple{Any, Any}"><code>Rimu._n_walkers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_n_walkers(v, s_strat)</code></pre><p>Returns an estimate of the expected number of walkers as an integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/lomc.jl#L70-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T" href="#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T"><code>Rimu.advance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">advance!(report::Report, state::QMCState, replica::ReplicaState)</code></pre><p>Advance the <code>replica</code> by one step. The <code>state</code> is used only to access the various strategies involved. Steps, stats, and computed quantities are written to the <code>report</code>.</p><p>Returns <code>true</code> if the step was successful and calculation should proceed, <code>false</code> when it should terminate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/lomc.jl#L298-L306">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.all_overlaps-Union{Tuple{N}, Tuple{Tuple, Tuple{Vararg{AbstractDVec, N}}}} where N" href="#Rimu.all_overlaps-Union{Tuple{N}, Tuple{Tuple, Tuple{Vararg{AbstractDVec, N}}}} where N"><code>Rimu.all_overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_overlaps(operators, vectors)</code></pre><p>Get all overlaps between vectors and operators. This function is overlpaded for <code>MPIData</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/replicastrategy.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}" href="#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.apply_memory_noise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r = apply_memory_noise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)</code></pre><p>Apply memory noise to <code>w</code>, i.e. <code>w .+= r.*v</code>, computing the noise <code>r</code> according to <code>m_strat</code>. Note that <code>m_strat</code> needs to be compatible with <code>StochasticStyle(w)</code>. Otherwise, an error exception is thrown. See <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a>.</p><p><code>w</code> is the walker array after fciqmc step, <code>v</code> the previous one, <code>pnorm</code> the norm of <code>v</code>, and <code>r</code> the instantaneously applied noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/apply_memory_noise.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}" href="#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.fciqmc_col!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fciqmc_col!(w, ham, add, num, shift, dτ)
fciqmc_col!(::Type{T}, args...)
-&gt; spawns, deaths, clones, antiparticles, annihilations</code></pre><p>Spawning and diagonal step of FCIQMC for single column of <code>ham</code>. In essence it computes</p><p><code>w .+= (1 .+ dτ.*(shift .- ham[:,add])).*num</code>.</p><p>Depending on <code>T ==</code><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle(w)</code></a>, a stochastic or deterministic algorithm will be chosen. The possible values for <code>T</code> are:</p><ul><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>IsDeterministic()</code></a> deteministic algorithm</li><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>IsStochasticInteger()</code></a> stochastic version where the changes added to <code>w</code> are purely integer, according to the FCIQMC algorithm</li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold(c)</code></a> stochastic algorithm with floating point walkers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/fciqmc_col.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_step!" href="#Rimu.fciqmc_step!"><code>Rimu.fciqmc_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;
                      m_strat::MemoryStrategy = NoMemory()) -&gt; ṽ, w̃, stats</code></pre><p>Perform a single matrix(/operator)-vector multiplication:</p><p class="math-container">\[\tilde{v} = [1 - dτ(\hat{H} - S)]⋅v ,\]</p><p>where <code>Ĥ == ham</code> and <code>S == shift</code>. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait <code>StochasticStyle(w)</code>. See <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>. <code>w</code> is a local data structure with the same size and type as <code>v</code> and used for working. Both <code>v</code> and <code>w</code> are modified.</p><p>Returns the result <code>ṽ</code>, a (possibly changed) reference to working memory <code>w̃</code>,  and the array <code>stats = [spawns, deaths, clones, antiparticles, annihilations]</code>. Stats will contain zeros when running in deterministic mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/fciqmc_step.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.finalize_report!-Tuple{ReportingStrategy, Any}" href="#Rimu.finalize_report!-Tuple{ReportingStrategy, Any}"><code>Rimu.finalize_report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">finalize_report!(::ReportingStrategy, report)</code></pre><p>Finalize the report. This function is called after all steps in <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> have finished.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.lomc!-Tuple{Any, Any}" href="#Rimu.lomc!-Tuple{Any, Any}"><code>Rimu.lomc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lomc!(ham::AbstractHamiltonian, [v]; kwargs...) -&gt; df, state
lomc!(state::QMCState, [df]; kwargs...) -&gt; df, state</code></pre><p>Linear operator Monte Carlo: Perform a projector quantum Monte Carlo simulation for determining the lowest eigenvalue of <code>ham</code>. <code>v</code> can be a single starting vector. The default choice is</p><pre><code class="language-julia hljs">v = DVec(starting_address(ham) =&gt; 10; style=IsStochasticInteger())</code></pre><p>and triggers the integer walker FCIQMC algorithm. See <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a> and <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p><p><strong>Keyword arguments, defaults, and precedence:</strong></p><ul><li><code>params::FciqmcRunStrategy = RunTillLastStep(laststep = 100, dτ = 0.01, shift = diagonal_element(ham, starting_address(ham)))</code> - basic parameters of simulation state, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>; is mutated</li><li><code>laststep</code> - can be used to override information otherwise contained in <code>params</code></li><li><code>s_strat::ShiftStrategy = DoubleLogUpdate(targetwalkers = 100, ζ = 0.08, ξ = ζ^2/4)</code> - how to update the <code>shift</code>, see <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a></li><li><code>maxlength = 2 * s_strat.targetwalkers + 100</code> - upper limit on the length of <code>v</code>; when reached, <code>lomc!</code> will abort</li><li><code>style = IsStochasticInteger()</code> - set <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> for default <code>v</code>; unused if <code>v</code> is specified.</li><li><code>post_step::NTuple{N,&lt;:PostStepStrategy} = ()</code> - extract observables (e.g. <a href="API.html#Rimu.ProjectedEnergy"><code>ProjectedEnergy</code></a>), see <a href="API.html#Rimu.PostStepStrategy"><code>PostStepStrategy</code></a>.</li><li><code>replica::ReplicaStrategy = NoStats(1)</code> - run several synchronised simulation, see <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a>.</li><li><code>r_strat::ReportingStrategy = ReportDFAndInfo()</code> - how and when to report results, see <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a></li><li><code>τ_strat::TimeStepStrategy = ConstantTimeStep()</code> - adjust time step dynamically, see <a href="API.html#Rimu.TimeStepStrategy"><code>TimeStepStrategy</code></a></li><li><code>m_strat::MemoryStrategy = NoMemory()</code> - experimental: inject memory noise, see <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a></li><li><code>threading = :auto</code> - can be used to control the use of multithreading (overridden by <code>wm</code>)<ul><li><code>:auto</code> - use multithreading if <code>s_strat.targetwalkers ≥ 500</code></li><li><code>true</code> - use multithreading if available (set shell variable <code>JULIA_NUM_THREADS</code>!)</li><li><code>false</code> - run on single thread</li></ul></li><li><code>wm</code> - working memory; if set, it controls the use of multithreading and overrides <code>threading</code>; is mutated</li><li><code>df = DataFrame()</code> - when called with <code>AbstractHamiltonian</code> argument, a <code>DataFrame</code> can be passed into <code>lomc!</code> that will be pushed into.</li></ul><p><strong>Return values</strong></p><p><code>lomc!</code> returns a named tuple with the following fields:</p><ul><li><code>df</code>: a <code>DataFrame</code> with all statistics being reported.</li><li><code>state</code>: a <code>QMCState</code> that can be used for continuations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; add = BoseFS((1,2,3));

julia&gt; hamiltonian = HubbardReal1D(add);

julia&gt; df1, state = lomc!(hamiltonian);

julia&gt; df2, _ = lomc!(state, df1; laststep=200); # Continuation run

julia&gt; size(df1)
(100, 12)

julia&gt; size(df2)
(200, 12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/lomc.jl#L190-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.post_step" href="#Rimu.post_step"><code>Rimu.post_step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">post_step(::PostStepStrategy, ::ReplicaState) -&gt; kvpairs</code></pre><p>Compute statistics after FCIQMC step. Should return a tuple of <code>:key =&gt; value</code> pairs. See also <a href="API.html#Rimu.PostStepStrategy"><code>PostStepStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/poststepstrategy.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.refine_r_strat-Tuple{ReportingStrategy}" href="#Rimu.refine_r_strat-Tuple{ReportingStrategy}"><code>Rimu.refine_r_strat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">refine_r_strat(r_strat::ReportingStrategy) -&gt; r_strat</code></pre><p>Initialize the reporting strategy. This can be used to set up filenames or other attributes that need to be unique for a run of FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.replica_stats" href="#Rimu.replica_stats"><code>Rimu.replica_stats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replica_stats(::ReplicaStrategy{N}, replicas::NTuple{N,ReplicaState}) -&gt; (names, values)</code></pre><p>Return the names and values of statistics reported by <code>ReplicaStrategy</code>. <code>names</code> should be a tuple of <code>Symbol</code>s or <code>String</code>s and <code>values</code> should be a tuple of the same length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/replicastrategy.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}" href="#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> report!(::ReportingStrategy, step, report::Report, keys, values, id=&quot;&quot;)
 report!(::ReportingStrategy, step, report::Report, nt, id=&quot;&quot;)</code></pre><p>Report <code>keys</code> and <code>values</code> to <code>report</code>, which will be converted to a <code>DataFrame</code> before <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> exits. Alternatively, a <code>nt::NamedTuple</code> can be passed in place of <code>keys</code> and <code>values</code>. If <code>id</code> is specified, it is appended to all <code>keys</code>. This is used to differentiate between values reported by different replicas.</p><p>To overload this function for a new <code>ReportingStrategy</code>, overload <code>report!(::ReportingStrategy, step, args...)</code> and apply the report by calling <code>report!(args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L109-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{Rimu.Report, Union{AbstractString, Symbol}, Any}" href="#Rimu.report!-Tuple{Rimu.Report, Union{AbstractString, Symbol}, Any}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">report!(report, keys, values, id=&quot;&quot;)
report!(report, pairs, id=&quot;&quot;)</code></pre><p>Write <code>keys</code>, <code>values</code> pairs to <code>report</code> that will be converted to a <code>DataFrame</code> later. Alternatively, a named tuple or a collection of pairs can be passed instead of <code>keys</code> and <code>values</code>.</p><p>The value of <code>id</code> is appended to the name of the column, e.g. <code>report!(report, :key, value, :_1)</code> will report <code>value</code> to a column named <code>:key_1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L31-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}" href="#Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>Rimu.report_after_step</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">report_after_step(::ReportingStrategy, step, report, state)</code></pre><p>This function is called exactly once at the very end of a step. For example, it can be used to print some information to <code>stdout</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/reportingstrategy.jl#L127-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.sort_into_targets!-Tuple{Any, Any, Any}" href="#Rimu.sort_into_targets!-Tuple{Any, Any, Any}"><code>Rimu.sort_into_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_into_targets!(target, source, stats) -&gt; agg, wm, agg_stats</code></pre><p>Aggregate coefficients from <code>source</code> to <code>agg</code> and from <code>stats</code> to <code>agg_stats</code> according to thread- or MPI-level parallelism. <code>wm</code> passes back a reference to working memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/helpers.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.step_stats-Tuple{StochasticStyle}" href="#Rimu.step_stats-Tuple{StochasticStyle}"><code>Rimu.step_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step_stats(::StochasticStyle)</code></pre><p>Return a tuple of names (<code>Symbol</code> or <code>String</code>) and a zeros of values of the same length. These will be reported as columns in the <code>DataFrame</code> returned by <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/fciqmc_col.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s322&quot;, false} where var&quot;#s322&quot;, Any, Any, Any, Any}" href="#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s322&quot;, false} where var&quot;#s322&quot;, Any, Any, Any, Any}"><code>Rimu.threshold_projected_deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">threshold_projected_deposit!</code></pre><p>This function performs threshold projection before spawning, but only for <code>IsDynamicSemistochastic</code> with the <code>project_later</code> parameter set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/fciqmc_col.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dvec!-Tuple{StochasticStyle, Any}" href="#Rimu.update_dvec!-Tuple{StochasticStyle, Any}"><code>Rimu.update_dvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_dvec!([::StochasticStyle,] dvec) -&gt; dvec, nt</code></pre><p>Perform an arbitrary transformation on <code>dvec</code> after the spawning step is completed and report statistics to the <code>DataFrame</code>.</p><p>Returns the new <code>dvec</code> and a <code>NamedTuple</code> <code>nt</code> of statistics to be reported.</p><p>When extending this function for a custom <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>, define a method  for the two-argument call signature!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/update_dvec.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}" href="#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.update_dτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_dτ(s&lt;:TimeStepStrategy, dτ, tnorm) -&gt; new dτ</code></pre><p>Update the time step according to the strategy <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/timestepstrategy.jl#L18-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_shift" href="#Rimu.update_shift"><code>Rimu.update_shift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_shift(s &lt;: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df, v_new, v_old)</code></pre><p>Update the shift according to strategy <code>s</code>. See <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/strategies_and_params/shiftstrategy.jl#L13-L16">source</a></section></article><h1 id="Reexported-Submodules"><a class="docs-heading-anchor" href="#Reexported-Submodules">Reexported Submodules</a><a id="Reexported-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Reexported-Submodules" title="Permalink"></a></h1><h2 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h2><p>Link to <a href="hamiltonians.html#Module-Hamiltionians.jl">Module <code>Hamiltionians.jl</code></a></p><h2 id="BitStringAddresses"><a class="docs-heading-anchor" href="#BitStringAddresses">BitStringAddresses</a><a id="BitStringAddresses-1"></a><a class="docs-heading-anchor-permalink" href="#BitStringAddresses" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.AbstractFockAddress" href="#Rimu.BitStringAddresses.AbstractFockAddress"><code>Rimu.BitStringAddresses.AbstractFockAddress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractFockAddress</code></pre><p>Supertype representing a Fock state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BitString" href="#Rimu.BitStringAddresses.BitString"><code>Rimu.BitStringAddresses.BitString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BitString{B,N,T&lt;:Unsigned}</code></pre><p>Type for storing bitstrings of static size. Holds <code>B</code> bits in <code>N</code> chunks, where each chunk is of type <code>T</code>.</p><p><code>N</code> is chosen automatically to accommodate <code>B</code> bits as efficiently as possible.</p><p><strong>Constructors</strong></p><ul><li><p><code>BitString{B,N,T}(::SVector{N,T})</code>: unsafe constructor. Does not check for ghost bits.</p></li><li><p><code>BitString{B,N,T}(i::T)</code>: as above, but sets <code>i</code> as the rightmost chunk.</p></li><li><p><code>BitString{B}(::Integer)</code>: Convert integer to <code>BitString</code>. Integer is truncated to the correct number of bits.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L46-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS" href="#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseFS{N,M,S} &lt;: SingleComponentFockAddress</code></pre><p>Address type that represents a Fock state of <code>N</code> spinless bosons in <code>M</code> modes by wrapping a bitstring of type <code>S &lt;: BitString</code>.</p><p><strong>Constructors</strong></p><ul><li><p><code>BoseFS{N,M}(bs::BitString)</code>: Unsafe constructor. Does not check whether the number of particles in <code>bs</code> is equal to <code>N</code>.</p></li><li><p><code>BoseFS(::BitString)</code>: Automatically determine <code>N</code> and <code>M</code>. This constructor is not type stable!</p></li><li><p><code>BoseFS{[N,M,S]}(onr)</code>: Create <code>BoseFS{N,M}</code> from <a href="API.html#Rimu.BitStringAddresses.onr-Tuple{BoseFS}"><code>onr</code></a> representation. This is efficient as long as at least <code>N</code> is provided.</p></li></ul><p>See also: <a href="API.html#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>SingleComponentFockAddress</code></a>, <a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>, <a href="API.html#Rimu.BitStringAddresses.BitString"><code>BitString</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bosefs.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS2C" href="#Rimu.BitStringAddresses.BoseFS2C"><code>Rimu.BitStringAddresses.BoseFS2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseFS2C{NA,NB,M,AA,AB} &lt;: AbstractFockAddress</code></pre><p>Address type that constructed with two <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS{N,M,S}</code></a>. It represents a Fock state with two components, e.g. two different species of bosons with particle number <code>NA</code> from species S and particle number <code>NB</code> from species B. The number of modes <code>M</code> is expected to be the same for both components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/multicomponent.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFSIndex" href="#Rimu.BitStringAddresses.BoseFSIndex"><code>Rimu.BitStringAddresses.BoseFSIndex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseFSIndex</code></pre><p>Convenience struct for indexing into a <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>.</p><p><strong>Fields:</strong></p><ul><li><code>occnum</code>: the occupation number.</li><li><code>mode</code>: the index of the mode.</li><li><code>offset</code>: the bit offset of the mode.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bosefs.jl#L248-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.CompositeFS" href="#Rimu.BitStringAddresses.CompositeFS"><code>Rimu.BitStringAddresses.CompositeFS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeFS(addresses::SingleComponentFockAddress...) &lt;: AbstractFockAddress</code></pre><p>Used to encode addresses for multi-component models. All component addresses are expected have the same number of modes <code>M</code>.</p><p>See also: <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>, <a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>, <a href="API.html#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>SingleComponentFockAddress</code></a>, <a href="API.html#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}"><code>num_modes</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/multicomponent.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.FermiFS" href="#Rimu.BitStringAddresses.FermiFS"><code>Rimu.BitStringAddresses.FermiFS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FermiFS{N,M,S} &lt;: SingleComponentFockAddress</code></pre><p>Address type that represents a Fock state of <code>N</code> fermions of the same spin in <code>M</code> modes by wrapping a bitstring of type <code>S &lt;: BitString</code>.</p><p><strong>Constructors</strong></p><ul><li><p><code>FermiFS{N,M}(bs::BitString)</code>: Unsafe constructor. Does not check whether the number of particles in <code>bs</code> is equal to <code>N</code>.</p></li><li><p><code>FermiFS(::BitString)</code>: Automatically determine <code>N</code> and <code>M</code>. This constructor is not type stable!</p></li><li><p><code>FermiFS{[N,M,S]}(onr)</code>: Create <code>FermiFS{N,M}</code> from <a href="API.html#Rimu.BitStringAddresses.onr-Tuple{BoseFS}"><code>onr</code></a> representation. This is efficient as long as at least <code>N</code> is provided.</p></li></ul><p>See also: <a href="API.html#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>SingleComponentFockAddress</code></a>, <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>, <a href="API.html#Rimu.BitStringAddresses.BitString"><code>BitString</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fermifs.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.FermiOccupiedModes" href="#Rimu.BitStringAddresses.FermiOccupiedModes"><code>Rimu.BitStringAddresses.FermiOccupiedModes</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FermiOccupiedModes</code></pre><p>Iterator over occupied modes in address. See <a href="API.html#Rimu.BitStringAddresses.occupied_modes"><code>occupied_modes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fermifs.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.SingleComponentFockAddress" href="#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>Rimu.BitStringAddresses.SingleComponentFockAddress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SingleComponentFockAddress{M}</code></pre><p>A type representing a single component Fock state with <code>M</code> modes.</p><p>Implemented subtypes: <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>, <a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>.</p><p><strong>Supported functionality</strong></p><ul><li><a href="API.html#Rimu.BitStringAddresses.find_mode"><code>find_mode</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.find_occupied_mode"><code>find_occupied_mode</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_occupied_modes"><code>num_occupied_modes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.occupied_modes"><code>occupied_modes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.move_particle"><code>move_particle</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L34-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}, Type{UInt64}}} where {B, N}" href="#Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}, Type{UInt64}}} where {B, N}"><code>Rimu.BitStringAddresses.check_bitstring_typeparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_bitstring_typeparams(::Val{B}, ::Val{N})</code></pre><p>Check if number of bits <code>B</code> is consistent with number of chunks <code>N</code>. Throw an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}" href="#Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}"><code>Rimu.BitStringAddresses.chunk_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chunks_bits(::Type{&lt;:BitString}, i)
chunks_bits(s, i)</code></pre><p>Number of bits in the <code>i</code>-th chunk of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.chunk_type-Union{Tuple{Type{var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(BitString{var&quot;#s5&quot;, var&quot;#s1&quot;, T} where {var&quot;#s5&quot;, var&quot;#s1&quot;})}, Tuple{T}} where T" href="#Rimu.BitStringAddresses.chunk_type-Union{Tuple{Type{var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(BitString{var&quot;#s5&quot;, var&quot;#s1&quot;, T} where {var&quot;#s5&quot;, var&quot;#s1&quot;})}, Tuple{T}} where T"><code>Rimu.BitStringAddresses.chunk_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chunk_type(::Type{&lt;:BitString})
chunk_type(s::BitString)</code></pre><p>Type of unsigned integer used to store the chunks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.chunks-Tuple{BitString}" href="#Rimu.BitStringAddresses.chunks-Tuple{BitString}"><code>Rimu.BitStringAddresses.chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chunks(s::BitString)</code></pre><p><code>SVector</code> that stores the chunks of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.find_mode" href="#Rimu.BitStringAddresses.find_mode"><code>Rimu.BitStringAddresses.find_mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_mode(::SingleComponentFockAddress, i)</code></pre><p>Find the <code>i</code>-th mode in address. Returns <a href="API.html#Rimu.BitStringAddresses.BoseFSIndex"><code>BoseFSIndex</code></a> for <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>, and an integer for <a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; find_mode(BoseFS((1, 0, 2)), 2)
3-element Rimu.BitStringAddresses.BoseFSIndex with indices SOneTo(3):
 0
 2
 2

julia&gt; find_mode(FermiFS((1, 1, 1, 0)), 2)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L54-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.find_occupied_mode" href="#Rimu.BitStringAddresses.find_occupied_mode"><code>Rimu.BitStringAddresses.find_occupied_mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_occupied_mode(::SingleComponentFockAddress, k)</code></pre><p>Find the <code>k</code>-th occupied mode in address. Returns <a href="API.html#Rimu.BitStringAddresses.BoseFSIndex"><code>BoseFSIndex</code></a> for <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>, and an integer for <a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; find_occupied_mode(BoseFS((1, 0, 2)), 2)
3-element Rimu.BitStringAddresses.BoseFSIndex with indices SOneTo(3):
 2
 3
 3

julia&gt; find_occupied_mode(FermiFS((1, 1, 1, 0)), 2)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L73-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString" href="#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.has_ghost_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_ghost_bits(s::BitString)</code></pre><p>Check for bits outside data field.</p><p>See also: <a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString"><code>remove_ghost_bits</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L161-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}" href="#Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.m_onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">m_onr(bs)</code></pre><p>Compute and return the occupation number representation of the bit string address <code>bs</code> as an <code>MVector{M,Int32}</code>, where <code>M</code> is the number of modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bosefs.jl#L159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.move_particle" href="#Rimu.BitStringAddresses.move_particle"><code>Rimu.BitStringAddresses.move_particle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move_particle(add::SingleComponentFockAddress, i, j) -&gt; nadd, α</code></pre><p>Move particle from mode <code>i</code> to mode <code>j</code>. Equivalent to <span>$a^{\dagger}_i a_j |add\rangle$</span>. Returns the new Fock state address <code>nadd</code> and integer <code>α</code>. For <code>FermiFS</code> the factor <code>α</code> is the correct (signed) amplitude, whereas for <code>BoseFS</code> the correct amplitude is <span>$\sqrt{α}$</span>.</p><p>Note that the modes in <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a> are indexed by <a href="API.html#Rimu.BitStringAddresses.BoseFSIndex"><code>BoseFSIndex</code></a>, while the ones in <a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a> are indexed by integers (see example below).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = BoseFS((1, 1, 3, 0))
BoseFS{5,4}((1, 1, 3, 0))

julia&gt; i = find_occupied_mode(b, 2)
3-element Rimu.BitStringAddresses.BoseFSIndex with indices SOneTo(3):
 1
 2
 2

julia&gt; j = find_mode(b, i.mode + 1)
3-element Rimu.BitStringAddresses.BoseFSIndex with indices SOneTo(3):
 3
 3
 4

julia&gt; move_particle(b, i, j)
(BoseFS{5,4}((1, 0, 4, 0)), 2.0)

julia&gt; move_particle(b, j, j)
(BoseFS{5,4}((1, 1, 3, 0)), 3.0)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; f = FermiFS((1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0))
FermiFS{7,12}((1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0))

julia&gt; i = find_occupied_mode(f, 2)
6

julia&gt; move_particle(f, i, i + 1)
(FermiFS{7,12}((1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0)), 0.0)

julia&gt; move_particle(f, i, i - 1)
(FermiFS{7,12}((1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0)), 1.0)

julia&gt; move_particle(f, i, 12)
(FermiFS{7,12}((1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1)), -1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L143-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.near_uniform-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BoseFS{N, M, S} where S&lt;:BitString)}, Tuple{M}, Tuple{N}} where {N, M}" href="#Rimu.BitStringAddresses.near_uniform-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BoseFS{N, M, S} where S&lt;:BitString)}, Tuple{M}, Tuple{N}} where {N, M}"><code>Rimu.BitStringAddresses.near_uniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">near_uniform(BoseFS{N,M})
near_uniform(BoseFS{N,M,S}) -&gt; bfs::BoseFS{N,M,S}</code></pre><p>Create bosonic Fock state with near uniform occupation number of <code>M</code> modes with a total of <code>N</code> particles. Specifying the bit address type <code>S</code> is optional.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; near_uniform(BoseFS{7,5,BitString{14}})
BoseFS((2,2,1,1,1))

julia&gt; near_uniform(BoseFS{7,5})
BoseFS((2,2,1,1,1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bosefs.jl#L128-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.near_uniform_onr-Tuple{Number, Number}" href="#Rimu.BitStringAddresses.near_uniform_onr-Tuple{Number, Number}"><code>Rimu.BitStringAddresses.near_uniform_onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">near_uniform_onr(N, M) -&gt; onr::SVector{M,Int}</code></pre><p>Create occupation number representation <code>onr</code> distributing <code>N</code> particles in <code>M</code> modes in a close-to-uniform fashion with each mode filled with at least <code>N ÷ M</code> particles and at most with <code>N ÷ M + 1</code> particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bosefs.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N, T} where {N, T&lt;:Unsigned})}, Tuple{B}} where B" href="#Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N, T} where {N, T&lt;:Unsigned})}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_bits(::Type{&lt;:BitString})
num_bits(s::BitString)</code></pre><p>Total number of bits stored in bitstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(BitString{var&quot;#s6&quot;, N, T} where {var&quot;#s6&quot;, T&lt;:Unsigned})}, Tuple{N}} where N" href="#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(BitString{var&quot;#s6&quot;, N, T} where {var&quot;#s6&quot;, T&lt;:Unsigned})}, Tuple{N}} where N"><code>Rimu.BitStringAddresses.num_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_chunks(::Type{&lt;:BitString})
num_chunks(s::BitString)</code></pre><p>Number of chunks in bitstring. Equivalent to <code>length(chunks(s))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B" href="#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_chunks(::Val{B})</code></pre><p>Determine the number and type of chunks needed to store <code>B</code> bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_components-Tuple{AbstractFockAddress}" href="#Rimu.BitStringAddresses.num_components-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_components</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_components(::Type{&lt;:AbstractFockAddress})
num_components(::AbstractFockAddress)</code></pre><p>Number of components in address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L26-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}" href="#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_modes(::Type{&lt;:AbstractFockAddress})
num_modes(::AbstractFockAddress)</code></pre><p>Number of modes represented by address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_occupied_modes" href="#Rimu.BitStringAddresses.num_occupied_modes"><code>Rimu.BitStringAddresses.num_occupied_modes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_occupied_modes(::SingleComponentFockAddress)</code></pre><p>Get the number of occupied modes in address. Equivalent to <code>length(</code><a href="API.html#Rimu.BitStringAddresses.occupied_modes"><code>occupied_modes</code></a><code>(address))</code>, or the number of non-zeros in its ONR representation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; num_occupied_modes(BoseFS((1, 0, 2)))
2
julia&gt; num_occupied_modes(FermiFS((1, 1, 1, 0)))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L94-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}" href="#Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_particles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">num_particles(::Type{&lt;:AbstractFockAddress})
num_particles(::AbstractFockAddress)</code></pre><p>Number of particles represented by address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.occupied_modes" href="#Rimu.BitStringAddresses.occupied_modes"><code>Rimu.BitStringAddresses.occupied_modes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">occupied_modes(::SingleComponentFockAddress)</code></pre><p>Iterate over all occupied modes in an address. Iterates <a href="API.html#Rimu.BitStringAddresses.BoseFSIndex"><code>BoseFSIndex</code></a> for <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>, and an integers for <a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; b = BoseFS((1,5,0,4))
julia&gt; for (n, i, m) in occupied_modes(b)
    @show n, i, m
end
(n, i, m) = (1, 1, 0)
(n, i, m) = (5, 2, 2)
(n, i, m) = (4, 4, 9)</code></pre><pre><code class="language-julia-repl hljs">julia&gt; f = FermiFS((1,1,0,1,0,0,1))
julia&gt; for i in occupied_modes(f)
    @show i
end
i = 1
i = 2
i = 4
i = 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/fockaddress.jl#L112-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.onr-Tuple{BoseFS}" href="#Rimu.BitStringAddresses.onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">onr(bs)</code></pre><p>Compute and return the occupation number representation of the bit string address <code>bs</code> as an <code>SVector{M,Int32}</code>, where <code>M</code> is the number of modes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bosefs.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.partial_left_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned" href="#Rimu.BitStringAddresses.partial_left_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned"><code>Rimu.BitStringAddresses.partial_left_shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partial_left_shift(bs::BitString, i, j)</code></pre><p>Shift a part of the bitstring left by one place with boundaries <code>i &lt; j</code>. In a <code>BoseFS</code> bitstring, it moves a particle at offset <code>i</code> to the position at offset <code>j</code>.</p><p>See also: <a href="API.html#Rimu.BitStringAddresses.move_particle"><code>move_particle</code></a>, <a href="API.html#Rimu.BitStringAddresses.partial_right_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned"><code>partial_right_shift</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L333-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.partial_right_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned" href="#Rimu.BitStringAddresses.partial_right_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned"><code>Rimu.BitStringAddresses.partial_right_shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partial_right_shift(bs::BitString, i, j)</code></pre><p>Shift a part of the bitstring right by one place with boundaries <code>i &lt; j</code>. In a <code>BoseFS</code> bitstring, it moves a particle at offset <code>j</code> to the position at offset <code>i</code>.</p><p>See also: <a href="API.html#Rimu.BitStringAddresses.partial_left_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned"><code>partial_left_shift</code></a>, <a href="API.html#Rimu.BitStringAddresses.move_particle"><code>move_particle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L355-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString" href="#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">remove_ghost_bits(s::BitString)</code></pre><p>Remove set bits outside data field if any are present.</p><p>See also: <a href="API.html#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString"><code>has_ghost_bits</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N, T} where {N, T&lt;:Unsigned})}, Tuple{B}} where B" href="#Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N, T} where {N, T&lt;:Unsigned})}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.top_chunk_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">top_chunk_bits(::Type{&lt;:BitString})
top_chunk_bits(s::BitString)</code></pre><p>Number of bits stored in top chunk. Equivalent to <code>chunk_bits(s, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/bitstring.jl#L105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.update_component-Union{Tuple{I}, Tuple{CompositeFS, Any, Val{I}}} where I" href="#Rimu.BitStringAddresses.update_component-Union{Tuple{I}, Tuple{CompositeFS, Any, Val{I}}} where I"><code>Rimu.BitStringAddresses.update_component</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_component(c::CompositeFS, new, ::Val{i})</code></pre><p>Replace the <code>i</code>-th component in <code>c</code> with <code>new</code>. Used for updating a single component in the address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/BitStringAddresses/multicomponent.jl#L73-L78">source</a></section></article><h2 id="DictVectors"><a class="docs-heading-anchor" href="#DictVectors">DictVectors</a><a id="DictVectors-1"></a><a class="docs-heading-anchor-permalink" href="#DictVectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors" href="#Rimu.DictVectors"><code>Rimu.DictVectors</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to <code>AbstractVector</code> nor to <code>AbstractDict</code> and are suitable for use with <code>KrylovKit.jl</code>. For this, the abstract type and interface <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a> is provided, with the concrete implementation of <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/DictVectors.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractDVec" href="#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DictVectors.AbstractDVec{K,V}</code></pre><p>Abstract type for sparse vectors with <code>valtype</code> <code>V</code> based on dictionary-like structures. The vectors are designed to work well with FCIQMC and <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a>.</p><p>They lie somewhere between <code>AbstractDict</code>s and sparse <code>AbstractVector</code>s, generally behaving like a dictionary, while supportting various linear algebra functionality. Indexing with a value not stored in the dictionary returns <code>zero(V)</code>. Setting a stored value to 0 or below <code>eps(V::AbstractFloat)</code> removes the value from the dictionary. Their <code>length</code> signals the number of stored elements, not the size of the vector space.</p><p>They have a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> which selects the spawning algorithm in <code>FCIQMC</code>.</p><p>To iterate over an <code>AbstractDVec</code>, use <code>pairs</code> or <code>values</code>.</p><p><strong>Interface</strong></p><p>The interface is similar to the <code>AbstractDict</code> interface.</p><p>Implement what would be needed for the <code>AbstractDict</code> interface (<code>pairs</code>, <code>keys</code>, <code>values</code>, <code>setindex!, getindex, delete!, length, haskey, empty!, isempty</code>) and, in addition:</p><ul><li><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a></li><li><a href="API.html#Rimu.DictVectors.storage"><code>storage(dv)</code></a> returns an <code>AbstractDict</code> storing the raw data with possibly different <code>valtype</code> than <code>V</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractProjector" href="#Rimu.DictVectors.AbstractProjector"><code>Rimu.DictVectors.AbstractProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for projectors to be used in in lieu of DVecs or Vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L214-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.CoherentInitiator" href="#Rimu.DictVectors.CoherentInitiator"><code>Rimu.DictVectors.CoherentInitiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CoherentInitiator(threshold) &lt;: InitiatorRule</code></pre><p>Initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li><p>Initiators can spawn anywhere.</p></li><li><p>Non-initiators can spawn to initiators.</p></li><li><p>Multiple non-initiators can spawn to a single non-initiator if their contributions add up to a value greater than the initiator threshold.</p><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L98-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.DVec" href="#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DVec{K,V,D&lt;:AbstractDict{K,V},S}</code></pre><p>Dictionary-based vector-like data structure for use with FCIQMC and <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a>. While mostly behaving like a <code>Dict</code>, it supports various linear algebra operations such as <code>norm</code> and <code>dot</code>. It has a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> that is used to select an appropriate spawning strategy in the FCIQMC algorithm.</p><p>See also: <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>.</p><p><strong>Constructors</strong></p><ul><li><p><code>DVec(dict::AbstractDict[; style, capacity])</code>: create a <code>DVec</code> with <code>dict</code> for storage. Note that the data may or may not be copied.</p></li><li><p><code>DVec(args...[; style, capacity])</code>: <code>args...</code> are passed to the <code>Dict</code> constructor. The <code>Dict</code> is used for storage.</p></li><li><p><code>DVec{K,V}([; style, capacity])</code>: create an empty <code>DVec{K,V}</code>.</p></li><li><p><code>DVec(dv::AbstractDVec[; style, capacity])</code>: create a <code>DVec</code> with the same contents as  <code>adv</code>. The <code>style</code> is inherited from <code>dv</code> by default.</p></li></ul><p>The default <code>style</code> is selected based on the <code>DVec</code>&#39;s <code>valtype</code> (see <a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>default_style</code></a>). If a style is given and the <code>valtype</code> does not match the <code>style</code>&#39;s <code>eltype</code>, the values are converted to an appropriate type.</p><p>The capacity argument is optional and sets the initial size of the <code>DVec</code> via <code>sizehint!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dv = DVec(:a =&gt; 1)
DVec{Symbol,Int64} with 1 entries, style = IsStochasticInteger{Int64}()
  :a =&gt; 1

julia&gt; dv = DVec(:a =&gt; 2, :b =&gt; 3; style=IsDynamicSemistochastic())
DVec{Symbol,Float32} with 2 entries, style = IsDynamicSemistochastic{Float64, true}(1.0, Inf, 1.0)
  :a =&gt; 2.0
  :b =&gt; 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/dvec.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.FrozenDVec" href="#Rimu.DictVectors.FrozenDVec"><code>Rimu.DictVectors.FrozenDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FrozenDVec</code></pre><p>See: <a href="API.html#OrderedCollections.freeze-Tuple{Any}"><code>freeze</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Initiator" href="#Rimu.DictVectors.Initiator"><code>Rimu.DictVectors.Initiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Initiator(threshold) &lt;: InitiatorRule</code></pre><p>Initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li>Initiators can spawn anywhere.</li><li>Non-initiators can spawn to initiators.</li></ul><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorDVec" href="#Rimu.DictVectors.InitiatorDVec"><code>Rimu.DictVectors.InitiatorDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorDVec{K,V} &lt;: AbstractDVec{K,V}</code></pre><p>Dictionary-based vector-like data structure for use with <a href="@ref"><code>lomc!</code></a> and <a href="https://github.com/Jutho/KrylovKit.jl"><code>KrylovKit.jl</code></a>. See <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>. Functionally identical to <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a>, but contains <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a>s internally in order to facilitate initiator methods. How the initiators are handled is controlled by the <code>initiator</code> keyword argument (see below).</p><p><strong>Constructors</strong></p><ul><li><p><code>InitiatorDVec(dict::AbstractDict[; style, initiator, capacity])</code>: create an <code>InitiatorDVec</code> with <code>dict</code> for storage.  Note that the data may or may not be copied.</p></li><li><p><code>InitiatorDVec(args...[; style, initiator, capacity])</code>: <code>args...</code> are passed to the <code>Dict</code> constructor. The <code>Dict</code> is used for storage.</p></li><li><p><code>InitiatorDVec{K,V}([; style, initiator, capacity])</code>: create an empty <code>InitiatorDVec{K,V}</code>.</p></li><li><p><code>InitiatorDVec(dv::AbstractDVec[; style, initiator, capacity])</code>: create an <code>InitiatorDVec</code>  with the same contents as <code>dv</code>. The <code>style</code> is inherited from <code>dv</code> by default.</p></li></ul><p><strong>Keyword  arguments</strong></p><ul><li><p><code>style</code>: A valid <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.  The default is selected based on the <code>InitiatorDVec</code>&#39;s <a href="@ref"><code>valtype</code></a> (see <a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>default_style</code></a>). If a style is given and the <code>valtype</code> does not match the <code>style</code>&#39;s <code>eltype</code>, the values are converted to an appropriate type.</p></li><li><p><code>initiator = Initiator(1)</code>: A valid <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>. See <a href="API.html#Rimu.DictVectors.Initiator"><code>Initiator</code></a>.</p></li><li><p><code>capacity</code>: Indicative size as <code>Int</code>. Optional. Sets the initial size of the <code>InitiatorDVec</code> via <a href="@ref"><code>sizehint!</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L125-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorIterator" href="#Rimu.DictVectors.InitiatorIterator"><code>Rimu.DictVectors.InitiatorIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorIterator</code></pre><p>Iterator over pairs or values of an <code>InitiatorDVec</code>. Supports the <code>SplittablesBase</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L304-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorRule" href="#Rimu.DictVectors.InitiatorRule"><code>Rimu.DictVectors.InitiatorRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorRule{V}</code></pre><p>Abstract type for defining initiator rules for <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. Concrete implementations:</p><ul><li><a href="API.html#Rimu.DictVectors.Initiator"><code>Initiator</code></a></li><li><a href="API.html#Rimu.DictVectors.SimpleInitiator"><code>SimpleInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.CoherentInitiator"><code>CoherentInitiator</code></a></li></ul><p>When defining a new <code>InitiatorRule</code>, also define a corresponding method for <a href="API.html#Rimu.DictVectors.value"><code>value</code></a>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorValue" href="#Rimu.DictVectors.InitiatorValue"><code>Rimu.DictVectors.InitiatorValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InitiatorValue{V}(; safe::V, unsafe::V, initiator::V) where V</code></pre><p>Composite &quot;walker&quot; with three fields. For use with <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsDeterministic" href="#Rimu.DictVectors.IsDeterministic"><code>Rimu.DictVectors.IsDeterministic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsDeterministic{T=Float64}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configuration indicating deterministic propagation of walkers.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsDynamicSemistochastic" href="#Rimu.DictVectors.IsDynamicSemistochastic"><code>Rimu.DictVectors.IsDynamicSemistochastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsDynamicSemistochastic{T=Float64}(rel_threshold=1, abs_threshold=Inf, proj_threshold=1) &lt;: StochasticStyle{T}</code></pre><p>QMC propagation with non-integer walker numbers and reduced noise. All possible spawns are performed deterministically when number of walkers in a configuration is high. Stochastic vector compression with threshold <code>proj_threshold</code> is applied after spawning and diagonal death steps.</p><p>Unlike with <a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a>, when <code>late_projection</code> is set to <code>true</code>, walker annihilation is done before the stochastic vector compression.</p><p><strong>Parameters:</strong></p><ul><li><p><code>late_projection = true</code>: If set to true, threshold projection is done after all spawns are collected, otherwise, values are projected as they are being spawned.</p></li><li><p><code>rel_threshold = 1.0</code>: If the walker number on a configuration times this threshold is greater than the number of offdiagonals, spawning is done deterministically. Should be set to 1 or more for best performance.</p></li><li><p><code>abs_threshold = Inf</code>: If the walker number on a configuration is greater than this value, spawning is done deterministically. Can be set to e.g <code>abs_threshold = 0.1 * target_walkers</code>.</p></li><li><p><code>proj_threshold = 1.0</code>: Values below this number are stochastically projected to this value or zero. See also <a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a>.</p></li></ul><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L86-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochastic2Pop" href="#Rimu.DictVectors.IsStochastic2Pop"><code>Rimu.DictVectors.IsStochastic2Pop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsStochastic2Pop{T=Complex{Int}}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of integer walkers.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochasticInteger" href="#Rimu.DictVectors.IsStochasticInteger"><code>Rimu.DictVectors.IsStochasticInteger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsStochasticInteger{T=Int}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation as seen in the original FCIQMC algorithm.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochasticWithThreshold" href="#Rimu.DictVectors.IsStochasticWithThreshold"><code>Rimu.DictVectors.IsStochasticWithThreshold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IsStochasticWithThreshold(threshold=1.0) &lt;: StochasticStyle</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff <code>threshold</code>.</p><p>During stochastic propagation, walker numbers small than <code>threshold</code> will be stochastically projected to either zero or <code>threshold</code>.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Norm1ProjectorPPop" href="#Rimu.DictVectors.Norm1ProjectorPPop"><code>Rimu.DictVectors.Norm1ProjectorPPop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Norm1ProjectorPPop()</code></pre><p>Results in computing the one-norm per population when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(Norm1ProjectorPPop(),x)
-&gt; norm(real.(x),1) + im*norm(imag.(x),1)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L271-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Norm2Projector" href="#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Norm2Projector()</code></pre><p>Results in computing the two-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(NormProjector(),x)
-&gt; norm(x,2) # with type Float64</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L254-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.NormProjector" href="#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NormProjector()</code></pre><p>Results in computing the one-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(NormProjector(),x)
-&gt; norm(x,1)</code></pre><p><code>NormProjector()</code> thus represents the vector <code>sign.(x)</code>.</p><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L238-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.PopsProjector" href="#Rimu.DictVectors.PopsProjector"><code>Rimu.DictVectors.PopsProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PopsProjector()</code></pre><p>Results in computing the projection of one population on the other when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia hljs">dot(PopsProjector(),x)
-&gt; real(x) ⋅ imag(x)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L299-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.SimpleInitiator" href="#Rimu.DictVectors.SimpleInitiator"><code>Rimu.DictVectors.SimpleInitiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleInitiator(threshold) &lt;: InitiatorRule</code></pre><p>Simplified initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li>Initiators can spawn anywhere.</li><li>Non-initiators cannot spawn.</li></ul><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L78-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.StochasticStyle" href="#Rimu.DictVectors.StochasticStyle"><code>Rimu.DictVectors.StochasticStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochasticStyle(v)</code></pre><p>Abstract type. When called as a function it returns the native style of the generalised vector <code>v</code> that determines how simulations are to proceed.</p><p><strong>Implemented styles</strong></p><ul><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>IsStochasticInteger</code></a> - integer walker FCIQMC</li><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>IsDeterministic</code></a> - perform deterministic variant of power method</li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a> - floating point walker FCIQMC</li><li><a href="API.html#Rimu.DictVectors.IsDynamicSemistochastic"><code>IsDynamicSemistochastic</code></a></li></ul><p><strong>Usage</strong></p><p>Concrete <code>StochasticStyle</code>s can be used for the <code>style</code> keyword argument of <a href="@ref"><code>lomc!</code></a> and <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a>.</p><p><strong>Interface</strong></p><p>When defining a new <code>StochasticStyle</code>, subtype it as <code>MyStyle&lt;:StochasticStyle{T}</code> where <code>T</code> is the concrete value type the style is designed to work with.</p><p>For it to work with <a href="@ref"><code>lomc!</code></a>, a <code>StochasticStyle</code> must define the following:</p><ul><li><a href="@ref"><code>fciqmc_col!(::StochasticStyle, w, H, address, value, shift, dτ)</code></a></li><li><a href="@ref"><code>step_stats(::StochasticStyle)</code></a></li></ul><p>Optionally, it can also define <a href="@ref"><code>update_dvec!</code></a>, which can be used to perform arbitrary transformations on the generalised vector after the spawning step is complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L1-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.StyleUnknown" href="#Rimu.DictVectors.StyleUnknown"><code>Rimu.DictVectors.StyleUnknown</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StyleUnknown{T}() &lt;: StochasticStyle</code></pre><p>Trait for value types not (currently) compatible with FCIQMC. This style makes it possible to construct dict vectors with unsupported <code>valtype</code>s.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L33-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.UniformProjector" href="#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UniformProjector()</code></pre><p>Represents a vector with all elements 1. To be used with <a href="@ref"><code>dot()</code></a>. Minimizes memory allocations.</p><pre><code class="language-julia hljs">UniformProjector()⋅v == sum(v)
dot(UniformProjector(), LO, v) == sum(LO*v)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L219-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OrderedCollections.freeze-Tuple{Any}" href="#OrderedCollections.freeze-Tuple{Any}"><code>OrderedCollections.freeze</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">freeze(dv)</code></pre><p>Create a &quot;frozen&quot; version of <code>dv</code> which can no longer be modified or used in the conventional manner, but supports faster dot products.</p><p>If <code>dv</code> is an <a href="@ref"><code>MPIData</code></a>, synchronize its contents among the ranks first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L356-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K" href="#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K"><code>Rimu.DictVectors.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add!(x::AbstractDVec,y::AbstactDVec)</code></pre><p>Inplace add <code>x+y</code> and store result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer" href="#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Rimu.DictVectors.default_style</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_style(::Type)</code></pre><p>Pick a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> based on the value type. Throws an error if no known default style is known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/stochasticstyle.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.deposit!-NTuple{4, Any}" href="#Rimu.DictVectors.deposit!-NTuple{4, Any}"><code>Rimu.DictVectors.deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deposit!(w::AbstractDVec, add, val, parent::Pair)</code></pre><p>Add <code>val</code> into <code>w</code> at address <code>add</code>, taking into account initiator rules if applicable. <code>parent</code> contains the <code>address =&gt; value</code> pair from which the pair <code>add =&gt; val</code> was created. <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a> can intercept this and add its own functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V" href="#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V"><code>Rimu.DictVectors.deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deposit!(w::InitiatorDVec, add, val, p_add=&gt;p_val)</code></pre><p>Add <code>val</code> into <code>w</code> at address <code>add</code> as an <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L266-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.localpart-Tuple{Any}" href="#Rimu.DictVectors.localpart-Tuple{Any}"><code>Rimu.DictVectors.localpart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">localpart(dv) -&gt; AbstractDVec</code></pre><p>Get the part of <code>dv</code> that is located on this MPI rank. Returns <code>dv</code> itself for <code>DictVector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L336-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.storage" href="#Rimu.DictVectors.storage"><code>Rimu.DictVectors.storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">storage(dvec) -&gt; AbstractDict</code></pre><p>Return the raw storage associated with <code>dvec</code> as an <code>AbstractDict</code>. Used in MPI communication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.value" href="#Rimu.DictVectors.value"><code>Rimu.DictVectors.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">value(i::InitiatorRule, v::InitiatorValue)</code></pre><p>Convert the <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a> <code>v</code> into a scalar value according to the <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a> <code>i</code>.</p><p>Internal function that implements functionality of <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/initiators.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.walkernumber-Tuple{Any}" href="#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>Rimu.DictVectors.walkernumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">walkernumber(w)</code></pre><p>Compute the number of walkers in <code>w</code>. It is used for updating the shift. Overload this function for modifying population control.</p><p>In most cases <code>walkernumber(w)</code> is identical to <code>norm(w,1)</code>. For <code>AbstractDVec</code>s with complex coefficients it reports the one norm separately for the real and the imaginary part as a <code>ComplexF64</code>. See <a href="API.html#Rimu.DictVectors.Norm1ProjectorPPop"><code>Norm1ProjectorPPop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L320-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.zero!-Tuple{AbstractDVec}" href="#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero!(v)</code></pre><p>Replace <code>v</code> by a zero vector as an inplace operation. For <code>AbstractDVec</code> types it means removing all non-zero elements. For <code>AbstractArrays</code>, it sets all of the values to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/180b0ff8b425ad897a51bf8a31d70fb13e181b30/src/DictVectors/abstractdvec.jl#L78-L83">source</a></section></article><h2 id="ConsistentRNG"><a class="docs-heading-anchor" href="#ConsistentRNG">ConsistentRNG</a><a id="ConsistentRNG-1"></a><a class="docs-heading-anchor-permalink" href="#ConsistentRNG" title="Permalink"></a></h2><p>Link to <a href="consistentrng.html#Module-ConsistentRNG.jl">Module <code>ConsistentRNG.jl</code></a></p><h1 id="Unexported-Submodules"><a class="docs-heading-anchor" href="#Unexported-Submodules">Unexported Submodules</a><a id="Unexported-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Unexported-Submodules" title="Permalink"></a></h1><h2 id="StatsTools"><a class="docs-heading-anchor" href="#StatsTools">StatsTools</a><a id="StatsTools-1"></a><a class="docs-heading-anchor-permalink" href="#StatsTools" title="Permalink"></a></h2><p>Link to <a href="statstools.html#Module-Rimu/StatsTools">Module <code>Rimu/StatsTools</code></a></p><h2 id="Blocking"><a class="docs-heading-anchor" href="#Blocking">Blocking</a><a id="Blocking-1"></a><a class="docs-heading-anchor-permalink" href="#Blocking" title="Permalink"></a></h2><pre><code class="language- hljs">Modules = [Blocking]</code></pre><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="consistentrng.html#Rimu.ConsistentRNG"><code>Rimu.ConsistentRNG</code></a></li><li><a href="API.html#Rimu.DictVectors"><code>Rimu.DictVectors</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a></li><li><a href="API.html#Rimu.Rimu"><code>Rimu.Rimu</code></a></li><li><a href="statstools.html#Rimu.StatsTools"><code>Rimu.StatsTools</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNGs"><code>Rimu.ConsistentRNG.CRNGs</code></a></li><li><a href="statstools.html#MonteCarloMeasurements.Particles-Tuple{Rimu.StatsTools.BlockingResult{var&quot;#s311&quot;} where var&quot;#s311&quot;&lt;:Real}"><code>MonteCarloMeasurements.Particles</code></a></li><li><a href="API.html#Rimu.AllOverlaps"><code>Rimu.AllOverlaps</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>Rimu.BitStringAddresses.AbstractFockAddress</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BitString"><code>Rimu.BitStringAddresses.BitString</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS2C"><code>Rimu.BitStringAddresses.BoseFS2C</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFSIndex"><code>Rimu.BitStringAddresses.BoseFSIndex</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.CompositeFS"><code>Rimu.BitStringAddresses.CompositeFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.FermiFS"><code>Rimu.BitStringAddresses.FermiFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.FermiOccupiedModes"><code>Rimu.BitStringAddresses.FermiOccupiedModes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>Rimu.BitStringAddresses.SingleComponentFockAddress</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNG"><code>Rimu.ConsistentRNG.CRNG</code></a></li><li><a href="API.html#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a></li><li><a href="API.html#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractProjector"><code>Rimu.DictVectors.AbstractProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.CoherentInitiator"><code>Rimu.DictVectors.CoherentInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FrozenDVec"><code>Rimu.DictVectors.FrozenDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.Initiator"><code>Rimu.DictVectors.Initiator</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>Rimu.DictVectors.InitiatorDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorIterator"><code>Rimu.DictVectors.InitiatorIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorRule"><code>Rimu.DictVectors.InitiatorRule</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorValue"><code>Rimu.DictVectors.InitiatorValue</code></a></li><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>Rimu.DictVectors.IsDeterministic</code></a></li><li><a href="API.html#Rimu.DictVectors.IsDynamicSemistochastic"><code>Rimu.DictVectors.IsDynamicSemistochastic</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochastic2Pop"><code>Rimu.DictVectors.IsStochastic2Pop</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>Rimu.DictVectors.IsStochasticInteger</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>Rimu.DictVectors.IsStochasticWithThreshold</code></a></li><li><a href="API.html#Rimu.DictVectors.Norm1ProjectorPPop"><code>Rimu.DictVectors.Norm1ProjectorPPop</code></a></li><li><a href="API.html#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a></li><li><a href="API.html#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.PopsProjector"><code>Rimu.DictVectors.PopsProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.SimpleInitiator"><code>Rimu.DictVectors.SimpleInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>Rimu.DictVectors.StochasticStyle</code></a></li><li><a href="API.html#Rimu.DictVectors.StyleUnknown"><code>Rimu.DictVectors.StyleUnknown</code></a></li><li><a href="API.html#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a></li><li><a href="API.html#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a></li><li><a href="API.html#Rimu.DoubleLogSumUpdate"><code>Rimu.DoubleLogSumUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian"><code>Rimu.Hamiltonians.AbstractHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>Rimu.Hamiltonians.BoseHubbardMom1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>Rimu.Hamiltonians.BoseHubbardReal1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>Rimu.Hamiltonians.ExtendedHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>Rimu.Hamiltonians.HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>Rimu.Hamiltonians.HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>Rimu.Hamiltonians.HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>Rimu.Hamiltonians.HubbardRealSpace</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LOStructure"><code>Rimu.Hamiltonians.LOStructure</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>Rimu.Hamiltonians.LadderBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian"><code>Rimu.Hamiltonians.MatrixHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>Rimu.Hamiltonians.PeriodicBoundaries</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a></li><li><a href="API.html#Rimu.MultiScalar"><code>Rimu.MultiScalar</code></a></li><li><a href="API.html#Rimu.NoMemory"><code>Rimu.NoMemory</code></a></li><li><a href="API.html#Rimu.NoStats"><code>Rimu.NoStats</code></a></li><li><a href="API.html#Rimu.PostStepStrategy"><code>Rimu.PostStepStrategy</code></a></li><li><a href="API.html#Rimu.ProjectedEnergy"><code>Rimu.ProjectedEnergy</code></a></li><li><a href="API.html#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a></li><li><a href="API.html#Rimu.Projector"><code>Rimu.Projector</code></a></li><li><a href="API.html#Rimu.PurgeNegatives"><code>Rimu.PurgeNegatives</code></a></li><li><a href="API.html#Rimu.QMCState"><code>Rimu.QMCState</code></a></li><li><a href="API.html#Rimu.ReplicaState"><code>Rimu.ReplicaState</code></a></li><li><a href="API.html#Rimu.ReplicaStrategy"><code>Rimu.ReplicaStrategy</code></a></li><li><a href="API.html#Rimu.Report"><code>Rimu.Report</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a></li><li><a href="API.html#Rimu.ReportToFile"><code>Rimu.ReportToFile</code></a></li><li><a href="API.html#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a></li><li><a href="API.html#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a></li><li><a href="API.html#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a></li><li><a href="API.html#Rimu.SignCoherence"><code>Rimu.SignCoherence</code></a></li><li><a href="statstools.html#Rimu.StatsTools.BlockingResult"><code>Rimu.StatsTools.BlockingResult</code></a></li><li><a href="statstools.html#Rimu.StatsTools.RatioBlockingResult"><code>Rimu.StatsTools.RatioBlockingResult</code></a></li><li><a href="API.html#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a></li><li><a href="API.html#Rimu.TripleLogUpdate"><code>Rimu.TripleLogUpdate</code></a></li><li><a href="API.html#Rimu.WalkerLoneliness"><code>Rimu.WalkerLoneliness</code></a></li><li><a href="statstools.html#Measurements.measurement-Tuple{Rimu.StatsTools.BlockingResult{var&quot;#s322&quot;} where var&quot;#s322&quot;&lt;:Real}"><code>Measurements.measurement</code></a></li><li><a href="API.html#OrderedCollections.freeze-Tuple{Any}"><code>OrderedCollections.freeze</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}, Type{UInt64}}} where {B, N}"><code>Rimu.BitStringAddresses.check_bitstring_typeparams</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}"><code>Rimu.BitStringAddresses.chunk_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.chunk_type-Union{Tuple{Type{var&quot;#s6&quot;} where var&quot;#s6&quot;&lt;:(BitString{var&quot;#s5&quot;, var&quot;#s1&quot;, T} where {var&quot;#s5&quot;, var&quot;#s1&quot;})}, Tuple{T}} where T"><code>Rimu.BitStringAddresses.chunk_type</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.chunks-Tuple{BitString}"><code>Rimu.BitStringAddresses.chunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.find_mode"><code>Rimu.BitStringAddresses.find_mode</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.find_occupied_mode"><code>Rimu.BitStringAddresses.find_occupied_mode</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.has_ghost_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.m_onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.move_particle"><code>Rimu.BitStringAddresses.move_particle</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.near_uniform-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BoseFS{N, M, S} where S&lt;:BitString)}, Tuple{M}, Tuple{N}} where {N, M}"><code>Rimu.BitStringAddresses.near_uniform</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.near_uniform_onr-Tuple{Number, Number}"><code>Rimu.BitStringAddresses.near_uniform_onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N, T} where {N, T&lt;:Unsigned})}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_chunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(BitString{var&quot;#s6&quot;, N, T} where {var&quot;#s6&quot;, T&lt;:Unsigned})}, Tuple{N}} where N"><code>Rimu.BitStringAddresses.num_chunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_components-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_components</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_modes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_occupied_modes"><code>Rimu.BitStringAddresses.num_occupied_modes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_particles</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.occupied_modes"><code>Rimu.BitStringAddresses.occupied_modes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.partial_left_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned"><code>Rimu.BitStringAddresses.partial_left_shift</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.partial_right_shift-Union{Tuple{T}, Tuple{T, Any, Any}} where T&lt;:Unsigned"><code>Rimu.BitStringAddresses.partial_right_shift</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N, T} where {N, T&lt;:Unsigned})}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.top_chunk_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.update_component-Union{Tuple{I}, Tuple{CompositeFS, Any, Val{I}}} where I"><code>Rimu.BitStringAddresses.update_component</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple"><code>Rimu.ConsistentRNG.cRand</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRandn-Tuple"><code>Rimu.ConsistentRNG.cRandn</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.check_crng_independence-Tuple{Any}"><code>Rimu.ConsistentRNG.check_crng_independence</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.newChildRNG"><code>Rimu.ConsistentRNG.newChildRNG</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Vector{T} where T}"><code>Rimu.ConsistentRNG.seedCRNG!</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.sync_cRandn-Tuple{Any}"><code>Rimu.ConsistentRNG.sync_cRandn</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}"><code>Rimu.ConsistentRNG.trng</code></a></li><li><a href="API.html#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K"><code>Rimu.DictVectors.add!</code></a></li><li><a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Rimu.DictVectors.default_style</code></a></li><li><a href="API.html#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V"><code>Rimu.DictVectors.deposit!</code></a></li><li><a href="API.html#Rimu.DictVectors.deposit!-NTuple{4, Any}"><code>Rimu.DictVectors.deposit!</code></a></li><li><a href="API.html#Rimu.DictVectors.localpart-Tuple{Any}"><code>Rimu.DictVectors.localpart</code></a></li><li><a href="API.html#Rimu.DictVectors.storage"><code>Rimu.DictVectors.storage</code></a></li><li><a href="API.html#Rimu.DictVectors.value"><code>Rimu.DictVectors.value</code></a></li><li><a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>Rimu.DictVectors.walkernumber</code></a></li><li><a href="API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.diagonal_element"><code>Rimu.Hamiltonians.diagonal_element</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>Rimu.Hamiltonians.dimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.get_offdiagonal"><code>Rimu.Hamiltonians.get_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>Rimu.Hamiltonians.neighbour_site</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>Rimu.Hamiltonians.num_neighbours</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_offdiagonals"><code>Rimu.Hamiltonians.num_offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.offdiagonals"><code>Rimu.Hamiltonians.offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.random_offdiagonal"><code>Rimu.Hamiltonians.random_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.starting_address"><code>Rimu.Hamiltonians.starting_address</code></a></li><li><a href="statstools.html#Rimu.StatsTools.autocovariance-Tuple{AbstractVector{T} where T, Int64}"><code>Rimu.StatsTools.autocovariance</code></a></li><li><a href="statstools.html#Rimu.StatsTools.blocker-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>Rimu.StatsTools.blocker</code></a></li><li><a href="statstools.html#Rimu.StatsTools.blocking_analysis-Tuple{AbstractVector{T} where T}"><code>Rimu.StatsTools.blocking_analysis</code></a></li><li><a href="statstools.html#Rimu.StatsTools.blocks_with_m-Tuple{Any}"><code>Rimu.StatsTools.blocks_with_m</code></a></li><li><a href="statstools.html#Rimu.StatsTools.growth_estimator-NTuple{4, Any}"><code>Rimu.StatsTools.growth_estimator</code></a></li><li><a href="statstools.html#Rimu.StatsTools.growth_witness-Tuple{AbstractArray, AbstractArray, Any}"><code>Rimu.StatsTools.growth_witness</code></a></li><li><a href="statstools.html#Rimu.StatsTools.mean_and_se-Tuple{Rimu.StatsTools.BlockingResult}"><code>Rimu.StatsTools.mean_and_se</code></a></li><li><a href="statstools.html#Rimu.StatsTools.med_and_errs-Tuple{Any}"><code>Rimu.StatsTools.med_and_errs</code></a></li><li><a href="statstools.html#Rimu.StatsTools.mixed_estimator-NTuple{5, Any}"><code>Rimu.StatsTools.mixed_estimator</code></a></li><li><a href="statstools.html#Rimu.StatsTools.mtest-Tuple{AbstractVector{T} where T}"><code>Rimu.StatsTools.mtest</code></a></li><li><a href="statstools.html#Rimu.StatsTools.pseudo_cov-Tuple{Any, Any}"><code>Rimu.StatsTools.pseudo_cov</code></a></li><li><a href="statstools.html#Rimu.StatsTools.ratio_estimators-Tuple{Any, Any}"><code>Rimu.StatsTools.ratio_estimators</code></a></li><li><a href="statstools.html#Rimu.StatsTools.ratio_of_means-Tuple{Any, Any}"><code>Rimu.StatsTools.ratio_of_means</code></a></li><li><a href="statstools.html#Rimu.StatsTools.ratio_with_errs-Tuple{Rimu.StatsTools.RatioBlockingResult}"><code>Rimu.StatsTools.ratio_with_errs</code></a></li><li><a href="statstools.html#Rimu.StatsTools.replica_fidelity-Tuple{Tuple}"><code>Rimu.StatsTools.replica_fidelity</code></a></li><li><a href="statstools.html#Rimu.StatsTools.smoothen-Tuple{AbstractVector{T} where T, Integer}"><code>Rimu.StatsTools.smoothen</code></a></li><li><a href="statstools.html#Rimu.StatsTools.to_measurement-Tuple{MonteCarloMeasurements.Particles}"><code>Rimu.StatsTools.to_measurement</code></a></li><li><a href="statstools.html#Rimu.StatsTools.w_exp-Tuple{Any, Any, Any}"><code>Rimu.StatsTools.w_exp</code></a></li><li><a href="statstools.html#Rimu.StatsTools.w_lin-Tuple{Any, Any, Any}"><code>Rimu.StatsTools.w_lin</code></a></li><li><a href="statstools.html#Rimu.StatsTools.x_by_y_linear-NTuple{5, Any}"><code>Rimu.StatsTools.x_by_y_linear</code></a></li><li><a href="API.html#Rimu._n_walkers-Tuple{Any, Any}"><code>Rimu._n_walkers</code></a></li><li><a href="API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, T1, V, W, R} where {T1, V, W, R&lt;:FciqmcRunStrategy{T1}}}} where T"><code>Rimu.advance!</code></a></li><li><a href="API.html#Rimu.all_overlaps-Union{Tuple{N}, Tuple{Tuple, Tuple{Vararg{AbstractDVec, N}}}} where N"><code>Rimu.all_overlaps</code></a></li><li><a href="API.html#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.apply_memory_noise!</code></a></li><li><a href="API.html#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.fciqmc_col!</code></a></li><li><a href="API.html#Rimu.fciqmc_step!"><code>Rimu.fciqmc_step!</code></a></li><li><a href="API.html#Rimu.finalize_report!-Tuple{ReportingStrategy, Any}"><code>Rimu.finalize_report!</code></a></li><li><a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>Rimu.lomc!</code></a></li><li><a href="API.html#Rimu.post_step"><code>Rimu.post_step</code></a></li><li><a href="API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy}"><code>Rimu.refine_r_strat</code></a></li><li><a href="API.html#Rimu.replica_stats"><code>Rimu.replica_stats</code></a></li><li><a href="API.html#Rimu.report!-Tuple{Rimu.Report, Union{AbstractString, Symbol}, Any}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.report!-Tuple{ReportingStrategy, Any, Vararg{Any, N} where N}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.report_after_step-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>Rimu.report_after_step</code></a></li><li><a href="API.html#Rimu.sort_into_targets!-Tuple{Any, Any, Any}"><code>Rimu.sort_into_targets!</code></a></li><li><a href="API.html#Rimu.step_stats-Tuple{StochasticStyle}"><code>Rimu.step_stats</code></a></li><li><a href="API.html#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s322&quot;, false} where var&quot;#s322&quot;, Any, Any, Any, Any}"><code>Rimu.threshold_projected_deposit!</code></a></li><li><a href="API.html#Rimu.update_dvec!-Tuple{StochasticStyle, Any}"><code>Rimu.update_dvec!</code></a></li><li><a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.update_dτ</code></a></li><li><a href="API.html#Rimu.update_shift"><code>Rimu.update_shift</code></a></li><li><a href="statstools.html#Statistics.cov-Tuple{Rimu.StatsTools.BlockingResult{var&quot;#s322&quot;} where var&quot;#s322&quot;&lt;:Complex}"><code>Statistics.cov</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="testing.html">« Code testing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Saturday 21 August 2021 23:35">Saturday 21 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
