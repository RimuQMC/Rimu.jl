<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Rimu.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Rimu.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="consistentrng.html">Random Numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li class="is-active"><a class="tocitem" href="API.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rimu"><span>Rimu</span></a></li><li><a class="tocitem" href="#Reexported-Submodules"><span>Reexported Submodules</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="BHM-example.html">Example: 1D Bose-Hubbard Model</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="API.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Rimu"><a class="docs-heading-anchor" href="#Rimu">Rimu</a><a id="Rimu-1"></a><a class="docs-heading-anchor-permalink" href="#Rimu" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.Rimu" href="#Rimu.Rimu"><code>Rimu.Rimu</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Rimu</code></pre><p>Random Integrator for Many-Body Quantum Systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/Rimu.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.AllOverlaps" href="#Rimu.AllOverlaps"><code>Rimu.AllOverlaps</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AllOverlaps(n=2, operator=nothing) &lt;: ReplicaStrategy{n}</code></pre><p>Run <code>n</code> replicas and report overlaps between all pairs of replica vectors. If operator is not <code>nothing</code>, the overlap <code>dot(c1, operator, c2)</code> is reported as well.</p><p>Column names in the report are of the form c{i}<em>dot</em>c{j} for vector-vector overlaps, and c{i}<em>Op</em>c{j} for operator overlaps.</p><p>See <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> (for an interface for implementing operators).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L870-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ConstantTimeStep" href="#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Keep <code>dτ</code> constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedDoubleLogUpdate" href="#Rimu.DelayedDoubleLogUpdate"><code>Rimu.DelayedDoubleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedDoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> and delay of <code>A</code> steps. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p><p class="math-container">\[S^{n+A} = S^n -\frac{ζ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^n}\right)-\frac{ξ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^\text{target}}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L621-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedDoubleLogUpdateAfterTW" href="#Rimu.DelayedDoubleLogUpdateAfterTW"><code>Rimu.DelayedDoubleLogUpdateAfterTW</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedDoubleLogUpdateAfterTW(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> and delay of <code>A</code> steps after the number of target walkers is reached. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p><p class="math-container">\[S^{n+A} = S^n -\frac{ζ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^n}\right)-\frac{ξ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^\text{target}}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L639-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedLogUpdate" href="#Rimu.DelayedLogUpdate"><code>Rimu.DelayedLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedLogUpdate(ζ = 0.08, a = 10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and delay of <code>a</code> steps.</p><p class="math-container">\[S^{n+a} = S^n -\frac{ζ}{a dτ}\ln\left(\frac{\|Ψ\|_1^{n+a}}{\|Ψ\|_1^n}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L655-L663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedLogUpdateAfterTargetWalkers" href="#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>Rimu.DelayedLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, a = 10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and delay of <code>a</code> steps. See <a href="API.html#Rimu.DelayedLogUpdate"><code>DelayedLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L455-L460">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory" href="#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = (pnorm - tnorm)/(dτ*pnorm) + shift
r = r̃ - &lt;r̃&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L291-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory2" href="#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory2(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = pnorm - tnorm + shift*dτ*pnorm
r = (r̃ - &lt;r̃&gt;)/(dτ*pnorm)</code></pre><p>The long-term average of <code>r</code> is not guaranteed to be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L308-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory3" href="#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory3(Δ::Int, level::Float64) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, apply multiplicative memory noise with a memory length of <code>Δ</code> at level <code>level</code>, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = (pnorm - tnorm)/pnorm + dτ*shift
r = r̃ - &lt;r̃&gt;
w .*= 1 + level*r</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L326-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DontUpdate" href="#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DontUpdate() &lt;: ShiftStrategy</code> Don&#39;t update the <code>shift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogProjected" href="#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DoubleLogProjected(; target, projector, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> after projecting onto <code>projector</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{P⋅Ψ^{(n)}}\right)-\frac{ξ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{\text{target}}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L545-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogSumUpdate" href="#Rimu.DoubleLogSumUpdate"><code>Rimu.DoubleLogSumUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DoubleLogSumUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, α = 1/2) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameters <code>ζ</code> and <code>ξ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^n}\right)
- \frac{ξ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^\text{target}}\right),\]</p><p>where <span>$N_\mathrm{w} =$</span> <code>(1-α)*walkernumber() + α*UniformProjector()⋅ψ</code> computed with <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber()</code></a> and <a href="API.html#Rimu.DictVectors.UniformProjector"><code>UniformProjector()</code></a>. When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L495-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdate" href="#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)-\frac{ξ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^\text{target}}\right)\]</p><p>When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L477-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkers" href="#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, ξ = 0.0016) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L593-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkersSwitch" href="#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>Rimu.DoubleLogUpdateAfterTargetWalkersSwitch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkersSwitch(targetwalkers, ζ = 0.08, ξ = 0.0016) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. After <code>a</code> steps the strategy switches to <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L607-L613">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.EveryKthStep" href="#Rimu.EveryKthStep"><code>Rimu.EveryKthStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EveryKthStep(;k = 10, projector = nothing, hproj = :auto)</code></pre><p>Report every <code>k</code>th step. Include projection onto <code>projector</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.EveryTimeStep" href="#Rimu.EveryTimeStep"><code>Rimu.EveryTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EveryTimeStep(;projector = nothing, hproj = :auto)</code></pre><p>Report every time step. Include projection onto <code>projector</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FciqmcRunStrategy" href="#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia"> FciqmcRunStrategy{T}</code></pre><p>Abstract type representing the strategy for running and terminating <a href="@ref"><code>fciqmc!()</code></a>. The type parameter <code>T</code> is relevant for reporting the shift and the norm.</p><p>Implemented strategies:</p><ul><li><a href="API.html#Rimu.RunTillLastStep"><code>RunTillLastStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L13-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.HistoryLogUpdate" href="#Rimu.HistoryLogUpdate"><code>Rimu.HistoryLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HistoryLogUpdate(df::DataFrame; d = 100, k=1, ζ= 0.08)</code></pre><p>Strategy for updating the shift according to log formula but with walker numbers accumulated from <code>k</code> samples of the history with delay <code>d</code>. A recent history has to be passed with the data frame <code>df</code> for initialisation.</p><p class="math-container">\[N_w^{n} = \sum_{i=0}^{k-1} \|Ψ\|_1^{n-i} \\
S^{n+a} = S^n -\frac{ζ}{a dτ}\ln\left(\frac{N_w^{n+1}}{N_w^n}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L668-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdate" href="#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdate(ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L466-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdateAfterTargetWalkers" href="#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code>. See <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L442-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MemoryStrategy" href="#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:</p><ul><li><a href="API.html#Rimu.NoMemory"><code>NoMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>DeltaMemory</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>ShiftMemory</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L268-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoMemory" href="#Rimu.NoMemory"><code>Rimu.NoMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoMemory &lt;: MemoryStrategy</code></pre><p>Default strategy for <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a> indicating that no memory noise will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L278-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoStats" href="#Rimu.NoStats"><code>Rimu.NoStats</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoStats(N=1) &lt;: ReplicaStrategy{N}</code></pre><p>The default <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a>. <code>N</code> replicas are run, but no statistics are collected.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L860-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectedMemory" href="#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectedMemory(Δ::Int, projector, pp::Number) &lt;: MemoryStrategy
ProjectedMemory(Δ::Int, projector, v::AbstractDVec)</code></pre><p>Before updating the shift, apply memory noise to minimize the fluctuations of the overlap of the coefficient vector with <code>projector</code>. Averaging over <code>Δ</code> time steps is applied, where <code>Δ = 1</code> means no memory noise is applied. Use <code>pp</code> to initialise the value of the projection or pass <code>v</code> in order to initialise the projection with <code>pp = projector.v</code>.</p><pre><code class="language-none">r̃ = (projector⋅v - projector⋅w)/projector⋅v + dτ*shift
r = r̃ - &lt;r̃&gt;</code></pre><p>where <code>v</code> is the coefficient vector before and <code>w</code> after applying a regular FCIQMC step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L358-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.PurgeNegatives" href="#Rimu.PurgeNegatives"><code>Rimu.PurgeNegatives</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PurgeNegatives &lt;: MemoryStrategy</code></pre><p>Purge all negative sign walkers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L285-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.QMCState" href="#Rimu.QMCState"><code>Rimu.QMCState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QMCState</code></pre><p>Holds all inforamtion needed to run FCIQMC, except the data frame. Holds a <code>NTuple</code> of <code>ReplicaState</code>s and various strategies that control the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/lomc.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReplicaState" href="#Rimu.ReplicaState"><code>Rimu.ReplicaState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReplicaState(hamiltonian, v, w, pnorm, r_strat)</code></pre><p>Struct that holds all information needed for an independent run of the algorithm.</p><p>Can be advanced a step forward with <a href="API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, V, W, R} where {V, W, R&lt;:FciqmcRunStrategy{T}}}} where T"><code>advance!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/lomc.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReplicaStrategy" href="#Rimu.ReplicaStrategy"><code>Rimu.ReplicaStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReplicaStrategy{N}</code></pre><p>An abstract type that controles how <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> uses replicas. A subtype of <code>ReplicaStrategy{N}</code> operates on <code>N</code> replicas and must implement the following function:</p><ul><li><a href="@ref"><code>replica_stats(::ReplicaStrategy{N}, ::NTuple{N,ReplicaState})</code></a> - return a tuple of <code>String</code>s or <code>Symbols</code> of replica statistic names and a tuple of the values.  These will be reported to the <code>DataFrame</code> returned by <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a></li></ul><p>Concrete implementations:</p><ul><li><a href="API.html#Rimu.NoStats"><code>NoStats</code></a>: run (possibly one) replica(s), but don&#39;t report any additional info.</li><li><a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>: report overlaps between all pairs of replica vectors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L832-L847">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Report" href="#Rimu.Report"><code>Rimu.Report</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Report</code></pre><p>Internal structure that hold the temporary reported values. See <a href="API.html#Rimu.report!-Tuple{Any, Any, Any}"><code>report!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/report.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportDFAndInfo" href="#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReportDFAndInfo(; k=10, i=100, io=stdout, writeinfo=true, projector = nothing, hproj = :auto)</code></pre><p>Report every <code>k</code>th step in DataFrame and write info message to <code>io</code> every <code>i</code>th step (unless <code>writeinfo == false</code>). The flag <code>writeinfo</code> is useful for controlling info messages in MPI codes. Include projection onto <code>projector</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportingStrategy" href="#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReportingStrategy</code></pre><p>Abstract type for strategies for reporting data in a DataFrame with <a href="API.html#Rimu.report!-Tuple{Any, Any, Any}"><code>report!()</code></a>. It also affects the calculation and reporting of projected quantities in the DataFrame.</p><p><strong>Implemented strategies:</strong></p><ul><li><a href="API.html#Rimu.EveryTimeStep"><code>EveryTimeStep</code></a></li><li><a href="API.html#Rimu.EveryKthStep"><code>EveryKthStep</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>ReportDFAndInfo</code></a></li></ul><p>Every strategy accepts the keyword arguments <code>projector</code> and <code>hproj</code> according to which a projection of the instantaneous coefficient vector <code>projector⋅v</code> and <code>hproj⋅v</code> are reported to the DataFrame in the fields <code>df.vproj</code> and <code>df.hproj</code>, respectively. Possible values for <code>projector</code> are</p><ul><li><code>nothing</code> - no projections are computed (default)</li><li><code>dv::AbstractDVec</code> - compute projection onto coefficient vector <code>dv</code> (set up with <a href="@ref"><code>copy</code></a> to conserve memory)</li><li><a href="API.html#Rimu.DictVectors.UniformProjector"><code>UniformProjector()</code></a> - projection onto vector of all ones (i.e. sum of elements)</li><li><a href="API.html#Rimu.DictVectors.NormProjector"><code>NormProjector()</code></a> - compute 1-norm (instead of projection)</li><li><a href="API.html#Rimu.DictVectors.Norm1ProjectorPPop"><code>Norm1ProjectorPPop()</code></a> - compute 1-norm per population</li><li><a href="API.html#Rimu.DictVectors.Norm2Projector"><code>Norm2Projector()</code></a> - compute 2-norm</li></ul><p>In order to help set up the calculation of the projected energy, where <code>df.hproj</code> should report <code>dot(projector, ham, v)</code>, the keyword <code>hproj</code> accepts the following values (for <code>ReportingStrategy</code>s passed to <code>lomc!()</code>):</p><ul><li><code>:auto</code> - choose method depending on <code>projector</code> and <code>ham</code> (default)</li><li><code>:lazy</code> - compute <code>dot(projector, ham, v)</code> every time (slow)</li><li><code>:eager</code> -  precompute <code>hproj</code> as <code>ham&#39;*v</code> (fast, requires <code>adjoint(ham)</code>)</li><li><code>:not</code> - don&#39;t compute second projector (equivalent to <code>nothing</code>)</li></ul><p><strong>Interface</strong></p><p>A <code>ReportingStrategy</code> must define the following:</p><ul><li><a href="API.html#Rimu.report!-Tuple{Any, Any, Any}"><code>report!</code></a></li><li><a href="API.html#Rimu.print_report-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>print_report</code></a> (optional)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">r_strat = EveryTimeStep(projector = copy(svec))</code></pre><p>Record the projected energy components <code>df.vproj = svec⋅v</code> and <code>df.hproj = dot(svec,ham,v)</code> with respect to the starting vector (performs fast eager calculation if <code>Hamiltonians.LOStructure(ham) ≠ Hamiltonians.AdjointUnknown()</code>), and report every time step.</p><pre><code class="language-julia">r_strat = EveryKthStep(k=10, projector = UniformProjector(), hproj = :lazy)</code></pre><p>Record the projection of the instananeous coefficient vector <code>v</code> onto the uniform vector of all 1s into <code>df.vproj</code> and of <code>ham⋅v</code> into <code>df.hproj</code>, and report every <code>k</code>th time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L44-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RunTillLastStep" href="#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RunTillLastStep(step::Int = 0 # number of current/starting timestep
             laststep::Int = 100 # number of final timestep
             shiftMode::Bool = false # whether to adjust shift
             shift = 0.0 # starting/current value of shift
             dτ::Float64 = 0.01 # current value of time step
) &lt;: FciqmcRunStrategy</code></pre><p>Parameters for running <a href="@ref"><code>fciqmc!()</code></a> for a fixed number of time steps. For alternative strategies, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L33-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftMemory" href="#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Effectively replaces the fluctuating <code>shift</code> update procedure for the coefficient vector by an averaged <code>shift</code> over <code>Δ</code> timesteps, where <code>Δ = 1</code> means no averaging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L346-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftStrategy" href="#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for updating the <code>shift</code> with <a href="API.html#Rimu.update_shift-Tuple{HistoryLogUpdate, Any, Any, Any, Any, Any, Any, Any, Vararg{Any, N} where N}"><code>update_shift()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a> - default in <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!()</code></a></li><li><a href="API.html#Rimu.DontUpdate"><code>DontUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdate"><code>DelayedLogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>LogUpdateAfterTargetWalkers</code></a> - FCIQMC standard</li><li><a href="API.html#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>DelayedLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>DoubleLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>DoubleLogUpdateAfterTargetWalkersSwitch</code></a></li><li><a href="API.html#Rimu.HistoryLogUpdate"><code>HistoryLogUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogProjected"><code>DoubleLogProjected</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L421-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TimeStepStrategy" href="#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for strategies for updating the time step with <a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>update_dτ()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.ConstantTimeStep"><code>ConstantTimeStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L229-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TripleLogUpdate" href="#Rimu.TripleLogUpdate"><code>Rimu.TripleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TripleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, η = 0.01) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the extended log formula with damping parameters <code>ζ</code>, <code>ξ</code>, and <code>η</code>.</p><p class="math-container">\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^n}\right)
- \frac{ξ}{dτ}\ln\left(\frac{N_\mathrm{w}^{n+1}}{N_\mathrm{w}^\text{target}}\right)
- \frac{η}{dτ}\ln\left(\frac{\|ℜ(Ψ^{n+1})\|_1^2 + \|ℑ(Ψ^{n+1})\|_1^2}
{\|ℜ(Ψ^{n})\|_1^2 + \|ℑ(Ψ^{n})\|_1^2}\right),\]</p><p>where <span>$N_\mathrm{w}$</span> is the <a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>walkernumber()</code></a>. When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L519-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, V, W, R} where {V, W, R&lt;:FciqmcRunStrategy{T}}}} where T" href="#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, V, W, R} where {V, W, R&lt;:FciqmcRunStrategy{T}}}} where T"><code>Rimu.advance!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">advance!(report::Report, state::QMCState, replica::ReplicaState)</code></pre><p>Advance the <code>replica</code> by one step. The <code>state</code> is used only to access the various strategies involved. Steps, stats, and computed quantities are written to the <code>report</code>.</p><p>Returns <code>true</code> if the step was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/lomc.jl#L252-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}" href="#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.apply_memory_noise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r = apply_memory_noise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)</code></pre><p>Apply memory noise to <code>w</code>, i.e. <code>w .+= r.*v</code>, computing the noise <code>r</code> according to <code>m_strat</code>. Note that <code>m_strat</code> needs to be compatible with <code>StochasticStyle(w)</code>. Otherwise, an error exception is thrown. See <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a>.</p><p><code>w</code> is the walker array after fciqmc step, <code>v</code> the previous one, <code>pnorm</code> the norm of <code>v</code>, and <code>r</code> the instantaneously applied noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/apply_memory_noise.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.compute_proj_observables-Tuple{Any, Any, ReportingStrategy{Nothing, Nothing}}" href="#Rimu.compute_proj_observables-Tuple{Any, Any, ReportingStrategy{Nothing, Nothing}}"><code>Rimu.compute_proj_observables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_proj_observables(v, ham, r::ReportingStrategy)</code></pre><p>Compute the projection of <code>r.projector⋅v</code> and <code>r.hproj⋅v</code> or <code>r.projector⋅ham*v</code> according to the <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}" href="#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.fciqmc_col!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fciqmc_col!(w, ham, add, num, shift, dτ)
fciqmc_col!(::Type{T}, args...)
-&gt; spawns, deaths, clones, antiparticles, annihilations</code></pre><p>Spawning and diagonal step of FCIQMC for single column of <code>ham</code>. In essence it computes</p><p><code>w .+= (1 .+ dτ.*(shift .- ham[:,add])).*num</code>.</p><p>Depending on <code>T ==</code><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle(w)</code></a>, a stochastic or deterministic algorithm will be chosen. The possible values for <code>T</code> are:</p><ul><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>IsDeterministic()</code></a> deteministic algorithm</li><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>IsStochasticInteger()</code></a> stochastic version where the changes added to <code>w</code> are purely integer, according to the FCIQMC algorithm</li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold(c)</code></a> stochastic algorithm with floating point walkers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/fciqmc_col.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_step!" href="#Rimu.fciqmc_step!"><code>Rimu.fciqmc_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;
                      m_strat::MemoryStrategy = NoMemory()) -&gt; ṽ, w̃, stats</code></pre><p>Perform a single matrix(/operator)-vector multiplication:</p><p class="math-container">\[\tilde{v} = [1 - dτ(\hat{H} - S)]⋅v ,\]</p><p>where <code>Ĥ == ham</code> and <code>S == shift</code>. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait <code>StochasticStyle(w)</code>. See <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>. <code>w</code> is a local data structure with the same size and type as <code>v</code> and used for working. Both <code>v</code> and <code>w</code> are modified.</p><p>Returns the result <code>ṽ</code>, a (possibly changed) reference to working memory <code>w̃</code>,  and the array <code>stats = [spawns, deaths, clones, antiparticles, annihilations]</code>. Stats will contain zeros when running in deterministic mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/fciqmc_step.jl#L4-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.lomc!-Tuple{Any, Any}" href="#Rimu.lomc!-Tuple{Any, Any}"><code>Rimu.lomc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lomc!(ham, v; kwargs...)</code></pre><p>Linear operator Monte Carlo: Perform the FCIQMC algorithm for determining the lowest eigenvalue of <code>ham</code>. <code>v</code> can be a single starting vector of (wrapped) type <code>:&lt;AbstractDVec</code>.</p><p>Returns a <code>DataFrame</code> with various statistics and a <code>QMCState</code> containing all information required for continuation runs.</p><p><strong>Keyword arguments, defaults, and precedence:</strong></p><ul><li><code>laststep</code> - can be used to override information otherwise contained in <code>params</code></li><li><code>threading = :auto</code> - can be used to control the use of multithreading (overridden by <code>wm</code>)<ul><li><code>:auto</code> - use multithreading if <code>s_strat.targetwalkers ≥ 500</code></li><li><code>true</code> - use multithreading if available (set shell variable <code>JULIA_NUM_THREADS</code>!)</li><li><code>false</code> - run on single thread</li></ul></li><li><code>wm</code> - working memory; if set, it controls the use of multithreading and overrides <code>threading</code>; is mutated</li><li><code>params::FciqmcRunStrategy = RunTillLastStep(laststep = 100)</code> - contains basic parameters of simulation state, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>; is mutated</li><li><code>s_strat::ShiftStrategy = DoubleLogUpdate(targetwalkers = 1000)</code> - see <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a></li><li><code>r_strat::ReportingStrategy = EveryTimeStep()</code> - see <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a></li><li><code>τ_strat::TimeStepStrategy = ConstantTimeStep()</code> - see <a href="API.html#Rimu.TimeStepStrategy"><code>TimeStepStrategy</code></a></li><li><code>m_strat::MemoryStrategy = NoMemory()</code> - see <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a></li><li><code>replica::ReplicaStrategy = NoStats(1)</code> - see <a href="API.html#Rimu.ReplicaStrategy"><code>ReplicaStrategy</code></a>.</li></ul><p><strong>Return values</strong></p><p><code>lomc!</code> returns a named tuple with the following fields:</p><ul><li><code>df</code>: a <code>DataFrame</code> with all statistics being reported.</li><li><code>state</code>: a <code>QMCState</code> that can be used for continuations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; add = BoseFS((1,2,3));

julia&gt; H = HubbardReal1D(add);

julia&gt; dv = DVec(add =&gt; 1);

julia&gt; df1, state = lomc!(H, dv);

julia&gt; df2, _ = lomc!(state, df1; laststep=200); # Contuniation run

julia&gt; size(df1)
(100, 12)

julia&gt; size(df2)
(200, 12)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/lomc.jl#L154-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.print_report-Tuple{ReportingStrategy, Vararg{Any, N} where N}" href="#Rimu.print_report-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>Rimu.print_report</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_report(::ReportingStrategy, step, report, state)</code></pre><p>This function is called at the very end of a step. It can let the <code>ReportingStrategy</code> print some information to output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.refine_r_strat-Tuple{ReportingStrategy, Any}" href="#Rimu.refine_r_strat-Tuple{ReportingStrategy, Any}"><code>Rimu.refine_r_strat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Rimu.refine_r_strat(r_strat::ReportingStrategy, ham)</code></pre><p>Refine the reporting strategy by replacing <code>Symbol</code>s in the keyword argument <code>hproj</code> by the appropriate value. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/helpers.jl#L13-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.replica_stats" href="#Rimu.replica_stats"><code>Rimu.replica_stats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">replica_stats(::ReplicaStrategy{N}, replicas::NTuple{N,ReplicaState}) -&gt; (names, values)</code></pre><p>Return the names and values of statistics reported by <code>ReplicaStrategy</code>. <code>names</code> should be a tuple of <code>Symbol</code>s or <code>String</code>s and <code>values</code> should be a tuple of the same length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L852-L857">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{Any, Any, Any}" href="#Rimu.report!-Tuple{Any, Any, Any}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">report!(report, keys, values, id=&quot;&quot;)
report!(report, nt, id=&quot;&quot;)</code></pre><p>Write <code>keys</code>, <code>values</code> pairs to <code>report</code> that will be converted to a <code>DataFrame</code> later. Alternatively, a named tuple can be passed instead of <code>keys</code> and <code>values</code>.</p><p>The value of <code>id</code> is appended to the name of the column, e.g. <code>report!(report, :key, value, :_1)</code> will report <code>value</code> to a column named <code>:key_1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/report.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{EveryTimeStep, Any, Vararg{Any, N} where N}" href="#Rimu.report!-Tuple{EveryTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> report!(::ReportingStrategy, step, report::Report, keys, values, id=&quot;&quot;)
 report!(::ReportingStrategy, step, report::Report, nt, id=&quot;&quot;)</code></pre><p>Report <code>keys</code> and <code>values</code> to <code>report</code>, which will be converted to a <code>DataFrame</code> before <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> exits. Alternatively, a <code>nt::NamedTuple</code> can be passed in place of <code>keys</code> and <code>values</code>. If <code>id</code> is specified, it is appended to all <code>keys</code>. This is used to differentiate between values reported by different replicas.</p><p>To overload this function for a new <code>ReportingStrategy</code>, overload <code>report!(::ReportingStrategy, step, args...)</code> and apply the report by calling <code>report!(args...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L186-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.sort_into_targets!-Tuple{Any, Any, Any}" href="#Rimu.sort_into_targets!-Tuple{Any, Any, Any}"><code>Rimu.sort_into_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_into_targets!(target, source, stats) -&gt; agg, wm, agg_stats</code></pre><p>Aggregate coefficients from <code>source</code> to <code>agg</code> and from <code>stats</code> to <code>agg_stats</code> according to thread- or MPI-level parallelism. <code>wm</code> passes back a reference to working memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/helpers.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.step_stats-Tuple{StochasticStyle}" href="#Rimu.step_stats-Tuple{StochasticStyle}"><code>Rimu.step_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step_stats(::StochasticStyle)</code></pre><p>Return a tuple of names (<code>Symbol</code> or <code>String</code>) and a zeros of values of the same length. These will be reported as columns in the <code>DataFrame</code> returned by <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/fciqmc_col.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s249&quot;, false} where var&quot;#s249&quot;, Any, Any, Any, Any}" href="#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s249&quot;, false} where var&quot;#s249&quot;, Any, Any, Any, Any}"><code>Rimu.threshold_projected_deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">threshold_projected_deposit!</code></pre><p>This function performs threshold projection before spawning, but only for <code>IsDynamicSemistochastic</code> with the <code>project_later</code> parameter set to <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/fciqmc_col.jl#L323-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dvec!-Tuple{StochasticStyle, Any}" href="#Rimu.update_dvec!-Tuple{StochasticStyle, Any}"><code>Rimu.update_dvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_dvec!([::StochasticStyle,] dvec) -&gt; dvec, nt</code></pre><p>Perform an arbitrary transformation on <code>dvec</code> after the spawning step is completed and report statistics to the <code>DataFrame</code>.</p><p>Returns the new <code>dvec</code> and a <code>NamedTuple</code> <code>nt</code> of statistics to be reported.</p><p>When extending this function for a custom <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>, define a method  for the two-argument call signature!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/update_dvec.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}" href="#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.update_dτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_dτ(s&lt;:TimeStepStrategy, dτ, args...) -&gt; new dτ</code></pre><p>Update the time step according to the strategy <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L241-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_shift-Tuple{HistoryLogUpdate, Any, Any, Any, Any, Any, Any, Any, Vararg{Any, N} where N}" href="#Rimu.update_shift-Tuple{HistoryLogUpdate, Any, Any, Any, Any, Any, Any, Any, Vararg{Any, N} where N}"><code>Rimu.update_shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_shift(s &lt;: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df, v_new, v_old)</code></pre><p>Update the shift according to strategy <code>s</code>. See <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/strategies_and_params.jl#L690-L693">source</a></section></article><h2 id="Reexported-Submodules"><a class="docs-heading-anchor" href="#Reexported-Submodules">Reexported Submodules</a><a id="Reexported-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Reexported-Submodules" title="Permalink"></a></h2><h3 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h3><p>Link to <a href="hamiltonians.html#Module-Hamiltionians.jl">Module <code>Hamiltionians.jl</code></a></p><h3 id="BitStringAddresses"><a class="docs-heading-anchor" href="#BitStringAddresses">BitStringAddresses</a><a id="BitStringAddresses-1"></a><a class="docs-heading-anchor-permalink" href="#BitStringAddresses" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.AbstractFockAddress" href="#Rimu.BitStringAddresses.AbstractFockAddress"><code>Rimu.BitStringAddresses.AbstractFockAddress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFockAddress</code></pre><p>Supertype representing a Fock state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BitString" href="#Rimu.BitStringAddresses.BitString"><code>Rimu.BitStringAddresses.BitString</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BitString{B,N} &lt;: AbstractBitString</code></pre><p>Type for storing bitstrings of static size. Holds <code>B</code> bits in <code>N</code> chunks, where each chunk is an <code>UInt64</code></p><p><code>N</code> is chosen automatically to accommodate <code>B</code> bits as efficiently as possible.</p><p><strong>Constructors</strong></p><ul><li><p><code>BitString{B,N}(::SVector{N,T})</code>: unsafe constructor. Does not check for ghost bits.</p></li><li><p><code>BitString{B,N}(i::UInt64)</code>: as above, but sets <code>i</code> as the rightmost chunk.</p></li><li><p><code>BitString{B}(::Integer)</code>: Convert integer to <code>BitString</code>. Integer is truncated to the correct number of bits.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L29-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS" href="#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoseFS{N,M,S} &lt;: AbstractFockAddress
BoseFS(bs::S) where S &lt;: BitAdd
BoseFS(bs::S, b)</code></pre><p>Address type that represents a Fock state of <code>N</code> spinless bosons in <code>M</code> orbitals by wrapping a bitstring of type <code>S</code>. Orbitals are stored in reverse order, i.e. the first orbital in a <code>BoseFS</code> is stored rightmost in the bitstring <code>bs</code>. If the number of significant bits <code>b</code> is not encoded in <code>S</code> it must be passed as an argument (e.g. for <code>BSAdd64</code> and <code>BSAdd128</code>).</p><p><strong>Constructors</strong></p><ul><li><p><code>BoseFS{N,M}(::BitString)</code>: Unsafe constructor. Does not check whether the number of ones in a is equal to <code>N</code>.</p></li><li><p><code>BoseFS(::BitString)</code>: Automatically determine <code>N</code> and <code>M</code>. This constructor is not type stable!</p></li><li><p><code>BoseFS{[N,M,S]}(onr)</code>: Create <code>BoseFS{N,M}</code> from onr representation. This is efficient as long as at least <code>N</code> is provided.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L22-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS2C" href="#Rimu.BitStringAddresses.BoseFS2C"><code>Rimu.BitStringAddresses.BoseFS2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoseFS2C{NA,NB,M,AA,AB} &lt;: AbstractFockAddress</code></pre><p>Address type that constructed with two <a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS{N,M,S}</code></a>. It represents a Fock state with two components, e.g. two different species of bosons with particle number <code>NA</code> from species S and particle number <code>NB</code> from species B. The number of orbitals <code>M</code> is expected to be the same for both components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L333-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.OccupiedOrbitalIterator" href="#Rimu.BitStringAddresses.OccupiedOrbitalIterator"><code>Rimu.BitStringAddresses.OccupiedOrbitalIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">occupied_orbitals(b)</code></pre><p>Iterate over occupied orbitals in <code>BoseFS</code> address. Returns tuples of <code>(boson_number, orbital_number, bit_offset)</code>.</p><p>Note that the <code>bit_offset</code> is zero-based!</p><p><strong>Example</strong></p><p>```jldoctest julia&gt; b = BoseFS((1,5,0,4)) julia&gt; for (n, i) in occupied_orbitals(b)     @show n, i end (n, i) = (1, 1) (n, i) = (5, 2) (n, i) = (4, 4)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L232-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}}} where {B, N}" href="#Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}}} where {B, N}"><code>Rimu.BitStringAddresses.check_bitstring_typeparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_bitstring_typeparams(::Val{B}, ::Val{N})</code></pre><p>Check if number of bits <code>B</code> is consistent with number of chunks <code>N</code>. Throw an error if not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}" href="#Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}"><code>Rimu.BitStringAddresses.chunk_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chunks_bits(s, i)</code></pre><p>Number of bits in the <code>i</code>-th chunk of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.chunks-Tuple{BitString}" href="#Rimu.BitStringAddresses.chunks-Tuple{BitString}"><code>Rimu.BitStringAddresses.chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chunks(::Type{&lt;:BitString})
chunks(s)</code></pre><p><code>SVector</code> that stores the chunks of <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L94-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString" href="#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.has_ghost_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_ghost_bits(s)</code></pre><p>Check for bits outside data field.</p><p>See also: <a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString"><code>remove_ghost_bits</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}" href="#Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.m_onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">m_onr(bs)</code></pre><p>Compute and return the occupation number representation of the bit string address <code>bs</code> as an <code>MVector{M,Int32}</code>, where <code>M</code> is the number of orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L184-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BoseFS{N, M, S} where S&lt;:BitString)}, Tuple{M}, Tuple{N}} where {N, M}" href="#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BoseFS{N, M, S} where S&lt;:BitString)}, Tuple{M}, Tuple{N}} where {N, M}"><code>Rimu.BitStringAddresses.nearUniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearUniform(BoseFS{N,M})
nearUniform(BoseFS{N,M,S}) -&gt; bfs::BoseFS{N,M,S}</code></pre><p>Create bosonic Fock state with near uniform occupation number of <code>M</code> modes with a total of <code>N</code> particles. Specifying the bit address type <code>S</code> is optional.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nearUniform(BoseFS{7,5,BitString{14}})
BoseFS((2,2,1,1,1))

julia&gt; nearUniform(BoseFS{7,5})
BoseFS((2,2,1,1,1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L155-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.nearUniformONR-Tuple{Number, Number}" href="#Rimu.BitStringAddresses.nearUniformONR-Tuple{Number, Number}"><code>Rimu.BitStringAddresses.nearUniformONR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearUniformONR(N, M) -&gt; onr::SVector{M,Int}</code></pre><p>Create occupation number representation <code>onr</code> distributing <code>N</code> particles in <code>M</code> modes in a close-to-uniform fashion with each orbital filled with at least <code>N ÷ M</code> particles and at most with <code>N ÷ M + 1</code> particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L137-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N} where N)}, Tuple{B}} where B" href="#Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N} where N)}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_bits(::Type{&lt;:BitString})
num_bits(s::BitString)</code></pre><p>Total number of bits stored in bitstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(BitString{var&quot;#s6&quot;, N} where var&quot;#s6&quot;)}, Tuple{N}} where N" href="#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(BitString{var&quot;#s6&quot;, N} where var&quot;#s6&quot;)}, Tuple{N}} where N"><code>Rimu.BitStringAddresses.num_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_chunks(::Type{&lt;:BitString})
num_chunks(s::BitString)</code></pre><p>Number of chunks in bitstring. Equivalent to <code>length(chunks(s))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B" href="#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_chunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_chunks(::Val{B})</code></pre><p>Determine the number of chunks needed to store <code>B</code> bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}" href="#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_modes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_modes(::Type{&lt;:AbstractFockAddress})</code></pre><p>Number of modes represented by address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}" href="#Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_particles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">num_particles(::Type{&lt;:AbstractFockAddress})</code></pre><p>Number of particles represented by address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.onr-Tuple{BoseFS}" href="#Rimu.BitStringAddresses.onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onr(bs)</code></pre><p>Compute and return the occupation number representation of the bit string address <code>bs</code> as an <code>SVector{M,Int32}</code>, where <code>M</code> is the number of orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bosefs.jl#L176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString" href="#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_ghost_bits(s)</code></pre><p>Remove set bits outside data field if any are present.</p><p>See also: <a href="API.html#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString"><code>has_ghost_bits</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N} where N)}, Tuple{B}} where B" href="#Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N} where N)}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.top_chunk_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">top_chunk_bits(::Type{&lt;:BitString})
top_chunk_bits(s::BitString)</code></pre><p>Number of bits stored in top chunk. Equivalent to <code>chunk_bits(s, 1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/BitStringAddresses/bitstring.jl#L80-L85">source</a></section></article><h3 id="DictVectors"><a class="docs-heading-anchor" href="#DictVectors">DictVectors</a><a id="DictVectors-1"></a><a class="docs-heading-anchor-permalink" href="#DictVectors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors" href="#Rimu.DictVectors"><code>Rimu.DictVectors</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to <code>AbstractVector</code> nor to <code>AbstractDict</code> and are suitable for use with <code>KrylovKit.jl</code>. For this, the abstract type and interface <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a> is provided, with the concrete implementation of <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/DictVectors.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractDVec" href="#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DictVectors.AbstractDVec{K,V}</code></pre><p>Abstract type for sparse vectors with <code>valtype</code> <code>V</code> based on dictionary-like structures. The vectors are designed to work well with FCIQMC and <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a>.</p><p>They lie somewhere between <code>AbstractDict</code>s and sparse <code>AbstractVector</code>s, generally behaving like a dictionary, while supportting various linear algebra functionality. Indexing with a value not stored in the dictionary returns <code>zero(V)</code>. Setting a stored value to 0 or below <code>eps(V::AbstractFloat)</code> removes the value from the dictionary. Their <code>length</code> signals the number of stored elements, not the size of the vector space.</p><p>They have a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> which selects the spawning algorithm in <code>FCIQMC</code>.</p><p>To iterate over an <code>AbstractDVec</code>, use <code>pairs</code> or <code>values</code>.</p><p><strong>Interface</strong></p><p>The interface is similar to the <code>AbstractDict</code> interface.</p><p>Implement what would be needed for the <code>AbstractDict</code> interface (<code>pairs</code>, <code>keys</code>, <code>values</code>, <code>setindex!, getindex, delete!, length, haskey, empty!, isempty</code>) and, in addition:</p><ul><li><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a></li><li><a href="API.html#Rimu.DictVectors.storage"><code>storage(dv)</code></a> returns an <code>AbstractDict</code> storing the raw data with possibly different <code>valtype</code> than <code>V</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractProjector" href="#Rimu.DictVectors.AbstractProjector"><code>Rimu.DictVectors.AbstractProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for projectors to be used in in lieu of DVecs or Vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L214-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.CoherentInitiator" href="#Rimu.DictVectors.CoherentInitiator"><code>Rimu.DictVectors.CoherentInitiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoherentInitiator(threshold) &lt;: InitiatorRule</code></pre><p>Initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li><p>Initiators can spawn anywhere.</p></li><li><p>Non-initiators can spawn to initiators.</p></li><li><p>Multiple non-initiators can spawn to a single non-initiator if their contributions add up to a value greater than the initiator threshold.</p><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L98-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.DVec" href="#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DVec{K,V,D&lt;:AbstractDict{K,V},S}</code></pre><p>Dictionary-based vector-like data structure for use with FCIQMC and <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit</a>. While mostly behaving like a <code>Dict</code>, it supports various linear algebra operations such as <code>norm</code> and <code>dot</code>. It has a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> that is used to select an appropriate spawning strategy in the FCIQMC algorithm.</p><p>See also: <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>.</p><p><strong>Constructors</strong></p><ul><li><p><code>DVec(dict::AbstractDict[; style, capacity])</code>: create a <code>DVec</code> with <code>dict</code> for storage. Note that the data may or may not be copied.</p></li><li><p><code>DVec(args...[; style, capacity])</code>: <code>args...</code> are passed to the <code>Dict</code> constructor. The <code>Dict</code> is used for storage.</p></li><li><p><code>DVec{K,V}([; style, capacity])</code>: create an empty <code>DVec{K,V}</code>.</p></li><li><p><code>DVec(dv::AbstractDVec[; style, capacity])</code>: create a <code>DVec</code> with the same contents as  <code>adv</code>. The <code>style</code> is inherited from <code>dv</code> by default.</p></li></ul><p>The default <code>style</code> is selected based on the <code>DVec</code>&#39;s <code>valtype</code> (see <a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>default_style</code></a>). If a style is given and the <code>valtype</code> does not match the <code>style</code>&#39;s <code>eltype</code>, the values are converted to an appropriate type.</p><p>The capacity argument is optional and sets the initial size of the <code>DVec</code> via <code>sizehint!</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; dv = DVec(:a =&gt; 1)
DVec{Symbol,Int64} with 1 entries, style = IsStochasticInteger{Int64}()
  :a =&gt; 1

julia&gt; dv = DVec(:a =&gt; 2, :b =&gt; 3; style=IsDynamicSemistochastic())
DVec{Symbol,Float32} with 2 entries, style = IsDynamicSemistochastic{Float64, true}(1.0, Inf, 1.0)
  :a =&gt; 2.0
  :b =&gt; 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/dvec.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Initiator" href="#Rimu.DictVectors.Initiator"><code>Rimu.DictVectors.Initiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Initiator(threshold) &lt;: InitiatorRule</code></pre><p>Initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li>Initiators can spawn anywhere.</li><li>Non-initiators can spawn to initiators.</li></ul><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorDVec" href="#Rimu.DictVectors.InitiatorDVec"><code>Rimu.DictVectors.InitiatorDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InitiatorDVec{K,V} &lt;: AbstractDVec{K,V}</code></pre><p>Dictionary-based vector-like data structure for use with <a href="@ref"><code>lomc!</code></a> and <a href="https://github.com/Jutho/KrylovKit.jl"><code>KrylovKit.jl</code></a>. See <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>. Functionally identical to <a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a>, but contains <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a>s internally in order to facilitate initiator methods. How the initiators are handled is controlled by the <code>initiator</code> keyword argument (see below).</p><p><strong>Constructors</strong></p><ul><li><p><code>InitiatorDVec(dict::AbstractDict[; style, initiator, capacity])</code>: create an <code>InitiatorDVec</code> with <code>dict</code> for storage.  Note that the data may or may not be copied.</p></li><li><p><code>InitiatorDVec(args...[; style, initiator, capacity])</code>: <code>args...</code> are passed to the <code>Dict</code> constructor. The <code>Dict</code> is used for storage.</p></li><li><p><code>InitiatorDVec{K,V}([; style, initiator, capacity])</code>: create an empty <code>InitiatorDVec{K,V}</code>.</p></li><li><p><code>InitiatorDVec(dv::AbstractDVec[; style, initiator, capacity])</code>: create an <code>InitiatorDVec</code>  with the same contents as <code>dv</code>. The <code>style</code> is inherited from <code>dv</code> by default.</p></li></ul><p><strong>Keyword  arguments</strong></p><ul><li><p><code>style</code>: A valid <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.  The default is selected based on the <code>InitiatorDVec</code>&#39;s <a href="@ref"><code>valtype</code></a> (see <a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>default_style</code></a>). If a style is given and the <code>valtype</code> does not match the <code>style</code>&#39;s <code>eltype</code>, the values are converted to an appropriate type.</p></li><li><p><code>initiator = Initiator(1)</code>: A valid <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>. See <a href="API.html#Rimu.DictVectors.Initiator"><code>Initiator</code></a>.</p></li><li><p><code>capacity</code>: Indicative size as <code>Int</code>. Optional. Sets the initial size of the <code>InitiatorDVec</code> via <a href="@ref"><code>sizehint!</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L125-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorIterator" href="#Rimu.DictVectors.InitiatorIterator"><code>Rimu.DictVectors.InitiatorIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InitiatorIterator</code></pre><p>Iterator over pairs or values of an <code>InitiatorDVec</code>. Supports the <code>SplittablesBase</code> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L299-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorRule" href="#Rimu.DictVectors.InitiatorRule"><code>Rimu.DictVectors.InitiatorRule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InitiatorRule{V}</code></pre><p>Abstract type for defining initiator rules for <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. Concrete implementations:</p><ul><li><a href="API.html#Rimu.DictVectors.Initiator"><code>Initiator</code></a></li><li><a href="API.html#Rimu.DictVectors.SimpleInitiator"><code>SimpleInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.CoherentInitiator"><code>CoherentInitiator</code></a></li></ul><p>When defining a new <code>InitiatorRule</code>, also define a corresponding method for <a href="API.html#Rimu.DictVectors.value"><code>value</code></a>!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L36-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.InitiatorValue" href="#Rimu.DictVectors.InitiatorValue"><code>Rimu.DictVectors.InitiatorValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InitiatorValue{V}(; safe::V, unsafe::V, initiator::V) where V</code></pre><p>Composite &quot;walker&quot; with three fields. For use with <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsDeterministic" href="#Rimu.DictVectors.IsDeterministic"><code>Rimu.DictVectors.IsDeterministic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsDeterministic{T=Float64}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configuration indicating deterministic propagation of walkers.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsDynamicSemistochastic" href="#Rimu.DictVectors.IsDynamicSemistochastic"><code>Rimu.DictVectors.IsDynamicSemistochastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsDynamicSemistochastic{T=Float64}(rel_threshold=1, abs_threshold=Inf, proj_threshold=1) &lt;: StochasticStyle{T}</code></pre><p>QMC propagation with non-integer walker numbers and reduced noise. All possible spawns are performed deterministically when number of walkers in a configuration is high. Stochastic vector compression with threshold <code>proj_threshold</code> is applied after spawning and diagonal death steps.</p><p>Unlike with <a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a>, when <code>late_projection</code> is set to <code>true</code>, walker annihilation is done before the stochastic vector compression.</p><p><strong>Parameters:</strong></p><ul><li><p><code>late_projection = true</code>: If set to true, threshold projection is done after all spawns are collected, otherwise, values are projected as they are being spawned.</p></li><li><p><code>rel_threshold = 1.0</code>: If the walker number on a configuration times this threshold is greater than the number of offdiagonals, spawning is done deterministically. Should be set to 1 or more for best performance.</p></li><li><p><code>abs_threshold = Inf</code>: If the walker number on a configuration is greater than this value, spawning is done deterministically. Can be set to e.g <code>abs_threshold = 0.1 * target_walkers</code>.</p></li><li><p><code>proj_threshold = 1.0</code>: Values below this number are stochastically projected to this value or zero. See also <a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a>.</p></li></ul><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L76-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochastic2Pop" href="#Rimu.DictVectors.IsStochastic2Pop"><code>Rimu.DictVectors.IsStochastic2Pop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsStochastic2Pop{T=Complex{Int}}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with complex walker numbers representing two populations of integer walkers.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L42-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochasticInteger" href="#Rimu.DictVectors.IsStochasticInteger"><code>Rimu.DictVectors.IsStochasticInteger</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsStochasticInteger{T=Int}() &lt;: StochasticStyle{T}</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation as seen in the original FCIQMC algorithm.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.IsStochasticWithThreshold" href="#Rimu.DictVectors.IsStochasticWithThreshold"><code>Rimu.DictVectors.IsStochasticWithThreshold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsStochasticWithThreshold(threshold=1.0) &lt;: StochasticStyle</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff <code>threshold</code>.</p><p>During stochastic propagation, walker numbers small than <code>threshold</code> will be stochastically projected to either zero or <code>threshold</code>.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Norm1ProjectorPPop" href="#Rimu.DictVectors.Norm1ProjectorPPop"><code>Rimu.DictVectors.Norm1ProjectorPPop</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Norm1ProjectorPPop()</code></pre><p>Results in computing the one-norm per population when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia">dot(Norm1ProjectorPPop(),x)
-&gt; norm(real.(x),1) + im*norm(imag.(x),1)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L274-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Norm2Projector" href="#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Norm2Projector()</code></pre><p>Results in computing the two-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia">dot(NormProjector(),x)
-&gt; norm(x,2) # with type Float64</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L257-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.NormProjector" href="#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormProjector()</code></pre><p>Results in computing the one-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia">dot(NormProjector(),x)
-&gt; norm(x,1)</code></pre><p><code>NormProjector()</code> thus represents the vector <code>sign.(x)</code>.</p><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L238-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.PopsProjector" href="#Rimu.DictVectors.PopsProjector"><code>Rimu.DictVectors.PopsProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PopsProjector()</code></pre><p>Results in computing the projection of one population on the other when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia">dot(PopsProjector(),x)
-&gt; real(x) ⋅ imag(x)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L302-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.SimpleInitiator" href="#Rimu.DictVectors.SimpleInitiator"><code>Rimu.DictVectors.SimpleInitiator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleInitiator(threshold) &lt;: InitiatorRule</code></pre><p>Simplified initiator rule to be passed to <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>. An initiator is a configuration <code>add</code> with a coefficient with magnitude <code>abs(v[add]) &gt; threshold</code>. Rules:</p><ul><li>Initiators can spawn anywhere.</li><li>Non-initiators cannot spawn.</li></ul><p>See <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L78-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.StochasticStyle" href="#Rimu.DictVectors.StochasticStyle"><code>Rimu.DictVectors.StochasticStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StochasticStyle(v)</code></pre><p><code>StochasticStyle</code> specifies the native style of the generalised vector <code>v</code> that determines how simulations are to proceed. This can be fully stochastic (with <code>IsStochasticInteger</code>), fully deterministic (with <code>IsDeterministic</code>), or stochastic with floating point walker numbers and threshold (with <a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>IsStochasticWithThreshold</code></a>).</p><p>When defining a new <code>StochasticStyle</code>, subtype it as <code>MyStyle&lt;:StochasticStyle{T}</code> where <code>T</code> is the concrete value type the style is designed to work with.</p><p>For it to work with FCIQMC, a <code>StochasticStyle</code> must define the following:</p><ul><li><a href="@ref"><code>fciqmc_col!(::StochasticStyle, w, H, address, value, shift, dτ)</code></a></li><li><a href="@ref"><code>step_stats(::StochasticStyle)</code></a></li></ul><p>Optionally, it can also define <a href="@ref"><code>update_dvec!</code></a>, which can be used to perform arbitrary transformations on the <code>dvec</code> after the spawning step is complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.StyleUnknown" href="#Rimu.DictVectors.StyleUnknown"><code>Rimu.DictVectors.StyleUnknown</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StyleUnknown{T}() &lt;: StochasticStyle</code></pre><p>Trait for value types not (currently) compatible with FCIQMC. This style makes it possible to construct dict vectors with unsupported <code>valtype</code>s.</p><p>See also <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L23-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.UniformProjector" href="#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniformProjector()</code></pre><p>Represents a vector with all elements 1. To be used with <a href="@ref"><code>dot()</code></a>. Minimizes memory allocations.</p><pre><code class="language-julia">UniformProjector()⋅v == sum(v)
dot(UniformProjector(), LO, v) == sum(LO*v)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L219-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K" href="#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K"><code>Rimu.DictVectors.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add!(x::AbstractDVec,y::AbstactDVec)</code></pre><p>Inplace add <code>x+y</code> and store result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer" href="#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Rimu.DictVectors.default_style</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">default_style(::Type)</code></pre><p>Pick a <a href="API.html#Rimu.DictVectors.StochasticStyle"><code>StochasticStyle</code></a> based on the value type. Throws an error if no known default style is known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/stochasticstyle.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.deposit!-NTuple{4, Any}" href="#Rimu.DictVectors.deposit!-NTuple{4, Any}"><code>Rimu.DictVectors.deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deposit!(w::AbstractDVec, add, val, parent::Pair)</code></pre><p>Add <code>val</code> into <code>w</code> at address <code>add</code>, taking into account initiator rules if applicable. <code>parent</code> contains the <code>address =&gt; value</code> pair from which the pair <code>add =&gt; val</code> was created. <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a> can intercept this and add its own functionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V" href="#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V"><code>Rimu.DictVectors.deposit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deposit!(w::InitiatorDVec, add, val, p_add=&gt;p_val)</code></pre><p>Add <code>val</code> into <code>w</code> at address <code>add</code> as an <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L266-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.localpart-Tuple{Any}" href="#Rimu.DictVectors.localpart-Tuple{Any}"><code>Rimu.DictVectors.localpart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">localpart(dv) -&gt; AbstractDVec</code></pre><p>Get the part of <code>dv</code> that is located on this MPI rank. Returns <code>dv</code> itself for <code>DictVector</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L339-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.storage" href="#Rimu.DictVectors.storage"><code>Rimu.DictVectors.storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">storage(dvec) -&gt; AbstractDict</code></pre><p>Return the raw storage associated with <code>dvec</code> as an <code>AbstractDict</code>. Used in MPI communication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.value" href="#Rimu.DictVectors.value"><code>Rimu.DictVectors.value</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">value(i::InitiatorRule, v::InitiatorValue)</code></pre><p>Convert the <a href="API.html#Rimu.DictVectors.InitiatorValue"><code>InitiatorValue</code></a> <code>v</code> into a scalar value according to the <a href="API.html#Rimu.DictVectors.InitiatorRule"><code>InitiatorRule</code></a> <code>i</code>.</p><p>Internal function that implements functionality of <a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>InitiatorDVec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/initiators.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.walkernumber-Tuple{Any}" href="#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>Rimu.DictVectors.walkernumber</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">walkernumber(w)</code></pre><p>Compute the number of walkers in <code>w</code>. It is used for updating the shift. Overload this function for modifying population control.</p><p>In most cases <code>walkernumber(w)</code> is identical to <code>norm(w,1)</code>. For <code>AbstractDVec</code>s with complex coefficients it reports the one norm separately for the real and the imaginary part as a <code>ComplexF64</code>. See <a href="API.html#Rimu.DictVectors.Norm1ProjectorPPop"><code>Norm1ProjectorPPop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L323-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.zero!-Tuple{AbstractDVec}" href="#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero!(v)</code></pre><p>Replace <code>v</code> by a zero vector as an inplace operation. For <code>AbstractDVec</code> types it means removing all non-zero elements. For <code>AbstractArrays</code>, it sets all of the values to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/2bccbbf0fbdafda756187937cbef2733fe5b1310/src/DictVectors/abstractdvec.jl#L78-L83">source</a></section></article><h3 id="StatsTools"><a class="docs-heading-anchor" href="#StatsTools">StatsTools</a><a id="StatsTools-1"></a><a class="docs-heading-anchor-permalink" href="#StatsTools" title="Permalink"></a></h3><pre><code class="language-">Modules = [StatsTools]</code></pre><h3 id="Blocking"><a class="docs-heading-anchor" href="#Blocking">Blocking</a><a id="Blocking-1"></a><a class="docs-heading-anchor-permalink" href="#Blocking" title="Permalink"></a></h3><pre><code class="language-">Modules = [Blocking]</code></pre><h3 id="ConsistentRNG"><a class="docs-heading-anchor" href="#ConsistentRNG">ConsistentRNG</a><a id="ConsistentRNG-1"></a><a class="docs-heading-anchor-permalink" href="#ConsistentRNG" title="Permalink"></a></h3><p>Link to <a href="consistentrng.html#Module-ConsistentRNG.jl">Module <code>ConsistentRNG.jl</code></a></p><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="consistentrng.html#Rimu.ConsistentRNG"><code>Rimu.ConsistentRNG</code></a></li><li><a href="API.html#Rimu.DictVectors"><code>Rimu.DictVectors</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a></li><li><a href="API.html#Rimu.Rimu"><code>Rimu.Rimu</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNGs"><code>Rimu.ConsistentRNG.CRNGs</code></a></li><li><a href="API.html#Rimu.AllOverlaps"><code>Rimu.AllOverlaps</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>Rimu.BitStringAddresses.AbstractFockAddress</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BitString"><code>Rimu.BitStringAddresses.BitString</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS2C"><code>Rimu.BitStringAddresses.BoseFS2C</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.OccupiedOrbitalIterator"><code>Rimu.BitStringAddresses.OccupiedOrbitalIterator</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNG"><code>Rimu.ConsistentRNG.CRNG</code></a></li><li><a href="API.html#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a></li><li><a href="API.html#Rimu.DelayedDoubleLogUpdate"><code>Rimu.DelayedDoubleLogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedDoubleLogUpdateAfterTW"><code>Rimu.DelayedDoubleLogUpdateAfterTW</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdate"><code>Rimu.DelayedLogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>Rimu.DelayedLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a></li><li><a href="API.html#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractProjector"><code>Rimu.DictVectors.AbstractProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.CoherentInitiator"><code>Rimu.DictVectors.CoherentInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a></li><li><a href="API.html#Rimu.DictVectors.Initiator"><code>Rimu.DictVectors.Initiator</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorDVec"><code>Rimu.DictVectors.InitiatorDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorIterator"><code>Rimu.DictVectors.InitiatorIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorRule"><code>Rimu.DictVectors.InitiatorRule</code></a></li><li><a href="API.html#Rimu.DictVectors.InitiatorValue"><code>Rimu.DictVectors.InitiatorValue</code></a></li><li><a href="API.html#Rimu.DictVectors.IsDeterministic"><code>Rimu.DictVectors.IsDeterministic</code></a></li><li><a href="API.html#Rimu.DictVectors.IsDynamicSemistochastic"><code>Rimu.DictVectors.IsDynamicSemistochastic</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochastic2Pop"><code>Rimu.DictVectors.IsStochastic2Pop</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochasticInteger"><code>Rimu.DictVectors.IsStochasticInteger</code></a></li><li><a href="API.html#Rimu.DictVectors.IsStochasticWithThreshold"><code>Rimu.DictVectors.IsStochasticWithThreshold</code></a></li><li><a href="API.html#Rimu.DictVectors.Norm1ProjectorPPop"><code>Rimu.DictVectors.Norm1ProjectorPPop</code></a></li><li><a href="API.html#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a></li><li><a href="API.html#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.PopsProjector"><code>Rimu.DictVectors.PopsProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.SimpleInitiator"><code>Rimu.DictVectors.SimpleInitiator</code></a></li><li><a href="API.html#Rimu.DictVectors.StochasticStyle"><code>Rimu.DictVectors.StochasticStyle</code></a></li><li><a href="API.html#Rimu.DictVectors.StyleUnknown"><code>Rimu.DictVectors.StyleUnknown</code></a></li><li><a href="API.html#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a></li><li><a href="API.html#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a></li><li><a href="API.html#Rimu.DoubleLogSumUpdate"><code>Rimu.DoubleLogSumUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>Rimu.DoubleLogUpdateAfterTargetWalkersSwitch</code></a></li><li><a href="API.html#Rimu.EveryKthStep"><code>Rimu.EveryKthStep</code></a></li><li><a href="API.html#Rimu.EveryTimeStep"><code>Rimu.EveryTimeStep</code></a></li><li><a href="API.html#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian"><code>Rimu.Hamiltonians.AbstractHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D"><code>Rimu.Hamiltonians.BoseHubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D"><code>Rimu.Hamiltonians.BoseHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedBHReal1D"><code>Rimu.Hamiltonians.ExtendedBHReal1D</code></a></li><li><a href="API.html#Rimu.HistoryLogUpdate"><code>Rimu.HistoryLogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a></li><li><a href="API.html#Rimu.NoMemory"><code>Rimu.NoMemory</code></a></li><li><a href="API.html#Rimu.NoStats"><code>Rimu.NoStats</code></a></li><li><a href="API.html#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a></li><li><a href="API.html#Rimu.PurgeNegatives"><code>Rimu.PurgeNegatives</code></a></li><li><a href="API.html#Rimu.QMCState"><code>Rimu.QMCState</code></a></li><li><a href="API.html#Rimu.ReplicaState"><code>Rimu.ReplicaState</code></a></li><li><a href="API.html#Rimu.ReplicaStrategy"><code>Rimu.ReplicaStrategy</code></a></li><li><a href="API.html#Rimu.Report"><code>Rimu.Report</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a></li><li><a href="API.html#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a></li><li><a href="API.html#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a></li><li><a href="API.html#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a></li><li><a href="API.html#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a></li><li><a href="API.html#Rimu.TripleLogUpdate"><code>Rimu.TripleLogUpdate</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.check_bitstring_typeparams-Union{Tuple{N}, Tuple{B}, Tuple{Val{B}, Val{N}}} where {B, N}"><code>Rimu.BitStringAddresses.check_bitstring_typeparams</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.chunk_bits-Tuple{Any, Any}"><code>Rimu.BitStringAddresses.chunk_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.chunks-Tuple{BitString}"><code>Rimu.BitStringAddresses.chunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.has_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.has_ghost_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.m_onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.m_onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BoseFS{N, M, S} where S&lt;:BitString)}, Tuple{M}, Tuple{N}} where {N, M}"><code>Rimu.BitStringAddresses.nearUniform</code></a></li><li><a href="hamiltonians.html#Rimu.BitStringAddresses.nearUniform"><code>Rimu.BitStringAddresses.nearUniform</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.nearUniformONR-Tuple{Number, Number}"><code>Rimu.BitStringAddresses.nearUniformONR</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N} where N)}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Type{var&quot;#s11&quot;} where var&quot;#s11&quot;&lt;:(BitString{var&quot;#s6&quot;, N} where var&quot;#s6&quot;)}, Tuple{N}} where N"><code>Rimu.BitStringAddresses.num_chunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_chunks-Union{Tuple{Val{B}}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.num_chunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_modes-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_modes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.num_particles-Tuple{AbstractFockAddress}"><code>Rimu.BitStringAddresses.num_particles</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.onr-Tuple{BoseFS}"><code>Rimu.BitStringAddresses.onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Tuple{S} where S&lt;:BitString"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.top_chunk_bits-Union{Tuple{Type{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:(BitString{B, N} where N)}, Tuple{B}} where B"><code>Rimu.BitStringAddresses.top_chunk_bits</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple"><code>Rimu.ConsistentRNG.cRand</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRandn-Tuple"><code>Rimu.ConsistentRNG.cRandn</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.check_crng_independence-Tuple{Any}"><code>Rimu.ConsistentRNG.check_crng_independence</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.newChildRNG"><code>Rimu.ConsistentRNG.newChildRNG</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Vector{T} where T}"><code>Rimu.ConsistentRNG.seedCRNG!</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.sync_cRandn-Tuple{Any}"><code>Rimu.ConsistentRNG.sync_cRandn</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}"><code>Rimu.ConsistentRNG.trng</code></a></li><li><a href="API.html#Rimu.DictVectors.add!-Union{Tuple{K}, Tuple{AbstractDVec{K, V} where V, AbstractDVec{K, V} where V}} where K"><code>Rimu.DictVectors.add!</code></a></li><li><a href="API.html#Rimu.DictVectors.default_style-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Integer"><code>Rimu.DictVectors.default_style</code></a></li><li><a href="API.html#Rimu.DictVectors.deposit!-NTuple{4, Any}"><code>Rimu.DictVectors.deposit!</code></a></li><li><a href="API.html#Rimu.DictVectors.deposit!-Union{Tuple{V}, Tuple{InitiatorDVec{var&quot;#s6&quot;, V, D, S, I} where {var&quot;#s6&quot;, D&lt;:AbstractDict{var&quot;#s6&quot;, Rimu.DictVectors.InitiatorValue{V}}, S&lt;:StochasticStyle{V}, I&lt;:Rimu.DictVectors.InitiatorRule}, Any, Any, Any}} where V"><code>Rimu.DictVectors.deposit!</code></a></li><li><a href="API.html#Rimu.DictVectors.localpart-Tuple{Any}"><code>Rimu.DictVectors.localpart</code></a></li><li><a href="API.html#Rimu.DictVectors.storage"><code>Rimu.DictVectors.storage</code></a></li><li><a href="API.html#Rimu.DictVectors.value"><code>Rimu.DictVectors.value</code></a></li><li><a href="API.html#Rimu.DictVectors.walkernumber-Tuple{Any}"><code>Rimu.DictVectors.walkernumber</code></a></li><li><a href="API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a></li><li><a href="API.html#Rimu.advance!-Union{Tuple{T}, Tuple{Any, Rimu.QMCState, Rimu.ReplicaState{T, V, W, R} where {V, W, R&lt;:FciqmcRunStrategy{T}}}} where T"><code>Rimu.advance!</code></a></li><li><a href="API.html#Rimu.apply_memory_noise!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.apply_memory_noise!</code></a></li><li><a href="API.html#Rimu.compute_proj_observables-Tuple{Any, Any, ReportingStrategy{Nothing, Nothing}}"><code>Rimu.compute_proj_observables</code></a></li><li><a href="API.html#Rimu.fciqmc_col!-Union{Tuple{T}, Tuple{K}, Tuple{Union{AbstractDVec{K, T}, AbstractArray{T, N} where N}, Any, Any, Any, Any, Any}} where {K, T&lt;:Real}"><code>Rimu.fciqmc_col!</code></a></li><li><a href="API.html#Rimu.fciqmc_step!"><code>Rimu.fciqmc_step!</code></a></li><li><a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>Rimu.lomc!</code></a></li><li><a href="API.html#Rimu.print_report-Tuple{ReportingStrategy, Vararg{Any, N} where N}"><code>Rimu.print_report</code></a></li><li><a href="API.html#Rimu.refine_r_strat-Tuple{ReportingStrategy, Any}"><code>Rimu.refine_r_strat</code></a></li><li><a href="API.html#Rimu.replica_stats"><code>Rimu.replica_stats</code></a></li><li><a href="API.html#Rimu.report!-Tuple{EveryTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.report!-Tuple{Any, Any, Any}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.sort_into_targets!-Tuple{Any, Any, Any}"><code>Rimu.sort_into_targets!</code></a></li><li><a href="API.html#Rimu.step_stats-Tuple{StochasticStyle}"><code>Rimu.step_stats</code></a></li><li><a href="API.html#Rimu.threshold_projected_deposit!-Tuple{IsDynamicSemistochastic{var&quot;#s249&quot;, false} where var&quot;#s249&quot;, Any, Any, Any, Any}"><code>Rimu.threshold_projected_deposit!</code></a></li><li><a href="API.html#Rimu.update_dvec!-Tuple{StochasticStyle, Any}"><code>Rimu.update_dvec!</code></a></li><li><a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep, Any, Vararg{Any, N} where N}"><code>Rimu.update_dτ</code></a></li><li><a href="API.html#Rimu.update_shift-Tuple{HistoryLogUpdate, Any, Any, Any, Any, Any, Any, Any, Vararg{Any, N} where N}"><code>Rimu.update_shift</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="testing.html">« Code testing</a><a class="docs-footer-nextpage" href="BHM-example.html">Example: 1D Bose-Hubbard Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 1 June 2021 00:00">Tuesday 1 June 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
