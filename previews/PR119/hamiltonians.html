<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hamiltonians · Rimu.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Rimu.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="generated/BHM-example.html">1D Bose-Hubbard Model</a></li><li><a class="tocitem" href="generated/BHM-example-mpi.html">Using MPI</a></li></ul></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="statstools.html">StatsTools</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li class="is-active"><a class="tocitem" href="hamiltonians.html">Hamiltonians</a><ul class="internal"><li><a class="tocitem" href="#Model-Hamiltonians"><span>Model Hamiltonians</span></a></li><li><a class="tocitem" href="#Hamiltonians-interface"><span>Hamiltonians interface</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li></ul></li><li><a class="tocitem" href="dictvectors.html">Dict vectors</a></li><li><a class="tocitem" href="addresses.html">BitString addresses</a></li><li><a class="tocitem" href="stochasticstyles.html">Stochastic styles</a></li><li><a class="tocitem" href="RMPI.html">RMPI</a></li><li><a class="tocitem" href="consistentrng.html">Random Numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li><a class="tocitem" href="API.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer documentation</a></li><li class="is-active"><a href="hamiltonians.html">Hamiltonians</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hamiltonians.html">Hamiltonians</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/master/docs/src/hamiltonians.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-Hamiltionians"><a class="docs-heading-anchor" href="#Module-Hamiltionians">Module <code>Hamiltionians</code></a><a id="Module-Hamiltionians-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Hamiltionians" title="Permalink"></a></h1><p>This module contains definitions of Hamiltonians, in particular specific physical models of interest. These are organised by means of an interface around the abstract type <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>, in the spirit of the <code>AbstractArray</code> interface as discussed in the <a href="https://docs.julialang.org/en/v1/manual/interfaces/">Julia Documentation</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians" href="#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Hamiltonians</code></pre><p>This module defines Hamiltonian types and functions for working with Hamiltonians.</p><p><strong>Exported concrete Hamiltonian types include</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian"><code>MatrixHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>BoseHubbardReal1D2C</code></a></li></ul><p><strong>Wrappers</strong></p><ul><li><a href="@ref"><code>GutzwillerSampling</code></a></li><li><a href="@ref"><code>GuidingVectorSampling</code></a></li></ul><p><strong>Other</strong></p><ul><li><a href="@ref"><code>G2Correlator</code></a></li></ul><p><strong>Interface for working with Hamiltonians</strong></p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>: defined in the module <a href="interfaces.html#Rimu.Interfaces"><code>Interfaces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/Hamiltonians.jl#L1-L24">source</a></section></article><h3 id="Relation-to-other-parts-of-the-Rimu-code"><a class="docs-heading-anchor" href="#Relation-to-other-parts-of-the-Rimu-code">Relation to other parts of the <code>Rimu</code> code</a><a id="Relation-to-other-parts-of-the-Rimu-code-1"></a><a class="docs-heading-anchor-permalink" href="#Relation-to-other-parts-of-the-Rimu-code" title="Permalink"></a></h3><p>In order to define a specific model Hamiltonian with relevant parameters for the model, instantiate the model like this in the input file:</p><p><code>ham = HubbardReal1D(BoseFS((1,2,0,3)); u=1.0, t=1.0)</code></p><p>In the rest of the <code>Rimu</code> code, access to properties and matrix elements of the model are then provided by the following methods:</p><ul><li><code>ham[address1, address2]</code>:  indexing of matrix elements (slow - use with caution)</li><li><code>ham * dv</code>, <code>ham(dv::AbstractDVec)</code> or <code>mul!(dv1, ham, dv2)</code>: use as linear operator</li><li><a href="hamiltonians.html#Rimu.Interfaces.diagonal_element"><code>diagonal_element(ham, add)</code></a>: diagonal matrix element</li><li><a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>num_offdiagonals(ham, add)</code></a>: number of off-diagonals</li><li><a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>get_offdiagonal(ham, add, chosen)</code></a>: access off-diagonal matrix element</li><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals(ham, add)</code></a>: iterator over off-diagonal matrix elements</li><li><a href="hamiltonians.html#Rimu.Interfaces.random_offdiagonal"><code>random_offdiagonal(hops)</code></a>: choose random off-diagonal</li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>dimension(T, ham)</code></a>: dimension of linear space</li><li><a href="addresses.html#Rimu.BitStringAddresses.near_uniform"><code>near_uniform(ham)</code></a>: configuration with particles spread across modes</li><li><a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address(ham)</code></a>: address for accessing one of the diagonal elements of <code>ham</code></li></ul><h2 id="Model-Hamiltonians"><a class="docs-heading-anchor" href="#Model-Hamiltonians">Model Hamiltonians</a><a id="Model-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Hamiltonians" title="Permalink"></a></h2><p>Here is a list of fully implemented model Hamiltonians. So far there are two variants implemented of the one-dimensional Bose-Hubbard model real space as well as a momentum-space Hubbard chain.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardReal1D" href="#Rimu.Hamiltonians.HubbardReal1D"><code>Rimu.Hamiltonians.HubbardReal1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardReal1D(address; u=1.0, t=1.0)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in real space.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \frac{u}{2}\sum_i n_i (n_i-1)\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/HubbardReal1D.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.ExtendedHubbardReal1D" href="#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>Rimu.Hamiltonians.ExtendedHubbardReal1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExtendedHubbardReal1D(address; u=1.0, v=1.0, t=1.0)</code></pre><p>Implements the extended Hubbard model on a one-dimensional chain in real space.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \frac{u}{2}\sum_i n_i (n_i-1) + v \sum_{\langle i,j\rangle} n_i n_j\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address.</li><li><code>u</code>: on-site interaction parameter</li><li><code>v</code>: the next-neighbor interaction</li><li><code>t</code>: the hopping strength</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/ExtendedHubbardReal1D.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardMom1D" href="#Rimu.Hamiltonians.HubbardMom1D"><code>Rimu.Hamiltonians.HubbardMom1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardMom1D(address; u=1.0, t=1.0, dispersion=hubbard_dispersion)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space.</p><p class="math-container">\[\hat{H} =  \sum_{k} ϵ_k n_k + \frac{u}{M}\sum_{kpqr} a^†_{r} a^†_{q} a_p a_k δ_{r+q,p+k}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li><li><code>dispersion</code>: defines <span>$ϵ_k =$</span><code>t*dispersion(k)</code><ul><li><a href="@ref"><code>hubbard_dispersion</code></a>: <span>$ϵ_k = -2t \cos(k)$</span></li><li><a href="@ref"><code>continuum_dispersion</code></a>: <span>$ϵ_k = tk^2$</span></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/HubbardMom1D.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.BoseHubbardReal1D2C" href="#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>Rimu.Hamiltonians.BoseHubbardReal1D2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseHubbardReal1D2C(address::BoseFS2C; ua=1.0, ub=1.0, ta=1.0, tb=1.0, v=1.0)</code></pre><p>Implements a two-component one-dimensional Bose Hubbard chain in real space.</p><p class="math-container">\[\hat{H} = \hat{H}_a + \hat{H}_b + V\sum_{i} n_{a_i}n_{b_i}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>ua</code>: the on-site interaction parameter parameter for Hamiltonian a.</li><li><code>ub</code>: the on-site interaction parameter parameter for Hamiltonian b.</li><li><code>ta</code>: the hopping strength for Hamiltonian a.</li><li><code>tb</code>: the hopping strength for Hamiltonian b.</li><li><code>v</code>: the inter-species interaction parameter V.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/BoseHubbardReal1D2C.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.BoseHubbardMom1D2C" href="#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>Rimu.Hamiltonians.BoseHubbardMom1D2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseHubbardMom1D2C(add::BoseFS2C; ua=1.0, ub=1.0, ta=1.0, tb=1.0, v=1.0, kwargs...)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space with a two-component Bose gas.</p><p class="math-container">\[\hat{H} = \hat{H}_a + \hat{H}_b + \frac{V}{M}\sum_{kpqr} b^†_{r} a^†_{q} b_p a_k δ_{r+q,p+k}\]</p><p><strong>Arguments</strong></p><ul><li><code>add</code>: the starting address.</li><li><code>ua</code>: the <code>u</code> parameter for Hamiltonian a.</li><li><code>ub</code>: the <code>u</code> parameter for Hamiltonian b.</li><li><code>ta</code>: the <code>t</code> parameter for Hamiltonian a.</li><li><code>tb</code>: the <code>t</code> parameter for Hamiltonian b.</li><li><code>v</code>: the inter-species interaction parameter V.</li></ul><p>Further keyword arguments are passed on to the constructor of <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>.</p><p><strong>See also</strong></p><ul><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS2C"><code>BoseFS2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>BoseHubbardReal1D2C</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/BoseHubbardMom1D2C.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardRealSpace" href="#Rimu.Hamiltonians.HubbardRealSpace"><code>Rimu.Hamiltonians.HubbardRealSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardRealSpace(address; u=ones(C, C), t=ones(C), geometry=PeriodicBoundaries(M,))</code></pre><p>Hubbard model in real space. Supports single or multi-component Fock state addresses (with <code>C</code> components) and various (rectangular) lattice geometries in arbitrary dimensions.</p><p class="math-container">\[  \hat{H} = -\sum_{\langle i,j\rangle,σ} t_σ a^†_{iσ} a_{jσ} +
  \frac{1}{2}\sum_{i,σ} u_{σ,σ} n_{iσ} (n_{iσ} - 1) +
  \frac{1}{2}\sum_{i,σ≠τ}u_{σ,τ} n_{iσ} n_{iτ}\]</p><p><strong>Address types</strong></p><ul><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>: Single-component Bose-Hubbard model.</li><li><a href="addresses.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>: Single-component Fermi-Hubbard model. This address only provides a single species of (non-interacting) fermions. You probably want to use <a href="addresses.html#Rimu.BitStringAddresses.CompositeFS"><code>CompositeFS</code></a>.</li><li><a href="addresses.html#Rimu.BitStringAddresses.CompositeFS"><code>CompositeFS</code></a>: For multi-component models.</li></ul><p><strong>Geometries</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul><p><strong>Other parameters</strong></p><ul><li><code>u</code>: the on-site interaction parameters. Must be a symmetric matrix. <code>u[i, j]</code> corresponds to the interaction between the <code>i</code>-th and <code>j</code>-th component. <code>u[i, i]</code> corresponds to the interaction of a component with itself. Note that <code>u[i,i]</code> must be zero for fermionic components.</li><li><code>t</code>: the hopping strengths. Must be a vector of length <code>C</code>. The <code>i</code>-th element of the vector corresponds to the hopping strength of the <code>i</code>-th component.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/HubbardRealSpace.jl#L119-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.MatrixHamiltonian" href="#Rimu.Hamiltonians.MatrixHamiltonian"><code>Rimu.Hamiltonians.MatrixHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixHamiltonian(
    mat::AbstractMatrix{T};
    starting_address::Int = starting_address(mat)
) &lt;: AbstractHamiltonian{T}</code></pre><p>Wrap an abstract matrix <code>mat</code> as an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> object for use with regular <code>Vector</code>s indexed by integers. Works with stochastic methods of <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!()</code></a>. Optionally, a <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a> can be provided.</p><p>Specialised methods are implemented for sparse matrices of type <code>AbstractSparseMatrixCSC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/MatrixHamiltonian.jl#L1-L11">source</a></section></article><h2 id="Hamiltonians-interface"><a class="docs-heading-anchor" href="#Hamiltonians-interface">Hamiltonians interface</a><a id="Hamiltonians-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians-interface" title="Permalink"></a></h2><p>Behind the implementation of a particular model is a more abstract interface for defining hamiltonians. If you want to define a new model you should make use of this interface. The most general form of a model Hamiltonian should subtype to <code>AbstractHamiltonian</code> and implement the relevant methods.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.AbstractHamiltonian" href="#Rimu.Interfaces.AbstractHamiltonian"><code>Rimu.Interfaces.AbstractHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHamiltonian{T}</code></pre><p>Supertype that provides an interface for linear operators over a linear space with scalar type <code>T</code> that are suitable for FCIQMC (with <a href="@ref"><code>lomc!</code></a>). Indexing is done with addresses (typically not integers) from an address space that may be large (and will not need to be completely generated).</p><p><code>AbstractHamiltonian</code> instances operate on vectors of type <a href="dictvectors.html#Rimu.Interfaces.AbstractDVec"><code>AbstractDVec</code></a> from the module <code>DictVectors</code> and work well with addresses of type <a href="@ref"><code>AbstractFockAddress</code></a> from the module <code>BitStringAddresses</code>. The type works well with the external package <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit.jl</a>.</p><p>For available implementations see <a href="@ref"><code>Hamiltonians</code></a>.</p><p><strong>Interface</strong></p><p>Methods that need to be implemented:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>num_offdiagonals(::AbstractHamiltonian, address)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>get_offdiagonal(::AbstractHamiltonian, address, chosen::Integer)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.diagonal_element"><code>diagonal_element(::AbstractHamiltonian, address)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address(::AbstractHamiltonian)</code></a></li></ul><p>Optional methods to implement:</p><ul><li><a href="@ref"><code>LOStructure(::Type{typeof(lo)})</code></a>: defaults to <code>AdjointUnknown</code></li><li><a href="@ref"><code>dimension(::Type{T}, ::AbstractHamiltonian)</code></a>: defaults to dimension of address space</li><li><a href="@ref"><code>momentum(::AbstractHamiltonian)</code></a>: no default</li></ul><p>Provides:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>: iterator over reachable off-diagonal matrix elements</li><li><a href="hamiltonians.html#Rimu.Interfaces.random_offdiagonal"><code>random_offdiagonal</code></a>: function to generate random off-diagonal matrix element</li><li><code>*(H, v)</code>: deterministic matrix-vector multiply (allocating)</li><li><code>H(v)</code>: equivalent to <code>H * v</code>.</li><li><code>mul!(w, H, v)</code>: mutating matrix-vector multiply.</li><li><a href="@ref"><code>dot(x, H, v)</code></a>: compute <code>x⋅(H*v)</code> minimizing allocations.</li><li><code>H[address1, address2]</code>: indexing with <code>getindex()</code> - mostly for testing purposes (slow!)</li><li><a href="@ref"><code>BasisSetRep</code></a>: construct a basis set repesentation</li><li><a href="@ref"><code>sparse</code></a>, <a href="@ref"><code>Matrix</code></a>: construct a (sparse) matrix representation</li></ul><p>See also <a href="@ref"><code>Hamiltonians</code></a>, <a href="interfaces.html#Rimu.Interfaces"><code>Interfaces</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L4-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.offdiagonals" href="#Rimu.Interfaces.offdiagonals"><code>Rimu.Interfaces.offdiagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offdiagonals(h::AbstractHamiltonian, address)</code></pre><p>Return an iterator over reachable off-diagonal matrix elements of type <code>&lt;:AbstractOffdiagonals</code>. Defaults to returning <code>Offdiagonals(h, a)</code></p><p><strong>See also</strong></p><ul><li><a href="@ref"><code>Offdiagonals</code></a></li><li><a href="@ref"><code>AbstractOffdiagonals</code></a></li></ul><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3,2,1));


julia&gt; H = HubbardReal1D(addr);


julia&gt; h = offdiagonals(H, addr)
6-element Rimu.Hamiltonians.Offdiagonals{BoseFS{6, 3, BitString{8, 1, UInt8}}, Float64, HubbardReal1D{Float64, BoseFS{6, 3, BitString{8, 1, UInt8}}, 1.0, 1.0}}:
 (BoseFS{6,3}((2, 3, 1)), -3.0)
 (BoseFS{6,3}((2, 2, 2)), -2.449489742783178)
 (BoseFS{6,3}((3, 1, 2)), -2.0)
 (BoseFS{6,3}((4, 1, 1)), -2.8284271247461903)
 (BoseFS{6,3}((4, 2, 0)), -2.0)
 (BoseFS{6,3}((3, 3, 0)), -1.7320508075688772)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L138-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.diagonal_element" href="#Rimu.Interfaces.diagonal_element"><code>Rimu.Interfaces.diagonal_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diagonal_element(g::G2Correlator, add::BoseFS2C{NA,NB,M,AA,AB})</code></pre><p>The diagonal element in <a href="@ref"><code>G2Correlator</code></a>, where <code>(p-q)=0</code>, hence it becomes</p><p class="math-container">\[\frac{1}{M}\sum_{k,p=1}^M a^†_{k} b^†_{p}  b_p a_k .\]</p><p><strong>See also</strong></p><ul><li><a href="@ref"><code>G2Correlator</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/TwoBodyCorrelation.jl#L83-L94">source</a></section><section><div><pre><code class="nohighlight hljs">diagonal_element(ham, add)</code></pre><p>Compute the diagonal matrix element of the linear operator <code>ham</code> at address <code>add</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; diagonal_element(H, addr)
8.666666666666664</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.starting_address" href="#Rimu.Interfaces.starting_address"><code>Rimu.Interfaces.starting_address</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">starting_address(h)</code></pre><p>Return the starting address for Hamiltonian <code>h</code>. Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface. When called on an <code>AbstractMatrix</code> return the index of the lowest diagonal element.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; addr == starting_address(H)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L116-L135">source</a></section></article><p>The following functions may be implemented instead of <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.num_offdiagonals" href="#Rimu.Interfaces.num_offdiagonals"><code>Rimu.Interfaces.num_offdiagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_offdiagonals(ham, add)</code></pre><p>Compute the number of number of reachable configurations from address <code>add</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; num_offdiagonals(H, addr)
10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L74-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.get_offdiagonal" href="#Rimu.Interfaces.get_offdiagonal"><code>Rimu.Interfaces.get_offdiagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newadd, me = get_offdiagonal(ham, add, chosen)</code></pre><p>Compute value <code>me</code> and new address <code>newadd</code> of a single (off-diagonal) matrix element in a Hamiltonian <code>ham</code>. The off-diagonal element is in the same column as address <code>add</code> and is indexed by integer index <code>chosen</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(addr);


julia&gt; get_offdiagonal(H, addr, 3)
(BoseFS{6,3}((2, 1, 3)), 1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L94-L113">source</a></section></article><p>The following functions come with default implementations, but may be customized.</p><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.random_offdiagonal" href="#Rimu.Interfaces.random_offdiagonal"><code>Rimu.Interfaces.random_offdiagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_offdiagonal(offdiagonals::AbstractOffdiagonals)
random_offdiagonal(ham::AbstractHamiltonian, add)</code></pre><p>Generate a single random excitation, i.e. choose from one of the accessible off-diagonal elements in the column corresponding to address <code>add</code> of the Hamiltonian matrix represented by <code>ham</code>. Alternatively, pass as argument an iterator over the accessible matrix elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L173-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Interfaces.LOStructure" href="#Rimu.Interfaces.LOStructure"><code>Rimu.Interfaces.LOStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LOStructure(op::AbstractHamiltonian)
LOStructure(typeof(op))</code></pre><p><code>LOStructure</code> speficies properties of the linear operator <code>op</code>. If a special structure is known this can speed up calculations. Implemented structures are:</p><ul><li><code>IsHermitian</code>: The operator is complex and Hermitian or real and symmetric.</li><li><code>AdjointKnown</code>: The operator is not Hermitian, but its <a href="@ref"><code>adjoint</code></a> is implemented.</li><li><code>AdjointUnknown</code>: <a href="@ref"><code>adjoint</code></a> for this operator is not implemented.</li></ul><p>In order to define this trait for a new linear operator type, define a method for <code>LOStructure(::Type{&lt;:MyNewLOType}) = …</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Interfaces/hamiltonians.jl#L193-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.dimension" href="#Rimu.Hamiltonians.dimension"><code>Rimu.Hamiltonians.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimension(::Type{T}, h)</code></pre><p>Return the dimension of Hilbert space as <code>T</code>. If the result does not fit into <code>T</code>, return <code>nothing</code>. If <code>T&lt;:AbstractFloat</code>, an approximate value computed with the improved Stirling formula may be returned instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dimension(HubbardMom1D(BoseFS((1,2,3))))
28
julia&gt; dimension(HubbardMom1D(near_uniform(BoseFS{200,100})))


julia&gt; dimension(Float64, HubbardMom1D(near_uniform(BoseFS{200,100})))
1.3862737677578234e81
julia&gt; dimension(BigInt, HubbardMom1D(near_uniform(BoseFS{200,100})))
1386083821086188248261127842108801860093488668581216236221011219101585442774669540</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/abstract.jl#L21-L41">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.LatticeGeometry" href="#Rimu.Hamiltonians.LatticeGeometry"><code>Rimu.Hamiltonians.LatticeGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type LatticeGeometry</code></pre><p>A <code>LatticeGeometry</code> controls which sites in an <a href="addresses.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>AbstractFockAddress</code></a> are considered to be neighbours.</p><p>Currently only supported by <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><p><strong>Available implementations</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul><p><strong>Interface to implement</strong></p><ul><li><code>Base.size</code>: return the lattice size.</li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site(::LatticeGeometry, ::Int, ::Int)</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>num_neighbours(::LatticeGeometry)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/geometry.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.PeriodicBoundaries" href="#Rimu.Hamiltonians.PeriodicBoundaries"><code>Rimu.Hamiltonians.PeriodicBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundaries(size...) &lt;: LatticeGeometry</code></pre><p>Rectangular lattice with periodic boundary conditions of size <code>size</code>.</p><p>The dimension of the lattice is controlled by the number of arguments given to its constructor.</p><p>This is the default geometry used by <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = PeriodicBoundaries(5, 4) # 2D lattice of size 5 × 4
PeriodicBoundaries(5, 4)

julia&gt; num_neighbours(lattice)
4

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
5

julia&gt; neighbour_site(lattice, 1, 3)
6

julia&gt; neighbour_site(lattice, 1, 4)
16</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>num_neighbours</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/geometry.jl#L59-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.HardwallBoundaries" href="#Rimu.Hamiltonians.HardwallBoundaries"><code>Rimu.Hamiltonians.HardwallBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HardwallBoundaries</code></pre><p>Rectangular lattice with hard wall boundary conditions of size <code>size</code>. <a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site()</code></a> will return 0 for some neighbours of boundary sites.</p><p>The dimension of the lattice is controlled by the number of arguments given to its constructor.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = HardwallBoundaries(5) # 1D lattice of size 5
HardwallBoundaries(5)

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
0
</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/geometry.jl#L128-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.LadderBoundaries" href="#Rimu.Hamiltonians.LadderBoundaries"><code>Rimu.Hamiltonians.LadderBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LadderBoundaries(size...; subgeometry=PeriodicBoundaries) &lt;: LatticeGeometry</code></pre><p>Lattice geometry where the first dimension is of size 2 and has hardwall boundary conditions. Using this geometry is more efficient than using <a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a> with a size of 2, as it does not generate rejected neighbours.</p><p>In other dimensions, it behaves like its subgeometry, which can be any <a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = LadderBoundaries(2, 3, 4) # 3D lattice of size 2 × 3 × 4
LadderBoundaries(2, 3, 4)

julia&gt; num_neighbours(lattice)
5

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
3

julia&gt; neighbour_site(lattice, 1, 3)
5

julia&gt; neighbour_site(lattice, 1, 4)
7

julia&gt; neighbour_site(lattice, 1, 5)
19</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/geometry.jl#L182-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.num_neighbours" href="#Rimu.Hamiltonians.num_neighbours"><code>Rimu.Hamiltonians.num_neighbours</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_neighbours(geom::LatticeGeometry)</code></pre><p>Return the number of neighbours each lattice site has in this geometry.</p><p>Note that for efficiency reasons, all sites are expected to have the same number of neighbours. If some of the neighbours are invalid, this is handled by having <a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site</code></a> return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/geometry.jl#L47-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Hamiltonians.neighbour_site" href="#Rimu.Hamiltonians.neighbour_site"><code>Rimu.Hamiltonians.neighbour_site</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighbour_site(geom::LatticeGeometry, site, i)</code></pre><p>Find the <code>i</code>-th neighbour of <code>site</code> in the geometry. If the move is illegal, return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/08639e986bf870a6b14360d24387a191eb551ffc/src/Hamiltonians/geometry.jl#L40-L44">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="interfaces.html">« Interfaces</a><a class="docs-footer-nextpage" href="dictvectors.html">Dict vectors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 22 October 2021 00:54">Friday 22 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
