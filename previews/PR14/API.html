<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Rimu.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Rimu.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="consistentrng.html">Random Numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li class="is-active"><a class="tocitem" href="API.html">API</a><ul class="internal"><li><a class="tocitem" href="#Rimu"><span>Rimu</span></a></li><li><a class="tocitem" href="#Reexported-Submodules"><span>Reexported Submodules</span></a></li><li><a class="tocitem" href="#Unexported-Submodules"><span>Unexported Submodules</span></a></li><li class="toplevel"><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="BHM-example.html">Example: 1D Bose-Hubbard Model</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="API.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="API.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/joachimbrand/Rimu.jl/blob/master/docs/src/API.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Rimu"><a class="docs-heading-anchor" href="#Rimu">Rimu</a><a id="Rimu-1"></a><a class="docs-heading-anchor-permalink" href="#Rimu" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Rimu.Rimu" href="#Rimu.Rimu"><code>Rimu.Rimu</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Rimu</code></pre><p>Random Integrator for Many-Body Quantum Systems</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Rimu.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ConstantTimeStep" href="#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Keep <code>dτ</code> constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedDoubleLogUpdate" href="#Rimu.DelayedDoubleLogUpdate"><code>Rimu.DelayedDoubleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedDoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> and delay of <code>A</code> steps. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p><div>\[S^{n+A} = S^n -\frac{ζ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^n}\right)-\frac{ξ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^\text{target}}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L507-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedDoubleLogUpdateAfterTW" href="#Rimu.DelayedDoubleLogUpdateAfterTW"><code>Rimu.DelayedDoubleLogUpdateAfterTW</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedDoubleLogUpdateAfterTW(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4, A=10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> and delay of <code>A</code> steps after the number of target walkers is reached. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p><div>\[S^{n+A} = S^n -\frac{ζ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^n}\right)-\frac{ξ}{A dτ}\ln\left(\frac{\|Ψ\|_1^{n+A}}{\|Ψ\|_1^\text{target}}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L525-L534">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedLogUpdate" href="#Rimu.DelayedLogUpdate"><code>Rimu.DelayedLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedLogUpdate(ζ = 0.08, a = 10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and delay of <code>a</code> steps.</p><div>\[S^{n+a} = S^n -\frac{ζ}{a dτ}\ln\left(\frac{\|Ψ\|_1^{n+a}}{\|Ψ\|_1^n}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L541-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DelayedLogUpdateAfterTargetWalkers" href="#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>Rimu.DelayedLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedLogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, a = 10) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and delay of <code>a</code> steps. See <a href="API.html#Rimu.DelayedLogUpdate"><code>DelayedLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L391-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory" href="#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = (pnorm - tnorm)/(dτ*pnorm) + shift
r = r̃ - &lt;r̃&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L227-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory2" href="#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory2(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, memory noise with a memory length of <code>Δ</code> is applied, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = pnorm - tnorm + shift*dτ*pnorm
r = (r̃ - &lt;r̃&gt;)/(dτ*pnorm)</code></pre><p>The long-term average of <code>r</code> is not guaranteed to be zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L244-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DeltaMemory3" href="#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeltaMemory3(Δ::Int, level::Float64) &lt;: MemoryStrategy</code></pre><p>Before updating the shift, apply multiplicative memory noise with a memory length of <code>Δ</code> at level <code>level</code>, where <code>Δ = 1</code> means no memory noise.</p><pre><code class="language-none">r̃ = (pnorm - tnorm)/pnorm + dτ*shift
r = r̃ - &lt;r̃&gt;
w .*= 1 + level*r</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L262-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DontUpdate" href="#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><p><code>DontUpdate() &lt;: ShiftStrategy</code> Don&#39;t update the <code>shift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogProjected" href="#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DoubleLogProjected(; target, projector, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code> after projecting onto <code>projector</code>.</p><div>\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{P⋅Ψ^{(n)}}\right)-\frac{ξ}{dτ}\ln\left(\frac{P⋅Ψ^{(n+1)}}{\text{target}}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L431-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdate" href="#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DoubleLogUpdate(; targetwalkers = 1000, ζ = 0.08, ξ = ζ^2/4) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>.</p><div>\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)-\frac{ξ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^\text{target}}\right)\]</div><p>When ξ = ζ^2/4 this corresponds to critical damping with a damping time scale T = 2/ζ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L413-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkers" href="#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08, ξ = 0.0016) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L479-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DoubleLogUpdateAfterTargetWalkersSwitch" href="#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>Rimu.DoubleLogUpdateAfterTargetWalkersSwitch</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkersSwitch(targetwalkers, ζ = 0.08, ξ = 0.0016) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code> and <code>ξ</code>. After <code>a</code> steps the strategy switches to <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>. See <a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L493-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.EveryKthStep" href="#Rimu.EveryKthStep"><code>Rimu.EveryKthStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EveryKthStep(;k = 10, projector = missing)</code></pre><p>Report every <code>k</code>th step. Include projection onto <code>projector</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.EveryTimeStep" href="#Rimu.EveryTimeStep"><code>Rimu.EveryTimeStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EveryTimeStep(;projector = missing)</code></pre><p>Report every time step. Include projection onto <code>projector</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FciqmcRunStrategy" href="#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type representing the strategy for running and terminating <a href="API.html#Rimu.fciqmc!"><code>fciqmc!()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.RunTillLastStep"><code>RunTillLastStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L16-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.HistoryLogUpdate" href="#Rimu.HistoryLogUpdate"><code>Rimu.HistoryLogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HistoryLogUpdate(df::DataFrame; d = 100, k=1, ζ= 0.08)</code></pre><p>Strategy for updating the shift according to log formula but with walker numbers accumulated from <code>k</code> samples of the history with delay <code>d</code>. A recent history has to be passed with the data frame <code>df</code> for initialisation.</p><div>\[N_w^{n} = \sum_{i=0}^{k-1} \|Ψ\|_1^{n-i} \\
S^{n+a} = S^n -\frac{ζ}{a dτ}\ln\left(\frac{N_w^{n+1}}{N_w^n}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L554-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.IsSemistochastic" href="#Rimu.IsSemistochastic"><code>Rimu.IsSemistochastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsSemistochastic(threshold::Float16, d_space)</code></pre><p>Trait for generalised vector of configurations indicating semistochastic propagation. Set with <a href="API.html#Rimu.setSemistochastic!-Tuple{Any,Float16,Any}"><code>setSemistochastic!</code></a>.</p><pre><code class="language-none">&gt; StochasticStyle(V) = IsSemistochastic(threshold, d_space)</code></pre><p>where <code>d_space</code> is a vector of addresses defining the the stochastic subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L792-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.IsStochasticWithThreshold" href="#Rimu.IsStochasticWithThreshold"><code>Rimu.IsStochasticWithThreshold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IsStochasticWithThreshold(threshold::Float16)</code></pre><p>Trait for generalised vector of configurations indicating stochastic propagation with real walker numbers and cutoff <code>threshold</code>.</p><pre><code class="language-none">&gt; StochasticStyle(V) = IsStochasticWithThreshold(threshold)</code></pre><p>During stochastic propagation, walker numbers small than <code>threshold</code> will be stochastically projected to either zero or <code>threshold</code>.</p><p>The trait can be conveniently defined on an instance of a generalised vector with the macro <a href="API.html#Rimu.@setThreshold-Tuple{Any,Any}"><code>@setThreshold</code></a>. Example:</p><pre><code class="language-julia-repl">julia&gt; dv = DVec(Dict(nearUniform(BoseFS{3,3})=&gt;3.0))
julia&gt; @setThreshold dv 0.6
julia&gt; StochasticStyle(dv)
IsStochasticWithThreshold(0.6f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L713-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdate" href="#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdate(ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift according to the log formula with damping parameter <code>ζ</code>.</p><div>\[S^{n+1} = S^n -\frac{ζ}{dτ}\ln\left(\frac{\|Ψ\|_1^{n+1}}{\|Ψ\|_1^n}\right)\]</div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L402-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.LogUpdateAfterTargetWalkers" href="#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogUpdateAfterTargetWalkers(targetwalkers, ζ = 0.08) &lt;: ShiftStrategy</code></pre><p>Strategy for updating the shift: After <code>targetwalkers</code> is reached, update the shift according to the log formula with damping parameter <code>ζ</code>. See <a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L378-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPIData" href="#Rimu.MPIData"><code>Rimu.MPIData</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Simple wrapper used for signaling that this data is part of a distributed data structure and communication should happen with MPI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPIDefault" href="#Rimu.MPIDefault"><code>Rimu.MPIDefault</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPIDefault(nprocs, my_rank, comm)</code></pre><p>Strategy for point-to-point MPI communication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L41-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPINoWalkerExchange" href="#Rimu.MPINoWalkerExchange"><code>Rimu.MPINoWalkerExchange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPINoWalkerExchange(nprocs, my_rank, comm)</code></pre><p>Strategy for for not exchanging walkers between ranks. Consequently there will be no cross-rank annihilations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MPIOSWin" href="#Rimu.MPIOSWin"><code>Rimu.MPIOSWin</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPIOSWin(nprocs, myrank, comm, ::Type{T}, capacity)</code></pre><p>Communication buffer for use with MPI one-sided communication (remote memory access). Up to <code>capacity</code> elements of type <code>T</code> can be exchanged between MPI ranks via <a href="API.html#Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T"><code>put</code></a>. It is important that <code>isbitstype(T) == true</code>. Objects of type <code>MPIOSWin</code> have to be freed manually with a (blocking) call to <a href="API.html#Rimu.free-Tuple{MPIOSWin}"><code>free()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L63-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.MemoryStrategy" href="#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for injectimg memory noise. Implemented strategies:</p><ul><li><a href="API.html#Rimu.NoMemory"><code>NoMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>DeltaMemory</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>ShiftMemory</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoMemory" href="#Rimu.NoMemory"><code>Rimu.NoMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NoMemory &lt;: MemoryStrategy</code></pre><p>Default strategy for <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a> indicating that no memory noise will be used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoProjection" href="#Rimu.NoProjection"><code>Rimu.NoProjection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Do not project the walker amplitudes. See <a href="@ref"><code>norm_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L885">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.NoProjectionTwoNorm" href="#Rimu.NoProjectionTwoNorm"><code>Rimu.NoProjectionTwoNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Do not project the walker amplitudes. Use two-norm to calculate walker numbers. This affects reported &quot;norm&quot; but also the shift update procedures. See <a href="@ref"><code>norm_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L888-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectStrategy" href="#Rimu.ProjectStrategy"><code>Rimu.ProjectStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy of projection for fciqmc with floating point walker number with <a href="@ref"><code>norm_project</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.NoProjection"><code>NoProjection</code></a></li><li><a href="API.html#Rimu.NoProjectionTwoNorm"><code>NoProjectionTwoNorm</code></a></li><li><a href="API.html#Rimu.ThresholdProject"><code>ThresholdProject</code></a></li><li><a href="API.html#Rimu.ScaledThresholdProject"><code>ScaledThresholdProject</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L873-L882">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ProjectedMemory" href="#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectedMemory(Δ::Int, projector, pp::Number) &lt;: MemoryStrategy
ProjectedMemory(Δ::Int, projector, v::AbstractDVec)</code></pre><p>Before updating the shift, apply memory noise to minimize the fluctuations of the overlap of the coefficient vector with <code>projector</code>. Averaging over <code>Δ</code> time steps is applied, where <code>Δ = 1</code> means no memory noise is applied. Use <code>pp</code> to initialise the value of the projection or pass <code>v</code> in order to initialise the projection with <code>pp = projector.v</code>.</p><pre><code class="language-none">r̃ = (projector⋅v - projector⋅w)/projector⋅v + dτ*shift
r = r̃ - &lt;r̃&gt;</code></pre><p>where <code>v</code> is the coefficient vector before and <code>w</code> after applying a regular FCIQMC step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L294-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportDFAndInfo" href="#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReportDFAndInfo(; k=10, i=100, io=stdout, writeinfo=true, projector = missing)</code></pre><p>Report every <code>k</code>th step in DataFrame and write info message to <code>io</code> every <code>i</code>th step (unless <code>writeinfo == false</code>). The flag <code>writeinfo</code> is useful for controlling info messages in MPI codes. Include projection onto <code>projector</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ReportingStrategy" href="#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ReportingStrategy</code></pre><p>Abstract type for strategies for reporting data in a DataFrame with <a href="API.html#Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}"><code>report!()</code></a>. It also affects the calculation and reporting of projected quantities in the DataFrame.</p><p><strong>Implemented strategies:</strong></p><ul><li><a href="API.html#Rimu.EveryTimeStep"><code>EveryTimeStep</code></a></li><li><a href="API.html#Rimu.EveryKthStep"><code>EveryKthStep</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>ReportDFAndInfo</code></a></li></ul><p>Every strategy accepts the keyword argument <code>projector</code> according to which a projection of the instantaneous coefficient vector <code>projector⋅v</code> and Hamiltonian <code>dot(projector, H, v)</code> are reported to the DataFrame  in the fields <code>df.vproj</code> and <code>df.hproj</code>, respectively. Possible values for <code>projector</code> are</p><ul><li><code>missing</code> - no projections are computed (default)</li><li><code>dv::AbstractDVec</code> - compute projection onto coefficient vector <code>dv</code></li><li><a href="API.html#Rimu.DictVectors.UniformProjector"><code>UniformProjector()</code></a> - projection onto vector of all ones</li><li><a href="API.html#Rimu.DictVectors.NormProjector"><code>NormProjector()</code></a> - compute 1-norm instead of projection (only <code>df.vproj</code>)</li><li><a href="API.html#Rimu.DictVectors.Norm2Projector"><code>Norm2Projector()</code></a> - compute 2-norm instead of projection (only <code>df.vproj</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">r_strat = EveryTimeStep(projector = copy(svec))</code></pre><p>Record the projection of instananeous coefficient vector and Hamiltonian onto the starting vector, and report every time step.</p><pre><code class="language-julia">r_strat = EveryKthStep(k=10, projector = UniformProjector())</code></pre><p>Record the projection of instananeous coefficient vector and Hamiltonian onto the uniform vector of all 1s, and report every <code>k</code>th time step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L43-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.RunTillLastStep" href="#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RunTillLastStep(step::Int = 0 # number of current/starting timestep
             laststep::Int = 100 # number of final timestep
             shiftMode::Bool = false # whether to adjust shift
             shift::Float64 = 0.0 # starting/current value of shift
             dτ::Float64 = 0.01 # current value of time step
) &lt;: FciqmcRunStrategy</code></pre><p>Parameters for running <a href="API.html#Rimu.fciqmc!"><code>fciqmc!()</code></a> for a fixed number of time steps. For alternative strategies, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L32-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ScaledThresholdProject" href="#Rimu.ScaledThresholdProject"><code>Rimu.ScaledThresholdProject</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScaledThresholdProject(threshold = 1.0) &lt;: ProjectStrategy</code></pre><p>Project stochastically for walker amplitudes below <code>threshold</code> and scale configuration array as to keep the norm constant. As a consequence, the final configuration amplitudes may be smaller than <code>threshold</code>. See <a href="@ref"><code>norm_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L909-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftMemory" href="#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ShiftMemory(Δ::Int) &lt;: MemoryStrategy</code></pre><p>Effectively replaces the fluctuating <code>shift</code> update procedure for the coefficient vector by an averaged <code>shift</code> over <code>Δ</code> timesteps, where <code>Δ = 1</code> means no averaging.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L282-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ShiftStrategy" href="#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for defining the strategy for updating the <code>shift</code> with <a href="API.html#Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any,Vararg{Any,N} where N}"><code>update_shift()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.DoubleLogUpdate"><code>DoubleLogUpdate</code></a> - default in <a href="API.html#Rimu.lomc!-Tuple{Any,Any}"><code>lomc!()</code></a></li><li><a href="API.html#Rimu.DontUpdate"><code>DontUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>LogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdate"><code>DelayedLogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>LogUpdateAfterTargetWalkers</code></a> - FCIQMC standard</li><li><a href="API.html#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>DelayedLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>DoubleLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>DoubleLogUpdateAfterTargetWalkersSwitch</code></a></li><li><a href="API.html#Rimu.HistoryLogUpdate"><code>HistoryLogUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogProjected"><code>DoubleLogProjected</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L357-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.StochasticStyle" href="#Rimu.StochasticStyle"><code>Rimu.StochasticStyle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StochasticStyle(v)
StochasticStyle(typeof(v))</code></pre><p><code>StochasticStyle</code> specifies the native style of the generalised vector <code>v</code> that determines how simulations are to proceed. This can be fully stochastic (with <code>IsStochastic</code>), fully deterministic (with <code>IsDeterministic</code>), or semistochastic (with <a href="API.html#Rimu.IsSemistochastic"><code>IsSemistochastic</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L695-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.ThresholdProject" href="#Rimu.ThresholdProject"><code>Rimu.ThresholdProject</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ThresholdProject(threshold = 1.0) &lt;: ProjectStrategy</code></pre><p>Project stochastically for walker amplitudes below <code>threshold</code>. See <a href="@ref"><code>norm_project</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L899-L903">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.TimeStepStrategy" href="#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for strategies for updating the time step with <a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}"><code>update_dτ()</code></a>. Implemented strategies:</p><ul><li><a href="API.html#Rimu.ConstantTimeStep"><code>ConstantTimeStep</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L171-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{MPIData}" href="#Base.length-Tuple{MPIData}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(md::MPIData)</code></pre><p>Compute the length of the distributed data on every MPI rank with <code>MPI.Allreduce</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm" href="#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">norm(md::MPIData, p=2)</code></pre><p>Compute the norm of the distributed data on every MPI rank with <code>MPI.Allreduce</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.applyMemoryNoise!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}" href="#Rimu.applyMemoryNoise!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.applyMemoryNoise!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r = applyMemoryNoise!(w, v, shift, dτ, pnorm, m_strat::MemoryStrategy)</code></pre><p>Apply memory noise to <code>w</code>, i.e. <code>w .+= r.*v</code>, computing the noise <code>r</code> according to <code>m_strat</code>. Note that <code>m_strat</code> needs to be compatible with <code>StochasticStyle(w)</code>. Otherwise, an error exception is thrown. See <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a>.</p><p><code>w</code> is the walker array after fciqmc step, <code>v</code> the previous one, <code>pnorm</code> the norm of <code>v</code>, and <code>r</code> the instantaneously applied noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/fciqmc.jl#L513-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.clearDFlags!-Tuple{Any}" href="#Rimu.clearDFlags!-Tuple{Any}"><code>Rimu.clearDFlags!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clearDFlags!(dv)</code></pre><p>Clear all flags in <code>dv</code> of the deterministic bit (rightmost bit).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L821-L824">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.compute_proj_observables-Union{Tuple{RS}, Tuple{DV}, Tuple{Any,Any,RS}} where RS&lt;:ReportingStrategy{DV} where DV&lt;:Missing" href="#Rimu.compute_proj_observables-Union{Tuple{RS}, Tuple{DV}, Tuple{Any,Any,RS}} where RS&lt;:ReportingStrategy{DV} where DV&lt;:Missing"><code>Rimu.compute_proj_observables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_proj_observables(v, ham, r::ReportingStrategy)</code></pre><p>Compute the projection of <code>r.projector⋅v</code> and <code>r.projector⋅ham*v</code> according to the <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a> <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc!" href="#Rimu.fciqmc!"><code>Rimu.fciqmc!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fciqmc!(v, pa::FciqmcRunStrategy, [df,]
         ham, s_strat::ShiftStrategy,
         [r_strat::ReportingStrategy, τ_strat::TimeStepStrategy, w])
-&gt; df</code></pre><p>Perform the FCIQMC algorithm for determining the lowest eigenvalue of <code>ham</code>. <code>v</code> can be a single starting vector of type <code>:&lt;AbstractDVec</code> or a vector of such structures. In the latter case, independent replicas are constructed. Returns a <code>DataFrame</code> <code>df</code> with statistics about the run, or a tuple of <code>DataFrame</code>s for a replica run. Strategies can be given for updating the shift (see <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a>) and (optionally), for reporting (see <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a>), and for updating the time step <code>dτ</code> (see <a href="API.html#Rimu.TimeStepStrategy"><code>TimeStepStrategy</code></a>).</p><p>A pre-allocated data structure <code>w</code> for working memory can be passed as argument, and controls multi-threading behaviour. By default multi-threading is turned on. To turn multi-threading off, pass <code>similar(localpart(v))</code> for w.</p><p>This function mutates <code>v</code>, the parameter struct <code>pa</code> as well as <code>df</code>, and <code>w</code>.</p><p>NOTE: The function <code>fciqmc!()</code> may be deprecated soon. Change all scripts to call <code>lomc!()</code> instead!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/fciqmc.jl#L153-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_col!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}" href="#Rimu.fciqmc_col!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.fciqmc_col!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fciqmc_col!(w, ham, add, num, shift, dτ)
fciqmc_col!(::Type{T}, args...)
-&gt; spawns, deaths, clones, antiparticles, annihilations</code></pre><p>Spawning and diagonal step of FCIQMC for single column of <code>ham</code>. In essence it computes</p><p><code>w .+= (1 .+ dτ.*(shift .- ham[:,add])).*num</code>.</p><p>Depending on <code>T ==</code><a href="API.html#Rimu.StochasticStyle"><code>StochasticStyle(w)</code></a>, a stochastic or deterministic algorithm will be chosen. The possible values for <code>T</code> are:</p><ul><li><a href="@ref"><code>IsDeterministic()</code></a> deteministic algorithm</li><li><a href="@ref"><code>IsStochastic()</code></a> stochastic version where the changes added to <code>w</code> are purely integer, according to the FCIQMC algorithm</li><li><a href="@ref"><code>IsStochasticNonlinear(c)</code></a> stochastic algorithm with nonlinear diagonal</li><li><a href="API.html#Rimu.IsSemistochastic"><code>IsSemistochastic()</code></a> semistochastic version: TODO</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/fciqmc.jl#L743-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.fciqmc_step!-Union{Tuple{D}, Tuple{Any,D,Any,Any,Any,D}} where D" href="#Rimu.fciqmc_step!-Union{Tuple{D}, Tuple{Any,D,Any,Any,Any,D}} where D"><code>Rimu.fciqmc_step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fciqmc_step!(Ĥ, v, shift, dτ, pnorm, w;
                      m_strat::MemoryStrategy = NoMemory()) -&gt; ṽ, w̃, stats</code></pre><p>Perform a single matrix(/operator)-vector multiplication:</p><div>\[\tilde{v} = [1 - dτ(\hat{H} - S)]⋅v ,\]</div><p>where <code>Ĥ == ham</code> and <code>S == shift</code>. Whether the operation is performed in stochastic, semistochastic, or determistic way is controlled by the trait <code>StochasticStyle(w)</code>. See <a href="API.html#Rimu.StochasticStyle"><code>StochasticStyle</code></a>. <code>w</code> is a local data structure with the same size and type as <code>v</code> and used for working. Both <code>v</code> and <code>w</code> are modified.</p><p>Returns the result <code>ṽ</code>, a (possibly changed) reference to working memory <code>w̃</code>,  and the array <code>stats = [spawns, deaths, clones, antiparticles, annihilations]</code>. Stats will contain zeros when running in deterministic mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/fciqmc.jl#L392-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.free-Tuple{MPIOSWin}" href="#Rimu.free-Tuple{MPIOSWin}"><code>Rimu.free</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">free(obj::MPIOSWin)</code></pre><p>De-reference the object, call finalizer and the garbage collector immediately. This is a syncronizing MPI call. Make sure that the object is not used later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.greet-Tuple{}" href="#Rimu.greet-Tuple{}"><code>Rimu.greet</code></a> — <span class="docstring-category">Method</span></header><section><div><p>brief greeting</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Rimu.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.lomc!-Tuple{Any,Any}" href="#Rimu.lomc!-Tuple{Any,Any}"><code>Rimu.lomc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lomc!(ham, v; kwargs...)
-&gt; nt::NamedTuple</code></pre><p>Linear operator Monte Carlo: Perform the FCIQMC algorithm for determining the lowest eigenvalue of <code>ham</code>. <code>v</code> can be a single starting vector of (wrapped) type <code>:&lt;AbstractDVec</code>, or a vector of such structures for a replica simulation. Returns a named tuple containg all information required for continuation runs. In particular, <code>nt.df</code> is a <code>DataFrame</code> with statistics about the run, or a tuple of <code>DataFrame</code>s for a replica run.</p><p><strong>Keyword arguments, defaults, and precedence:</strong></p><ul><li><code>laststep</code> - can be used to override information otherwise contained in <code>params</code></li><li><code>threading = :auto</code> - can be used to control the use of multithreading (overridden by <code>wm</code>)<ul><li><code>:auto</code> - use multithreading if <code>s_strat.targetwalkers ≥ 500</code></li><li><code>true</code> - use multithreading if available (set shell variable <code>JULIA_NUM_THREADS</code>!)</li><li><code>false</code> - run on single thread</li></ul></li><li><code>wm</code> - working memory; if set, it controls the use of multithreading and overrides <code>threading</code>; is mutated</li><li><code>params::FciqmcRunStrategy = RunTillLastStep(laststep = 100)</code> - contains basic parameters of simulation state, see <a href="API.html#Rimu.FciqmcRunStrategy"><code>FciqmcRunStrategy</code></a>; is mutated</li><li><code>s_strat::ShiftStrategy = DoubleLogUpdate(targetwalkers = 1000)</code> - see <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a></li><li><code>r_strat::ReportingStrategy = EveryTimeStep()</code> - see <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a></li><li><code>τ_strat::TimeStepStrategy = ConstantTimeStep()</code> - see <a href="API.html#Rimu.TimeStepStrategy"><code>TimeStepStrategy</code></a></li><li><code>m_strat::MemoryStrategy = NoMemory()</code> - see <a href="API.html#Rimu.MemoryStrategy"><code>MemoryStrategy</code></a></li><li><code>p_strat::ProjectStrategy = NoProjection()</code> - see <a href="API.html#Rimu.ProjectStrategy"><code>ProjectStrategy</code></a></li></ul><p><strong>Return values</strong></p><pre><code class="language-julia">nt = lomc!(args...)</code></pre><p>The named tuple <code>nt</code> contains the following fields:</p><pre><code class="language-julia">nt = (
    ham = ham, # the linear operator, from input
    v = v, # the current coefficient vector, mutated from input
    params = params, # struct with state parameters, mutated from input
    df = df, # DataFrame with statistics per time step
    wm = wm, # working memory, mutated from input
    s_strat = s_strat, # from input
    r_strat = r_strat, # from input
    τ_strat = τ_strat, # from input
    m_strat = m_strat, # from input
    p_strat = p_strat, # from input
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/fciqmc.jl#L3-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.lomc!-Tuple{NamedTuple}" href="#Rimu.lomc!-Tuple{NamedTuple}"><code>Rimu.lomc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lomc!(nt::NamedTuple, laststep::Int = nt.params.laststep)</code></pre><p>Linear operator Monte Carlo: Call signature for a continuation run.</p><p><code>nt</code> should have the same structure as the return value of <code>lomc!()</code>. The optional argument <code>laststep</code> can be used to set a new last step. If <code>laststep &gt; nt.params.step</code>, additional time steps will be computed and the statistics in the <code>DataFrame</code> <code>nt.df</code> will be appended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/fciqmc.jl#L117-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.mpi_default" href="#Rimu.mpi_default"><code>Rimu.mpi_default</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpi_default(data, comm = MPI.COMM_WORLD, root = 0)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to default. Sets up the <a href="API.html#Rimu.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.MPIDefault"><code>MPIDefault</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.mpi_no_exchange" href="#Rimu.mpi_no_exchange"><code>Rimu.mpi_no_exchange</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpi_no_exchange(data, comm = MPI.COMM_WORLD, root = 0)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to <code>MPINoWalkerExchange</code>. Sets up the <a href="API.html#Rimu.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.MPINoWalkerExchange"><code>MPINoWalkerExchange</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L135-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.mpi_one_sided" href="#Rimu.mpi_one_sided"><code>Rimu.mpi_one_sided</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpi_one_sided(data, comm = MPI.COMM_WORLD, root = 0)</code></pre><p>Declare <code>data</code> as mpi-distributed and set communication strategy to one-sided with remote memory access (RMA). Sets up the <a href="API.html#Rimu.MPIData"><code>MPIData</code></a> structure with <a href="API.html#Rimu.MPIOSWin"><code>MPIOSWin</code></a> strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.next_mpiID" href="#Rimu.next_mpiID"><code>Rimu.next_mpiID</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">next_mpiID()</code></pre><p>Produce a new ID number for MPI distributed objects. Uses an internal counter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L7-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.norm_project!-Tuple{Any,Any}" href="#Rimu.norm_project!-Tuple{Any,Any}"><code>Rimu.norm_project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm_project!(w, p_strat::ProjectStrategy) -&gt; norm</code></pre><p>Computes the 1-norm of <code>w</code>. Project all elements of <code>w</code> to <code>s.threshold</code> preserving the sign if <code>StochasticStyle(w)</code> requires projection according to <code>p_strat</code>. See <a href="API.html#Rimu.ProjectStrategy"><code>ProjectStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/fciqmc.jl#L472-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T" href="#Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T"><code>Rimu.put</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">put(buf::Vector{T}, [len,] targetrank, s::MPIOSWin{T})
put(obj::T, targetrank, s::MPIOSWin{T})</code></pre><p>Deposit a single <code>obj</code> or vector <code>buf</code> into the MPI window <code>s</code> on rank <code>targetrank</code>. If <code>len</code> is given, only the first <code>len</code> elements are transmitted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L204-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}" href="#Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}"><code>Rimu.report!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">report!(df::DataFrame, t::Tuple, s&lt;:ReportingStrategy)</code></pre><p>Record results in <code>df</code> and write informational messages according to strategy <code>s</code>. See <a href="API.html#Rimu.ReportingStrategy"><code>ReportingStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.setSemistochastic!-Tuple{Any,Float16,Any}" href="#Rimu.setSemistochastic!-Tuple{Any,Float16,Any}"><code>Rimu.setSemistochastic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setSemistochastic!(dv, threshold::Float16, d_space)</code></pre><p>Set the deterministic space for <code>dv</code> with threshold <code>threshold</code>, where <code>d_space</code> is a vector of addresses defining the the stochastic subspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L806-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.setThreshold-Tuple{Any,Any}" href="#Rimu.setThreshold-Tuple{Any,Any}"><code>Rimu.setThreshold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setThreshold(dv, threshold)</code></pre><p>Set a threshold for non-integer walker number FCIQMC. Technically, the function sets the trait <a href="API.html#Rimu.StochasticStyle"><code>StochasticStyle</code></a> of the generalised vector <code>dv</code> to <a href="API.html#Rimu.IsStochasticWithThreshold"><code>IsStochasticWithThreshold(threshold)</code></a>, where <code>dv</code> must be a type that supports floating point walker numbers. Also available as macro, see <a href="API.html#Rimu.@setThreshold-Tuple{Any,Any}"><code>@setThreshold</code></a>.</p><p>Example usage:</p><pre><code class="language-julia-repl">julia&gt; dv = DVec(Dict(nearUniform(BoseFS{3,3})=&gt;3.0))
julia&gt; setThreshold(dv, 0.6)
IsStochasticWithThreshold(0.6f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L758-L771">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.sort_into_targets!-Tuple{Any,Any,Any}" href="#Rimu.sort_into_targets!-Tuple{Any,Any,Any}"><code>Rimu.sort_into_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_into_targets!(target, source, stats) -&gt; agg, wm, agg_stats</code></pre><p>Aggregate coefficients from <code>source</code> to <code>agg</code> and from <code>stats</code> to <code>agg_stats</code> according to thread- or MPI-level parallelism. <code>wm</code> passes back a reference to working memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/helpers.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.sort_into_targets!-Tuple{MPIData,AbstractDVec}" href="#Rimu.sort_into_targets!-Tuple{MPIData,AbstractDVec}"><code>Rimu.sort_into_targets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_into_targets!(target::MPIData, source)</code></pre><p>Distribute the entries of <code>source</code> to the <code>target</code> data structure such that all entries in the <code>target</code> dictionaries are on the process with the correct rank as controlled by <a href="API.html#Rimu.targetrank"><code>targetrank()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.targetrank" href="#Rimu.targetrank"><code>Rimu.targetrank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">targetrank(key, np, hash = hash(key))</code></pre><p>Compute the rank where the <code>key</code> belongs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/mpi_helpers.jl#L244-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}" href="#Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}"><code>Rimu.update_dτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_dτ(s&lt;:TimeStepStrategy, dτ, args...) -&gt; new dτ</code></pre><p>Update the time step according to the strategy <code>s</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L183-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any,Vararg{Any,N} where N}" href="#Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Rimu.update_shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_shift(s &lt;: ShiftStrategy, shift, shiftMode, tnorm, pnorm, dτ, step, df, v_new, v_old)</code></pre><p>Update the shift according to strategy <code>s</code>. See <a href="API.html#Rimu.ShiftStrategy"><code>ShiftStrategy</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L576-L579">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.@setDeterministic-Tuple{Any}" href="#Rimu.@setDeterministic-Tuple{Any}"><code>Rimu.@setDeterministic</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@setDeterministic dv</code></pre><p>A macro to undo the effect of [<code>@setThreshold</code>] and set the trait <a href="API.html#Rimu.StochasticStyle"><code>StochasticStyle</code></a> of the generalised vector <code>dv</code> to <a href="@ref"><code>IsDeterministic()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L778-L783">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.@setThreshold-Tuple{Any,Any}" href="#Rimu.@setThreshold-Tuple{Any,Any}"><code>Rimu.@setThreshold</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@setThreshold dv threshold</code></pre><p>A macro to set a threshold for non-integer walker number FCIQMC. Technically, the macro sets the trait <a href="API.html#Rimu.StochasticStyle"><code>StochasticStyle</code></a> of the generalised vector <code>dv</code> to <a href="API.html#Rimu.IsStochasticWithThreshold"><code>IsStochasticWithThreshold(threshold)</code></a>, where <code>dv</code> must be a type that supports floating point walker numbers. Also available as function, see <a href="API.html#Rimu.setThreshold-Tuple{Any,Any}"><code>setThreshold</code></a>.</p><p>Example usage:</p><pre><code class="language-julia-repl">julia&gt; dv = DVec(Dict(nearUniform(BoseFS{3,3})=&gt;3.0))
julia&gt; @setThreshold dv 0.6
IsStochasticWithThreshold(0.6f0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/strategies_and_params.jl#L736-L749">source</a></section></article><h2 id="Reexported-Submodules"><a class="docs-heading-anchor" href="#Reexported-Submodules">Reexported Submodules</a><a id="Reexported-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Reexported-Submodules" title="Permalink"></a></h2><h3 id="Hamiltonians"><a class="docs-heading-anchor" href="#Hamiltonians">Hamiltonians</a><a id="Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians" title="Permalink"></a></h3><p>Link to <a href="hamiltonians.html#Module-Hamiltionians.jl">Module <code>Hamiltionians.jl</code></a></p><h3 id="BitStringAddresses"><a class="docs-heading-anchor" href="#BitStringAddresses">BitStringAddresses</a><a id="BitStringAddresses-1"></a><a class="docs-heading-anchor-permalink" href="#BitStringAddresses" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BSAdd128" href="#Rimu.BitStringAddresses.BSAdd128"><code>Rimu.BitStringAddresses.BSAdd128</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSAdd128 &lt;: BitStringAddressType</code></pre><p>Address type that encodes a bistring address in a UInt128.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BSAdd64" href="#Rimu.BitStringAddresses.BSAdd64"><code>Rimu.BitStringAddresses.BSAdd64</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BSAdd64 &lt;: BitStringAddressType</code></pre><p>Address type that encodes a bistring address in a UInt64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BStringAdd" href="#Rimu.BitStringAddresses.BStringAdd"><code>Rimu.BitStringAddresses.BStringAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BStringAdd &lt;: BitStringAddressType</code></pre><p>Address type that encodes a bistring address in a one-dim. BitArray.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BitAdd" href="#Rimu.BitStringAddresses.BitAdd"><code>Rimu.BitStringAddresses.BitAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BitAdd{I,B} &lt;: BitStringAddressType
BitAdd(address::Integer, B)
BitAdd(chunks::T, B) where T&lt;:Union{Tuple,SVector}
BitAdd{B}(address)</code></pre><p>Address type that encodes a bistring address with <code>B</code> bits. The bits are stored efficiently as <code>SVector</code> of <code>I</code> chunks of type <code>UInt64</code>. The two-argument constructor is preferred due to safety (consistency checks). In hot loops there maybe gain from the (unsafe) parametric constructor. If an integer <code>address</code> is passed, its bit representation  is used to initialize <code>BitAdd</code>. For large bit numbers, <code>BigInt</code> is convenient. <code>BitAdd[i]</code> will return bit <code>i</code> (as <code>Bool</code>), counting from right to left.</p><ul><li><code>BitAdd{B}()</code> creates a <code>BitAdd</code> with all ones.</li><li><code>zero(BitAdd{B})</code>  creates a <code>BitAdd</code> with all zeros.</li></ul><p>Note that no checking for ghost bits occurs when constructing <code>BitAdd</code> from <code>SVector</code> or <code>Tuple</code>. See <a href="@ref"><code>bitadd()</code></a>, <a href="@ref"><code>check_consistency()</code></a>, and <a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I"><code>remove_ghost_bits()</code></a> methods!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L219-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BitStringAddressType" href="#Rimu.BitStringAddresses.BitStringAddressType"><code>Rimu.BitStringAddresses.BitStringAddressType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BitStringAddressType</code></pre><p>Abstract type for configuration addresses with the nature of a bitstring. A number of methods need to be implemented, in particular <code>Base.isless(a,b)</code>, <code>numBits()</code>, <code>numChunks()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS" href="#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BoseFS{N,M,A} &lt;: BosonicFockStateAddress &lt;: BitStringAddressType
BoseFS(bs::A) where A &lt;: BitAdd
BoseFS(bs::A, b)</code></pre><p>Address type that represents a Fock state of <code>N</code> spinless bosons in <code>M</code> orbitals by wrapping a bitstring of type <code>A</code>. Orbitals are stored in reverse order, i.e. the first orbital in a <code>BoseFS</code> is stored rightmost in the bitstring <code>bs</code>. If the number of significant bits <code>b</code> is not encoded in <code>A</code> it must be passed as an argument (e.g. for <code>BSAdd64</code> and <code>BSAdd128</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L619-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BoseFS-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}" href="#Rimu.BitStringAddresses.BoseFS-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>Rimu.BitStringAddresses.BoseFS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoseFS(onr::T) where T&lt;:Union{AbstractVector,Tuple}
BoseFS{BST}(onr::T)</code></pre><p>Create <code>BoseFS</code> address from an occupation number representation, specifying the occupation number of each orbital. If a type <code>BST</code> is given it will define the underlying bit string type. Otherwise, the bit string type is chosen to fit the <code>onr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L656-L663">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.BosonicFockStateAddress" href="#Rimu.BitStringAddresses.BosonicFockStateAddress"><code>Rimu.BitStringAddresses.BosonicFockStateAddress</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BosonicFockStateAddress &lt;: BitStringAddressType</code></pre><p>Supertype representing a bosonic Fock state. Implement <a href="API.html#Rimu.BitStringAddresses.numModes-Tuple{Type}"><code>numModes()</code></a> and <a href="API.html#Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>numParticles()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&lt;&lt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I" href="#Base.:&lt;&lt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&lt;&lt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">&lt;&lt;(b::BitAdd,n::Integer)</code></pre><p>Bitshift <code>b</code> to the left by <code>n</code> bits and fill from the right with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L469-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:&gt;&gt;&gt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I" href="#Base.:&gt;&gt;&gt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&gt;&gt;&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">&gt;&gt;&gt;(b::BitAdd,n::Integer)</code></pre><p>Bitshift <code>b</code> to the right by <code>n</code> bits and fill from the left with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L366-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.bitaddr-Union{Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:Integer" href="#Rimu.BitStringAddresses.bitaddr-Union{Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:Integer"><code>Rimu.BitStringAddresses.bitaddr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bitaddr(onr, Type)</code></pre><p>Calculate a bitstring address from an occupation number representation the type of the bitstring address is passed as the second argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L891-L896">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.lbshr-Union{Tuple{I}, Tuple{N}, Tuple{StaticArrays.SArray{Tuple{N},I,1,N},Any}} where I where N" href="#Rimu.BitStringAddresses.lbshr-Union{Tuple{I}, Tuple{N}, Tuple{StaticArrays.SArray{Tuple{N},I,1,N},Any}} where I where N"><code>Rimu.BitStringAddresses.lbshr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lbshr(c,k)</code></pre><p>Apply logical bit shift to the right by <code>k</code> bits to <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L396-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{BoseFS{N,M,A}}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N" href="#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{BoseFS{N,M,A}}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.nearUniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearUniform(BoseFS{N,M})
nearUniform(BoseFS{N,M,A}) -&gt; bfs::BoseFS{N,M,A}</code></pre><p>Create bosonic Fock state with near uniform occupation number of <code>M</code> modes with a total of <code>N</code> particles. Specifying the bit address type <code>A</code> is optional.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; nearUniform(BoseFS{7,5,BitAdd})
BoseFS{BitAdd}((2,2,1,1,1))

julia&gt; nearUniform(BoseFS{7,5})
BoseFS{BSAdd64}((2,2,1,1,1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L833-L847">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.nearUniformONR-Tuple{Number,Number}" href="#Rimu.BitStringAddresses.nearUniformONR-Tuple{Number,Number}"><code>Rimu.BitStringAddresses.nearUniformONR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearUniformONR(N, M) -&gt; onr::SVector{M,Int}</code></pre><p>Create occupation number representation <code>onr</code> distributing <code>N</code> particles in <code>M</code> modes in a close-to-uniform fashion with each orbital filled with at least <code>N ÷ M</code> particles and at most with <code>N ÷ M + 1</code> particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L816-L821">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numBits-Tuple{Type}" href="#Rimu.BitStringAddresses.numBits-Tuple{Type}"><code>Rimu.BitStringAddresses.numBits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numBits(a)</code></pre><p>Number of bit chunks representing <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numChunks-Tuple{Type}" href="#Rimu.BitStringAddresses.numChunks-Tuple{Type}"><code>Rimu.BitStringAddresses.numChunks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numChunks(a)</code></pre><p>Number of 64-bit chunks representing <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L29-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numModes-Tuple{Type}" href="#Rimu.BitStringAddresses.numModes-Tuple{Type}"><code>Rimu.BitStringAddresses.numModes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numModes(a)</code></pre><p>Number of modes represented by <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Rimu.BitStringAddresses.numParticles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numParticles(a)</code></pre><p>Number of particles represented by <code>a</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L50-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.onr-Union{Tuple{A}, Tuple{A,Integer}} where A&lt;:Integer" href="#Rimu.BitStringAddresses.onr-Union{Tuple{A}, Tuple{A,Integer}} where A&lt;:Integer"><code>Rimu.BitStringAddresses.onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onr(address, m)</code></pre><p>Compute and return the occupation number representation as an array of <code>Int</code> corresponding to the given address.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L937-L942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.onr-Union{Tuple{BoseFS{N,M,A}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N" href="#Rimu.BitStringAddresses.onr-Union{Tuple{BoseFS{N,M,A}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.onr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">onr(bs)</code></pre><p>Compute and return the occupation number representation of the bit string address <code>bs</code> as an <code>SVector{M,Int}</code>, where <code>M</code> is the number of orbitals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L765-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I" href="#Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">remove_ghost_bits(bs)</code></pre><p>Remove set bits outside data field if any are present.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/BitStringAddresses.jl#L335-L338">source</a></section></article><h3 id="DictVectors"><a class="docs-heading-anchor" href="#DictVectors">DictVectors</a><a id="DictVectors-1"></a><a class="docs-heading-anchor-permalink" href="#DictVectors" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors" href="#Rimu.DictVectors"><code>Rimu.DictVectors</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Module that provides data structures that behave similar to sparse vectors, but are indexed by arbitrary types (could be non-integers) similarly to dictionaries. The idea is to do linear algebra with data structures that are neither subtyped to <code>AbstractVector</code> nor to <code>AbstractDict</code> and are suitable for use with <code>KrylovKit.jl</code>. For this, the abstract type and interface <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a> is provided, with the following concrete subtypes:</p><ul><li><a href="API.html#Rimu.DictVectors.DVec"><code>DVec</code></a></li><li><a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FastDVec"><code>FastDVec</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/DictVectors.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.ADVPairsIterator" href="#Rimu.DictVectors.ADVPairsIterator"><code>Rimu.DictVectors.ADVPairsIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ADVPairsIterator</code></pre><p>Iterator type for pairs from a <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L333-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.AbstractDVec" href="#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DictVectors.AbstractDVec{K,V}</code></pre><p>Abstract type for sparse vectors with <code>valtype()</code> <code>V</code> based on dictionary-like structures. They behave like vectors except that indexing is performed with an arbitrary <code>keytype()</code> <code>K</code> (no order required). <code>getindex()</code> returns <code>zero(V)</code> for any unknown key and zeroed elements should be deleted with <code>delete!()</code>. Thus, iteration typically returns only non-zero entries. In variance to <code>AbstractVector</code>, <code>length()</code> will return the number of non-zero elements, while <code>capacity()</code> returns the holding capacity (assumed fixed) of the object. Even though <code>AbstractDVec</code> is similar to both <code>AbstractDict</code> and <code>AbstractVector</code>, it is explicitly not subtyped to either. The aim is to create data structures suitable for FCIQMC and compatible with KrylovKit.jl.</p><p><strong>Interface</strong></p><p>The interface is similar to the <code>AbstractDict</code> interface. Implement what would be needed for the <code>AbstractDict</code> interface (<code>setindex!, getindex, delete!, length, haskey, empty!, isempty</code>) and, in addition:</p><ul><li><code>capacity(dv)</code>: holding capacity</li><li><code>similar(dv [,Type])</code></li><li><code>iterate()</code>: should return values of type <code>V</code></li><li><code>pairs()</code>: should return an iterator over <code>key::K =&gt; content</code> pairs. If <code>content ≠ value::V</code> then provide <code>values()</code> iterator as well!</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.DFVec" href="#Rimu.DictVectors.DFVec"><code>Rimu.DictVectors.DFVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DFVec{K,V,F}(capacity) &lt;: AbstractDVec{K,V &lt;: Number}
DFVec(key =&gt; (value, flag); capacity)
DFVec(args...; capacity)
DFVec(d::Dict [, capacity])
DFVec(v::Vector{V} [, capacity])</code></pre><p>Dictionary-based vector-like data structure with minimum capacity <code>capacity</code> for storing values and flags with keys. The values have type <code>eltype(dv) == V</code> and the flags have <code>flagtype(dv) == F</code>. Indexing is done with an arbitrary (in general non-integer) key with <code>keytype(dv) == K</code>. If the keyword argument <code>capacity</code> is passed then args are parsed as for <code>Dict</code>. When constructed from a <code>Vector{V}</code>, the keys will be integers <code>∈ [1, length(v)]</code> and the flag <code>zero(UInt16)</code>. See <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>. The method <a href="API.html#Rimu.DictVectors.capacity"><code>capacity()</code></a> is defined but not a strict upper limit as <code>Dict</code> objects can expand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.DVec" href="#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DVec{K,V}(capacity) &lt;: AbstractDVec{K,V}
DVec(key =&gt; value; capacity)
DVec(args...; capacity)
DVec(d::Dict [, capacity])
DVec(v::Vector{V} [, capacity])</code></pre><p>Dictionary-based vector-like data structure with minimum capacity <code>capacity</code> for storing values with keys. The type of the values is <code>eltype(dv) == V</code>. Indexing is done with an arbitrary (in general non-integer) key with <code>keytype(dv) == K</code>. If the keyword argument <code>capacity</code> is passed then args are parsed as for <code>Dict</code>. When constructed from a <code>Vector</code>, the keys will be integers ∈ <code>[1, length(v)]</code>. See <a href="API.html#Rimu.DictVectors.AbstractDVec"><code>AbstractDVec</code></a>. The method <a href="API.html#Rimu.DictVectors.capacity"><code>capacity()</code></a> is defined but not a strict upper limit as <code>Dict</code> objects can expand.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dvec.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.FastDVec" href="#Rimu.DictVectors.FastDVec"><code>Rimu.DictVectors.FastDVec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DictVectors.FastDVec{K,V}(capacity)</code></pre><p>Create a dictionary-like array indexed by keys of type <code>K</code> and values of type <code>V</code> with a maximum capacity of <code>capacity</code>.</p><pre><code class="language-none">FastDVec(a::AbstractArray, [capacity = length(a)])
FastDVec(d::AbstractDict{K,V}, [capacity = length(d)])
FastDVec(d::AbstractDVec{K,V}, [capacity = length(d)])</code></pre><p>Construct a <code>FastDVec</code> object from an existing array or dictionary.</p><pre><code class="language-none">FastDVec(args...; capacity)</code></pre><p>If the keyword argument <code>capacity</code> is passed then args are parsed as for <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/fastdvec.jl#L2-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.FlagsIterator" href="#Rimu.DictVectors.FlagsIterator"><code>Rimu.DictVectors.FlagsIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FlagsIterator</code></pre><p>Iterator type returned by <a href="API.html#Rimu.DictVectors.flags-Tuple{DFVec}"><code>flags()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L214-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.KVPairsIterator" href="#Rimu.DictVectors.KVPairsIterator"><code>Rimu.DictVectors.KVPairsIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">KVPairsIterator</code></pre><p>Iterator type returned by <a href="API.html#Rimu.DictVectors.kvpairs-Tuple{Any}"><code>kvpairs()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L238-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.Norm2Projector" href="#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Norm2Projector()</code></pre><p>Results in computing the two-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia">dot(NormProjector(),x)
-&gt; norm(x,2) # with type Float64</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L439-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.NormProjector" href="#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NormProjector()</code></pre><p>Results in computing the one-norm when used in <code>dot()</code>. E.g.</p><pre><code class="language-julia">dot(NormProjector(),x)
-&gt; norm(x,1) # with type valtype(x)</code></pre><p><code>NormProjector()</code> thus represents the vector <code>sign.(x)</code>.</p><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L420-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.UniformProjector" href="#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniformProjector()</code></pre><p>Represents a vector with all elements 1. To be used with <a href="@ref"><code>dot()</code></a>. Minimizes memory allocations.</p><pre><code class="language-julia">UniformProjector()⋅v == sum(v)
dot(UniformProjector(), LO, v) == sum(LO*v)</code></pre><p>See also <a href="@ref"><code>ReportingStrategy</code></a> for use of projectors in FCIQMC.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L401-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.fill!-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDVec{K,V},V}} where V where K" href="#Base.fill!-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDVec{K,V},V}} where V where K"><code>Base.fill!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fill!(da::AbstractDVec, x)</code></pre><p>Empties <code>da</code> if <code>x==zero(valtype(da))</code> and throws an error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L148-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Tuple{DFVec,Any,Tuple}" href="#Base.get-Tuple{DFVec,Any,Tuple}"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get(dv::DFVec, key, deftup::Tuple)</code></pre><p>Return tuple containing value and flag if <code>key</code> exists and otherwise <code>deftup</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L131-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any,Number}} where F where V where K" href="#Base.get-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any,Number}} where F where V where K"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get(dv::DFVec, key, defnum::Number)</code></pre><p>Return value only if <code>key</code> exists and otherwise <code>defnum</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L137-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{AbstractDVec,AbstractDVec}" href="#Base.isequal-Tuple{AbstractDVec,AbstractDVec}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequal(l::AbstractDVec, r::AbstractDVec)</code></pre><p>Returns <code>true</code> if all non-zero entries have the same value. Equality of flags is not tested unless both <code>l</code> and <code>r</code> support flags.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L299-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{DFVec,DFVec}" href="#Base.isequal-Tuple{DFVec,DFVec}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequal(l::DFVec, r::DFVec)</code></pre><p>Returns <code>true</code> if all non-zero entries have the same value and the same flag.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L333-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.axpy!-Tuple{Number,AbstractDVec,AbstractDVec}" href="#LinearAlgebra.axpy!-Tuple{Number,AbstractDVec,AbstractDVec}"><code>LinearAlgebra.axpy!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">axpy!(α::Number, X::AbstractDVec, Y::AbstractDVec)
axpy!(α::Number, X::AbstractDVec, Ys::Tuple, batchsize)</code></pre><p>Overwrite <code>Y</code> with <code>α*X + Y</code> where <code>α</code> is scalar for <code>AbstractDVec</code>s. If a tuple <code>Ys</code> is passed with <code>Threads.nthreads()</code> <code>AbstractDVec</code>s, then perform the operation in parallel over threads with <code>batchsize</code> elements at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractDVec,Real}" href="#LinearAlgebra.norm-Tuple{AbstractDVec,Real}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(x::AbstractDVec, p)</code></pre><p>Computes the p-norm of the DVec x. Implemented for <code>p ∈ {1, 2, Inf}</code>. Returns zero if <code>x</code> is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractDVec}" href="#LinearAlgebra.norm-Tuple{AbstractDVec}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(x::AbstractDVec{K,V})</code></pre><p>Computes the 2-norm of the DVec x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L82-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.add!-Union{Tuple{V2}, Tuple{V1}, Tuple{K}, Tuple{AbstractDVec{K,V1},AbstractDVec{K,V2}}} where V2 where V1 where K" href="#Rimu.DictVectors.add!-Union{Tuple{V2}, Tuple{V1}, Tuple{K}, Tuple{AbstractDVec{K,V1},AbstractDVec{K,V2}}} where V2 where V1 where K"><code>Rimu.DictVectors.add!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add!(x::AbstractDVec,y::AbstactDVec)</code></pre><p>Inplace add <code>x+y</code> and store result in <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L179-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.capacity" href="#Rimu.DictVectors.capacity"><code>Rimu.DictVectors.capacity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">DictVectors.capacity(dv::AbstractDVec, [s = :effective])
capacity(dvs::Tuple, [s = :effective])</code></pre><p>gives the effective holding capacity of <code>dv</code>. If a tuple of <code>dvs</code> is given it aggregates the capacities.</p><p>Optional argument <code>s</code>:</p><ul><li><code>:effective</code>  the number of elements that</li></ul><p>can be stored savely (default)</p><ul><li><code>:allocated</code> actual internal memory allocation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L29-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.flags-Tuple{DFVec}" href="#Rimu.DictVectors.flags-Tuple{DFVec}"><code>Rimu.DictVectors.flags</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">flags(dv::DFVec)</code></pre><p>An iterator that yields flags stored in the <a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a> <code>dv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L225-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.gettuple-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any}} where F where V where K" href="#Rimu.DictVectors.gettuple-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any}} where F where V where K"><code>Rimu.DictVectors.gettuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gettuple(dv::DFVec, key)</code></pre><p>Retrieve the tuple <code>(v,f)</code> stored at the given <code>key</code>. If the key is not found, return a tuple of zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.kvpairs-Tuple{Any}" href="#Rimu.DictVectors.kvpairs-Tuple{Any}"><code>Rimu.DictVectors.kvpairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kvpairs(collection)</code></pre><p>Return an iterator over <code>key =&gt; value</code> pairs ignoring any flags. If no flags are present, eg. for generic <code>AbstractDVec</code>, this falls back to <a href="@ref"><code>Base.pairs</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L346-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.kvpairs-Tuple{DFVec}" href="#Rimu.DictVectors.kvpairs-Tuple{DFVec}"><code>Rimu.DictVectors.kvpairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kvpairs(dv::DFVec)</code></pre><p>An iterator that yields <code>key =&gt; value</code> pairs stored in the <a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a> <code>dv</code> ignoring any <code>flags</code>. In contrast, <code>Base.pairs()</code> will return pairs <code>key =&gt; (value, flag)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.normInf-Tuple{AbstractDVec}" href="#Rimu.DictVectors.normInf-Tuple{AbstractDVec}"><code>Rimu.DictVectors.normInf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normInf(x::AbstractDVec)</code></pre><p>Infinity norm: largest absolute value of entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L105-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.norm_sqr-Union{Tuple{AbstractDVec{K,V}}, Tuple{K}, Tuple{V}} where K where V&lt;:Number" href="#Rimu.DictVectors.norm_sqr-Union{Tuple{AbstractDVec{K,V}}, Tuple{K}, Tuple{V}} where K where V&lt;:Number"><code>Rimu.DictVectors.norm_sqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm_sqr(x::AbstractDVec)</code></pre><p>Fast calculation of the square of the 2-norm of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L74-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.pairtype-Tuple{Any}" href="#Rimu.DictVectors.pairtype-Tuple{Any}"><code>Rimu.DictVectors.pairtype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pairtype(dv)</code></pre><p>Returns the type of stored data, as returned by the <code>pairs()</code> iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L57-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.tuples-Tuple{DFVec}" href="#Rimu.DictVectors.tuples-Tuple{DFVec}"><code>Rimu.DictVectors.tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tuples(dv::DFVec)</code></pre><p>An iterator that yields tuples <code>(v, f)</code> with value <code>v</code> and flag <code>f</code> stored in the <a href="API.html#Rimu.DictVectors.DFVec"><code>DFVec</code></a> <code>dv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/dfvec.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.DictVectors.zero!-Tuple{AbstractDVec}" href="#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero!(v::AbstractDVec)</code></pre><p>Replace <code>v</code> by a zero vector as an inplace operation. For <code>AbstractDVec</code> types it means removing all non-zero elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/DictVectors/abstractdvec.jl#L67-L71">source</a></section></article><h3 id="Blocking"><a class="docs-heading-anchor" href="#Blocking">Blocking</a><a id="Blocking-1"></a><a class="docs-heading-anchor-permalink" href="#Blocking" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking" href="#Rimu.Blocking"><code>Rimu.Blocking</code></a> — <span class="docstring-category">Module</span></header><section><div><p><code>Blocking</code></p><p>Module that contains functions performing the Flyvbjerg-Petersen (J. Chem. Phys. 91, 461 (1989)) blocking analysis for evaluating the standard error on a correlated data set. A &quot;M-test&quot; is also implemented based on Jonsson (Phys. Rev. E 98, 043304, (2018)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.autoblock-Tuple{DataFrames.DataFrame}" href="#Rimu.Blocking.autoblock-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.autoblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoblock(df::DataFrame; start = 1, stop = size(df)[1])
-&gt; s̄, σs, ē, σe, k</code></pre><p>Determine mean shift <code>s̄</code> and projected energy <code>ē</code> with respective standard errors <code>σs</code> and <code>σe</code> by blocking analsis from the <code>DataFrame</code> <code>df</code> returned from <code>fciqmc!()</code>. The number <code>k</code> of blocking steps and decorrelation time <code>2^k</code> are obtained from the M-test for the shift and also applied to the projected energy, assuming that the projected quantities decorrelate on the same time scale. Returns a named tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L404-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.autoblock-Tuple{Tuple}" href="#Rimu.Blocking.autoblock-Tuple{Tuple}"><code>Rimu.Blocking.autoblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autoblock(dftup::Tuple; start = 1, stop = size(dftup[1])[1])
-&gt; s̄1, σs1, s̄2, σs2, ē1, σe1, ē2, σe2, ēH, σeH, k</code></pre><p>Replica version. <code>dftup</code> is the tuple of <code>DataFrame</code>s returned from replica <code>fciqmc!()</code>. Returns a named tuple with shifts and three variational energy estimators and respective errors obtained from blocking analysis. The larger of the <code>k</code> values from M-tests on the two shift time series is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L421-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.autocovariance-Tuple{Array{T,1} where T,Int64}" href="#Rimu.Blocking.autocovariance-Tuple{Array{T,1} where T,Int64}"><code>Rimu.Blocking.autocovariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autocovariance(v::Vector,h::Int; corrected::Bool=true)</code></pre><p><span>$\hat{\gamma}(h) =\frac{1}{n}\sum_{t=1}^{n-h}(v_{t+h}-\bar{v})(v_t-\bar{v})$</span> Calculate the autocovariance of dataset <code>v</code> with a delay <code>h</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with <code>n-h</code>, whereas the sum is scaled with <code>n</code> if corrected is <code>false</code> where <code>n = length(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L104-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blockAndMTest-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.blockAndMTest-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blockAndMTest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">v̄, σ, σσ, k, df = blockAndMTest(v::Vector)</code></pre><p>Perform a blocking analysis and M-test on <code>v</code> returning the mean <code>v̄</code>, standard error <code>σ</code>, its error <code>σσ</code>, the number of blocking steps <code>k</code>, and the <code>DataFrame</code> <code>df</code> with blocking data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L372-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocker-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.blocker-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocker</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blocker(v::Vector) -&gt; new_v::Vector</code></pre><p>Reblock the data by successively taking the mean of two adjacent data points to form a new vector with a half of the <code>length(v)</code>. The last data point will be discarded if <code>length(v)</code> is odd.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking-Tuple{Array{T,1} where T,Array{T,1} where T}" href="#Rimu.Blocking.blocking-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blocking(x::Vector,y::Vector) -&gt; df::DataFrame</code></pre><p>Perform a blocking analysis for the quotient of means <code>x̄/ȳ</code> from two data sets. If <code>corrected</code> is <code>true</code> (the default) then the sums in both variance and covariance are scaled with <code>n-1</code>, whereas the sums are scaled with <code>n</code> if corrected is <code>false</code>  where <code>n = length(x) = length(y)</code>. Entries in returned dataframe:</p><ul><li><code>blocks</code> = number of blocks in current blocking step;</li><li><code>mean_x</code>, <code>SD_x</code>, <code>SE_x</code>, <code>SE_SE_x</code> = the mean, standard deviation, standard error and error on standard error estimated for dataset <code>x</code>;</li><li><code>mean_y</code>, <code>SD_y</code>, <code>SE_y</code>, <code>SE_SE_y</code> = ditto. for dataset <code>y</code>;</li><li><code>Covariance</code> = the covariance between data in <code>x</code> and <code>y</code>;</li><li><code>mean_f</code> = <code>x̄/ȳ</code>;</li><li><code>SE_f</code> = standard error estimated for <code>x̄/ȳ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L209-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.blocking-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blocking(v::Vector; corrected::Bool=true) -&gt; df</code></pre><p>Perform a blocking analysis according to Flyvberg and Peterson <a href="http://aip.scitation.org/doi/10.1063/1.457480">JCP (1989)</a> for single data set and return a <code>DataFrame</code> with statistical data for each blocking step. M-test data according to Jonsson <a href="https://link.aps.org/doi/10.1103/PhysRevE.98.043304">PRE (2018)</a> is also provided. If <code>corrected</code> is <code>true</code> (the default) then the sum in <code>var</code> is scaled with <code>n-1</code> and in <code>autocovariance</code> is scaled with <code>n-h</code>, whereas the sum is scaled with <code>n</code> for both if corrected is <code>false</code> where <code>n = length(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L122-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.blocking_old-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.blocking_old-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocking_old</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blocking(v::Vector; typos = nothing) -&gt; df</code></pre><p>Perform a blocking analysis according to Flyvberg and Peterson <a href="http://aip.scitation.org/doi/10.1063/1.457480">JCP (1989)</a> for single data set and return a <code>DataFrame</code> with statistical data for each blocking step. M-test data according to Jonsson <a href="https://link.aps.org/doi/10.1103/PhysRevE.98.043304">PRE (2018)</a> is also provided.</p><p>Keyword argument <code>typos</code></p><ul><li><code>typos = nothing</code> - correct all presumed typos.</li><li><code>typos = :FP</code> - use Flyvberg and Peterson (correct) standard error and Jonsson formul for M.</li><li><code>typos = :Jonsson</code> - calculate <code>M</code> and standard error as written in Jonsson.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L60-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.combination_division-Tuple{Array{T,1} where T,Array{T,1} where T}" href="#Rimu.Blocking.combination_division-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.combination_division</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">combination_division(x::Vector,y::Vector; corrected::Bool=true)</code></pre><p>Find the standard error on the quotient of means <code>x̄/ȳ</code> from two data sets, note that the standard errors are different on <span>$(x̄/ȳ) \neq \bar{(\frac{x}{y})}$</span>. If <code>corrected</code> is <code>true</code> (the default) then the sums in both variance and covariance are scaled with <code>n-1</code>, whereas the sums are scaled with <code>n</code> if corrected is <code>false</code>  where <code>n = length(x) = length(y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L180-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.covariance-Tuple{Array{T,1} where T,Array{T,1} where T}" href="#Rimu.Blocking.covariance-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.covariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">covariance(x::Vector,y::Vector; corrected::Bool=true)</code></pre><p>Calculate the covariance between the two data sets <code>x</code> and <code>y</code> with equal length. If <code>corrected</code> is <code>true</code> (the default) then the sum is scaled with  <code>n-1</code>, whereas the sum is scaled with <code>n</code> if corrected is <code>false</code>  where <code>n = length(x) = length(y)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.growthWitness-Tuple{AbstractArray,AbstractArray,Any}" href="#Rimu.Blocking.growthWitness-Tuple{AbstractArray,AbstractArray,Any}"><code>Rimu.Blocking.growthWitness</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">growthWitness(norm::AbstractArray, shift::AbstractArray, dt; b = 30, pad = :true) -&gt; g
growthWitness(df::DataFrame; b = 30, pad = :true) -&gt; g</code></pre><p>Compute the growth witness </p><div>\[G_b^{(n)} = S̄^{(n)} - \frac{\log\vert\mathbf{c}^{(n+b)}\vert - \log\vert\mathbf{c}^{(n)}\vert}{b d\tau},\]</div><p>where <code>S̄</code> is an average of the <code>shift</code> over <code>b</code> time steps and <span>$\vert\mathbf{c}^{(n)}\vert ==$</span> <code>norm[n]</code>.  The parameter <code>b ≥ 1</code> averages the derivative quantity over <code>b</code> time steps and helps suppress noise.</p><p>If <code>pad</code> is set to <code>:false</code> then the returned array <code>g</code> has the length <code>length(norm) - b</code>. If set to <code>:true</code> then <code>g</code> will be padded up to the same length as <code>norm</code> and <code>shift</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L450-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}" href="#Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.mtest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mtest(df::DataFrame; warn = true) -&gt; k</code></pre><p>The &quot;M test&quot; based on Jonsson, M. Physical Review E, 98(4), 043304, (2018). Expects <code>df</code> to be output of a blocking analysis with column <code>df.M</code> containing relevant M_j values, which are compared to a χ^2 distribution. Returns the row number <code>k</code> where the M-test is passed. If the M-test has failed <code>mtest()</code> returns the value <code>-1</code> and optionally prints a warning message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L297-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.Blocking.se-Tuple{Array{T,1} where T}" href="#Rimu.Blocking.se-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.se</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">se(v::Vector;corrected::Bool=true)</code></pre><p>Calculate the standard error of the dataset <code>v</code>. If <code>corrected</code> is <code>true</code> (the default) then the sum in <code>std</code> is scaled with <code>n-1</code>, whereas the sum is scaled with <code>n</code> if corrected is <code>false</code> where <code>n = length(v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/Blocking.jl#L38-L43">source</a></section></article><h2 id="Unexported-Submodules"><a class="docs-heading-anchor" href="#Unexported-Submodules">Unexported Submodules</a><a id="Unexported-Submodules-1"></a><a class="docs-heading-anchor-permalink" href="#Unexported-Submodules" title="Permalink"></a></h2><h3 id="FastBufs"><a class="docs-heading-anchor" href="#FastBufs">FastBufs</a><a id="FastBufs-1"></a><a class="docs-heading-anchor-permalink" href="#FastBufs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Rimu.FastBufs" href="#Rimu.FastBufs"><code>Rimu.FastBufs</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Provides the <code>FastBuf</code> data structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/FastBufs.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FastBufs.FastBuf" href="#Rimu.FastBufs.FastBuf"><code>Rimu.FastBufs.FastBuf</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FastBuf{T}(n)</code></pre><p>Create a first-in-last-out buffer of maximum capacity <code>n</code>. The element type is <code>T</code>. Fill a FastBuf with <code>push!()</code>, retrieve with <code>pop!()</code>. Accessing elements with <code>getindex()</code> and <code>setindex!()</code> as well as iteration are also supported. Check the capacity of a <code>FastBuf</code> with <code>capacity()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/FastBufs.jl#L12-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Rimu.FastBufs.capacity-Tuple{FastBuf}" href="#Rimu.FastBufs.capacity-Tuple{FastBuf}"><code>Rimu.FastBufs.capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Gives the capacity of a <code>FastBuf</code> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/cb10af721a1f59eaff43129a3b96d17f50000e23/src/FastBufs.jl#L39">source</a></section></article><h3 id="ConsistentRNG"><a class="docs-heading-anchor" href="#ConsistentRNG">ConsistentRNG</a><a id="ConsistentRNG-1"></a><a class="docs-heading-anchor-permalink" href="#ConsistentRNG" title="Permalink"></a></h3><p>Link to <a href="consistentrng.html#Module-ConsistentRNG.jl">Module <code>ConsistentRNG.jl</code></a></p><h1 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h1><ul><li><a href="API.html#Rimu.Blocking"><code>Rimu.Blocking</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG"><code>Rimu.ConsistentRNG</code></a></li><li><a href="API.html#Rimu.DictVectors"><code>Rimu.DictVectors</code></a></li><li><a href="API.html#Rimu.FastBufs"><code>Rimu.FastBufs</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a></li><li><a href="API.html#Rimu.Rimu"><code>Rimu.Rimu</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BSAdd128"><code>Rimu.BitStringAddresses.BSAdd128</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BSAdd64"><code>Rimu.BitStringAddresses.BSAdd64</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BStringAdd"><code>Rimu.BitStringAddresses.BStringAdd</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BitAdd"><code>Rimu.BitStringAddresses.BitAdd</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BitStringAddressType"><code>Rimu.BitStringAddresses.BitStringAddressType</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS"><code>Rimu.BitStringAddresses.BoseFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BoseFS-Union{Tuple{T}, Tuple{T}} where T&lt;:Union{Tuple, AbstractArray{T,1} where T}"><code>Rimu.BitStringAddresses.BoseFS</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.BosonicFockStateAddress"><code>Rimu.BitStringAddresses.BosonicFockStateAddress</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.CRNG"><code>Rimu.ConsistentRNG.CRNG</code></a></li><li><a href="API.html#Rimu.ConstantTimeStep"><code>Rimu.ConstantTimeStep</code></a></li><li><a href="API.html#Rimu.DelayedDoubleLogUpdate"><code>Rimu.DelayedDoubleLogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedDoubleLogUpdateAfterTW"><code>Rimu.DelayedDoubleLogUpdateAfterTW</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdate"><code>Rimu.DelayedLogUpdate</code></a></li><li><a href="API.html#Rimu.DelayedLogUpdateAfterTargetWalkers"><code>Rimu.DelayedLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DeltaMemory"><code>Rimu.DeltaMemory</code></a></li><li><a href="API.html#Rimu.DeltaMemory2"><code>Rimu.DeltaMemory2</code></a></li><li><a href="API.html#Rimu.DeltaMemory3"><code>Rimu.DeltaMemory3</code></a></li><li><a href="API.html#Rimu.DictVectors.ADVPairsIterator"><code>Rimu.DictVectors.ADVPairsIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.AbstractDVec"><code>Rimu.DictVectors.AbstractDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.DFVec"><code>Rimu.DictVectors.DFVec</code></a></li><li><a href="API.html#Rimu.DictVectors.DVec"><code>Rimu.DictVectors.DVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FastDVec"><code>Rimu.DictVectors.FastDVec</code></a></li><li><a href="API.html#Rimu.DictVectors.FlagsIterator"><code>Rimu.DictVectors.FlagsIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.KVPairsIterator"><code>Rimu.DictVectors.KVPairsIterator</code></a></li><li><a href="API.html#Rimu.DictVectors.Norm2Projector"><code>Rimu.DictVectors.Norm2Projector</code></a></li><li><a href="API.html#Rimu.DictVectors.NormProjector"><code>Rimu.DictVectors.NormProjector</code></a></li><li><a href="API.html#Rimu.DictVectors.UniformProjector"><code>Rimu.DictVectors.UniformProjector</code></a></li><li><a href="API.html#Rimu.DontUpdate"><code>Rimu.DontUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogProjected"><code>Rimu.DoubleLogProjected</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdate"><code>Rimu.DoubleLogUpdate</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkers"><code>Rimu.DoubleLogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.DoubleLogUpdateAfterTargetWalkersSwitch"><code>Rimu.DoubleLogUpdateAfterTargetWalkersSwitch</code></a></li><li><a href="API.html#Rimu.EveryKthStep"><code>Rimu.EveryKthStep</code></a></li><li><a href="API.html#Rimu.EveryTimeStep"><code>Rimu.EveryTimeStep</code></a></li><li><a href="API.html#Rimu.FastBufs.FastBuf"><code>Rimu.FastBufs.FastBuf</code></a></li><li><a href="API.html#Rimu.FciqmcRunStrategy"><code>Rimu.FciqmcRunStrategy</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AbstractHamiltonian"><code>Rimu.Hamiltonians.AbstractHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D"><code>Rimu.Hamiltonians.BoseHubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D"><code>Rimu.Hamiltonians.BoseHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BosonicHamiltonian"><code>Rimu.Hamiltonians.BosonicHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedBHReal1D"><code>Rimu.Hamiltonians.ExtendedBHReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Hops"><code>Rimu.Hamiltonians.Hops</code></a></li><li><a href="API.html#Rimu.HistoryLogUpdate"><code>Rimu.HistoryLogUpdate</code></a></li><li><a href="API.html#Rimu.IsSemistochastic"><code>Rimu.IsSemistochastic</code></a></li><li><a href="API.html#Rimu.IsStochasticWithThreshold"><code>Rimu.IsStochasticWithThreshold</code></a></li><li><a href="API.html#Rimu.LogUpdate"><code>Rimu.LogUpdate</code></a></li><li><a href="API.html#Rimu.LogUpdateAfterTargetWalkers"><code>Rimu.LogUpdateAfterTargetWalkers</code></a></li><li><a href="API.html#Rimu.MPIData"><code>Rimu.MPIData</code></a></li><li><a href="API.html#Rimu.MPIDefault"><code>Rimu.MPIDefault</code></a></li><li><a href="API.html#Rimu.MPINoWalkerExchange"><code>Rimu.MPINoWalkerExchange</code></a></li><li><a href="API.html#Rimu.MPIOSWin"><code>Rimu.MPIOSWin</code></a></li><li><a href="API.html#Rimu.MemoryStrategy"><code>Rimu.MemoryStrategy</code></a></li><li><a href="API.html#Rimu.NoMemory"><code>Rimu.NoMemory</code></a></li><li><a href="API.html#Rimu.NoProjection"><code>Rimu.NoProjection</code></a></li><li><a href="API.html#Rimu.NoProjectionTwoNorm"><code>Rimu.NoProjectionTwoNorm</code></a></li><li><a href="API.html#Rimu.ProjectStrategy"><code>Rimu.ProjectStrategy</code></a></li><li><a href="API.html#Rimu.ProjectedMemory"><code>Rimu.ProjectedMemory</code></a></li><li><a href="API.html#Rimu.ReportDFAndInfo"><code>Rimu.ReportDFAndInfo</code></a></li><li><a href="API.html#Rimu.ReportingStrategy"><code>Rimu.ReportingStrategy</code></a></li><li><a href="API.html#Rimu.RunTillLastStep"><code>Rimu.RunTillLastStep</code></a></li><li><a href="API.html#Rimu.ScaledThresholdProject"><code>Rimu.ScaledThresholdProject</code></a></li><li><a href="API.html#Rimu.ShiftMemory"><code>Rimu.ShiftMemory</code></a></li><li><a href="API.html#Rimu.ShiftStrategy"><code>Rimu.ShiftStrategy</code></a></li><li><a href="API.html#Rimu.StochasticStyle"><code>Rimu.StochasticStyle</code></a></li><li><a href="API.html#Rimu.ThresholdProject"><code>Rimu.ThresholdProject</code></a></li><li><a href="API.html#Rimu.TimeStepStrategy"><code>Rimu.TimeStepStrategy</code></a></li><li><a href="API.html#Base.:&lt;&lt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&lt;&lt;</code></a></li><li><a href="API.html#Base.:&gt;&gt;&gt;-Union{Tuple{B}, Tuple{I}, Tuple{BitAdd{I,B},Integer}} where B where I"><code>Base.:&gt;&gt;&gt;</code></a></li><li><a href="API.html#Base.fill!-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDVec{K,V},V}} where V where K"><code>Base.fill!</code></a></li><li><a href="API.html#Base.get-Tuple{DFVec,Any,Tuple}"><code>Base.get</code></a></li><li><a href="API.html#Base.get-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any,Number}} where F where V where K"><code>Base.get</code></a></li><li><a href="API.html#Base.isequal-Tuple{AbstractDVec,AbstractDVec}"><code>Base.isequal</code></a></li><li><a href="API.html#Base.isequal-Tuple{DFVec,DFVec}"><code>Base.isequal</code></a></li><li><a href="API.html#Base.length-Tuple{MPIData}"><code>Base.length</code></a></li><li><a href="API.html#LinearAlgebra.axpy!-Tuple{Number,AbstractDVec,AbstractDVec}"><code>LinearAlgebra.axpy!</code></a></li><li><a href="API.html#LinearAlgebra.norm"><code>LinearAlgebra.norm</code></a></li><li><a href="API.html#LinearAlgebra.norm-Tuple{AbstractDVec}"><code>LinearAlgebra.norm</code></a></li><li><a href="API.html#LinearAlgebra.norm-Tuple{AbstractDVec,Real}"><code>LinearAlgebra.norm</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.bitaddr-Union{Tuple{T}, Tuple{Any,Type{T}}} where T&lt;:Integer"><code>Rimu.BitStringAddresses.bitaddr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.lbshr-Union{Tuple{I}, Tuple{N}, Tuple{StaticArrays.SArray{Tuple{N},I,1,N},Any}} where I where N"><code>Rimu.BitStringAddresses.lbshr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.nearUniform-Union{Tuple{Type{BoseFS{N,M,A}}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.nearUniform</code></a></li><li><a href="hamiltonians.html#Rimu.BitStringAddresses.nearUniform"><code>Rimu.BitStringAddresses.nearUniform</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.nearUniformONR-Tuple{Number,Number}"><code>Rimu.BitStringAddresses.nearUniformONR</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numBits-Tuple{Type}"><code>Rimu.BitStringAddresses.numBits</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numChunks-Tuple{Type}"><code>Rimu.BitStringAddresses.numChunks</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numModes-Tuple{Type}"><code>Rimu.BitStringAddresses.numModes</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.numParticles-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>Rimu.BitStringAddresses.numParticles</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.onr-Union{Tuple{BoseFS{N,M,A}}, Tuple{A}, Tuple{M}, Tuple{N}} where A where M where N"><code>Rimu.BitStringAddresses.onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.onr-Union{Tuple{A}, Tuple{A,Integer}} where A&lt;:Integer"><code>Rimu.BitStringAddresses.onr</code></a></li><li><a href="API.html#Rimu.BitStringAddresses.remove_ghost_bits-Union{Tuple{BitAdd{I,B}}, Tuple{B}, Tuple{I}} where B where I"><code>Rimu.BitStringAddresses.remove_ghost_bits</code></a></li><li><a href="API.html#Rimu.Blocking.autoblock-Tuple{Tuple}"><code>Rimu.Blocking.autoblock</code></a></li><li><a href="API.html#Rimu.Blocking.autoblock-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.autoblock</code></a></li><li><a href="API.html#Rimu.Blocking.autocovariance-Tuple{Array{T,1} where T,Int64}"><code>Rimu.Blocking.autocovariance</code></a></li><li><a href="API.html#Rimu.Blocking.blockAndMTest-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blockAndMTest</code></a></li><li><a href="API.html#Rimu.Blocking.blocker-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocker</code></a></li><li><a href="API.html#Rimu.Blocking.blocking-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a></li><li><a href="API.html#Rimu.Blocking.blocking-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.blocking</code></a></li><li><a href="API.html#Rimu.Blocking.blocking_old-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.blocking_old</code></a></li><li><a href="API.html#Rimu.Blocking.combination_division-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.combination_division</code></a></li><li><a href="API.html#Rimu.Blocking.covariance-Tuple{Array{T,1} where T,Array{T,1} where T}"><code>Rimu.Blocking.covariance</code></a></li><li><a href="API.html#Rimu.Blocking.growthWitness-Tuple{AbstractArray,AbstractArray,Any}"><code>Rimu.Blocking.growthWitness</code></a></li><li><a href="API.html#Rimu.Blocking.mtest-Tuple{DataFrames.DataFrame}"><code>Rimu.Blocking.mtest</code></a></li><li><a href="API.html#Rimu.Blocking.se-Tuple{Array{T,1} where T}"><code>Rimu.Blocking.se</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.cRand-Tuple"><code>Rimu.ConsistentRNG.cRand</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.newChildRNG"><code>Rimu.ConsistentRNG.newChildRNG</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.seedCRNG!-Tuple{Array{T,1} where T}"><code>Rimu.ConsistentRNG.seedCRNG!</code></a></li><li><a href="consistentrng.html#Rimu.ConsistentRNG.trng-Tuple{}"><code>Rimu.ConsistentRNG.trng</code></a></li><li><a href="API.html#Rimu.DictVectors.add!-Union{Tuple{V2}, Tuple{V1}, Tuple{K}, Tuple{AbstractDVec{K,V1},AbstractDVec{K,V2}}} where V2 where V1 where K"><code>Rimu.DictVectors.add!</code></a></li><li><a href="API.html#Rimu.DictVectors.capacity"><code>Rimu.DictVectors.capacity</code></a></li><li><a href="API.html#Rimu.DictVectors.flags-Tuple{DFVec}"><code>Rimu.DictVectors.flags</code></a></li><li><a href="API.html#Rimu.DictVectors.gettuple-Union{Tuple{F}, Tuple{V}, Tuple{K}, Tuple{DFVec{K,V,F},Any}} where F where V where K"><code>Rimu.DictVectors.gettuple</code></a></li><li><a href="API.html#Rimu.DictVectors.kvpairs-Tuple{Any}"><code>Rimu.DictVectors.kvpairs</code></a></li><li><a href="API.html#Rimu.DictVectors.kvpairs-Tuple{DFVec}"><code>Rimu.DictVectors.kvpairs</code></a></li><li><a href="API.html#Rimu.DictVectors.normInf-Tuple{AbstractDVec}"><code>Rimu.DictVectors.normInf</code></a></li><li><a href="API.html#Rimu.DictVectors.norm_sqr-Union{Tuple{AbstractDVec{K,V}}, Tuple{K}, Tuple{V}} where K where V&lt;:Number"><code>Rimu.DictVectors.norm_sqr</code></a></li><li><a href="API.html#Rimu.DictVectors.pairtype-Tuple{Any}"><code>Rimu.DictVectors.pairtype</code></a></li><li><a href="API.html#Rimu.DictVectors.tuples-Tuple{DFVec}"><code>Rimu.DictVectors.tuples</code></a></li><li><a href="API.html#Rimu.DictVectors.zero!-Tuple{AbstractDVec}"><code>Rimu.DictVectors.zero!</code></a></li><li><a href="API.html#Rimu.FastBufs.capacity-Tuple{FastBuf}"><code>Rimu.FastBufs.capacity</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.bit_String_Length"><code>Rimu.Hamiltonians.bit_String_Length</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.diagME"><code>Rimu.Hamiltonians.diagME</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimensionLO"><code>Rimu.Hamiltonians.dimensionLO</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.fDimensionLO"><code>Rimu.Hamiltonians.fDimensionLO</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.generateRandHop"><code>Rimu.Hamiltonians.generateRandHop</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.hasIntDimension"><code>Rimu.Hamiltonians.hasIntDimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.hop"><code>Rimu.Hamiltonians.hop</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.numOfHops"><code>Rimu.Hamiltonians.numOfHops</code></a></li><li><a href="API.html#Rimu.applyMemoryNoise!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.applyMemoryNoise!</code></a></li><li><a href="API.html#Rimu.clearDFlags!-Tuple{Any}"><code>Rimu.clearDFlags!</code></a></li><li><a href="API.html#Rimu.compute_proj_observables-Union{Tuple{RS}, Tuple{DV}, Tuple{Any,Any,RS}} where RS&lt;:ReportingStrategy{DV} where DV&lt;:Missing"><code>Rimu.compute_proj_observables</code></a></li><li><a href="API.html#Rimu.fciqmc!"><code>Rimu.fciqmc!</code></a></li><li><a href="API.html#Rimu.fciqmc_col!-Tuple{Union{AbstractArray, AbstractDVec},Vararg{Any,N} where N}"><code>Rimu.fciqmc_col!</code></a></li><li><a href="API.html#Rimu.fciqmc_step!-Union{Tuple{D}, Tuple{Any,D,Any,Any,Any,D}} where D"><code>Rimu.fciqmc_step!</code></a></li><li><a href="API.html#Rimu.free-Tuple{MPIOSWin}"><code>Rimu.free</code></a></li><li><a href="API.html#Rimu.greet-Tuple{}"><code>Rimu.greet</code></a></li><li><a href="API.html#Rimu.lomc!-Tuple{Any,Any}"><code>Rimu.lomc!</code></a></li><li><a href="API.html#Rimu.lomc!-Tuple{NamedTuple}"><code>Rimu.lomc!</code></a></li><li><a href="API.html#Rimu.mpi_default"><code>Rimu.mpi_default</code></a></li><li><a href="API.html#Rimu.mpi_no_exchange"><code>Rimu.mpi_no_exchange</code></a></li><li><a href="API.html#Rimu.mpi_one_sided"><code>Rimu.mpi_one_sided</code></a></li><li><a href="API.html#Rimu.next_mpiID"><code>Rimu.next_mpiID</code></a></li><li><a href="API.html#Rimu.norm_project!-Tuple{Any,Any}"><code>Rimu.norm_project!</code></a></li><li><a href="API.html#Rimu.put-Union{Tuple{T}, Tuple{Array{T,1},Integer,Integer,MPIOSWin{T}}} where T"><code>Rimu.put</code></a></li><li><a href="API.html#Rimu.report!-Tuple{DataFrames.DataFrame,Tuple,EveryTimeStep}"><code>Rimu.report!</code></a></li><li><a href="API.html#Rimu.setSemistochastic!-Tuple{Any,Float16,Any}"><code>Rimu.setSemistochastic!</code></a></li><li><a href="API.html#Rimu.setThreshold-Tuple{Any,Any}"><code>Rimu.setThreshold</code></a></li><li><a href="API.html#Rimu.sort_into_targets!-Tuple{Any,Any,Any}"><code>Rimu.sort_into_targets!</code></a></li><li><a href="API.html#Rimu.sort_into_targets!-Tuple{MPIData,AbstractDVec}"><code>Rimu.sort_into_targets!</code></a></li><li><a href="API.html#Rimu.targetrank"><code>Rimu.targetrank</code></a></li><li><a href="API.html#Rimu.update_dτ-Tuple{ConstantTimeStep,Any,Vararg{Any,N} where N}"><code>Rimu.update_dτ</code></a></li><li><a href="API.html#Rimu.update_shift-Tuple{HistoryLogUpdate,Any,Any,Any,Any,Any,Any,Any,Vararg{Any,N} where N}"><code>Rimu.update_shift</code></a></li><li><a href="API.html#Rimu.@setDeterministic-Tuple{Any}"><code>Rimu.@setDeterministic</code></a></li><li><a href="API.html#Rimu.@setThreshold-Tuple{Any,Any}"><code>Rimu.@setThreshold</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="testing.html">« Code testing</a><a class="docs-footer-nextpage" href="BHM-example.html">Example: 1D Bose-Hubbard Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 3 November 2020 08:52">Tuesday 3 November 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
