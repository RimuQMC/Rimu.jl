<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Exact diagonalisation · Rimu.jl</title><meta name="title" content="Exact diagonalisation · Rimu.jl"/><meta property="og:title" content="Exact diagonalisation · Rimu.jl"/><meta property="twitter:title" content="Exact diagonalisation · Rimu.jl"/><meta name="description" content="Documentation for Rimu.jl."/><meta property="og:description" content="Documentation for Rimu.jl."/><meta property="twitter:description" content="Documentation for Rimu.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Rimu.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Guide</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="BHM-example.html">1D Bose-Hubbard Model</a></li><li><a class="tocitem" href="BHM-example-mpi.html">Rimu with MPI</a></li><li><a class="tocitem" href="G2-example.html">Calculating observables</a></li><li class="is-active"><a class="tocitem" href="exact-example.html">Exact diagonalisation</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#The-BasisSetRepresentation"><span>The BasisSetRepresentation</span></a></li><li><a class="tocitem" href="#Computing-eigenvalues"><span>Computing eigenvalues</span></a></li><li><a class="tocitem" href="#Reducing-matrix-size-with-symmetries"><span>Reducing matrix size with symmetries</span></a></li><li><a class="tocitem" href="#Computing-observables"><span>Computing observables</span></a></li></ul></li><li><a class="tocitem" href="HO-example.html">Degenerate perturbation theory in a harmonic oscillator basis</a></li></ul></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="../exactdiagonalization.html">Exact Diagonalization</a></li><li><a class="tocitem" href="../statstools.html">StatsTools</a></li><li><a class="tocitem" href="../mpi.html">Using MPI</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="../interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../hamiltonians.html">Hamiltonians</a></li><li><a class="tocitem" href="../dictvectors.html">Dict vectors</a></li><li><a class="tocitem" href="../addresses.html">BitString addresses</a></li><li><a class="tocitem" href="../stochasticstyles.html">Stochastic styles</a></li><li><a class="tocitem" href="../RMPI.html">RMPI</a></li><li><a class="tocitem" href="../rimuio.html">I/O</a></li><li><a class="tocitem" href="../randomnumbers.html">Random numbers</a></li><li><a class="tocitem" href="../documentation.html">Documentation generation</a></li><li><a class="tocitem" href="../testing.html">Code testing</a></li></ul></li><li><a class="tocitem" href="../API.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href="exact-example.html">Exact diagonalisation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="exact-example.html">Exact diagonalisation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/joachimbrand/Rimu.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/joachimbrand/Rimu.jl/blob/develop/scripts/exact-example.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Example-4:-Exact-diagonalisation"><a class="docs-heading-anchor" href="#Example-4:-Exact-diagonalisation">Example 4: Exact diagonalisation</a><a id="Example-4:-Exact-diagonalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Example-4:-Exact-diagonalisation" title="Permalink"></a></h1><p>When working with smaller systems or when multiple eigenvalues of a system are required, one can use an exact diagonalisation method. There are a few ways to go about this, each with its pros and cons. The purpose of this tutorial is to show off the methods as well as provide a few tips regarding them.</p><p>A runnable script for this example is located <a href="https://github.com/joachimbrand/Rimu.jl/blob/develop/scripts/exact-example.jl">here</a>. Run it with <code>julia exact-example.jl</code>.</p><p>We start by loading Rimu.</p><pre><code class="language-julia hljs">using Rimu</code></pre><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>We will look at a bosonic system of 4 particles in 5 sites, formulated in momentum space. Let&#39;s start by building the Hamiltonian. To create a Fock state where all particles have zero momentum, we put all the particles in the mode at the centre of the address.</p><pre><code class="language-julia hljs">M = 5
N = 4
add = BoseFS(M, cld(M, 2) =&gt; N)
ham = HubbardMom1D(add)</code></pre><pre><code class="nohighlight hljs">HubbardMom1D(BoseFS{4,5}(0, 0, 4, 0, 0); u=1.0, t=1.0)</code></pre><p>Before performing exact diagonalisation, it is a good idea to check the dimension of the Hamiltonian.</p><pre><code class="language-julia hljs">dimension(ham)</code></pre><pre><code class="nohighlight hljs">70</code></pre><p>Keep in mind that this is an estimate of the number of Fock states the Hamiltonian can act on, not the actual matrix size - the matrix size can sometimes be smaller. It can still be used as a guide to decide whether a Hamiltonian is amenable to exact diagonalisation and to determine which algorithm would be best suited to diagonalising it.</p><h2 id="The-BasisSetRepresentation"><a class="docs-heading-anchor" href="#The-BasisSetRepresentation">The BasisSetRepresentation</a><a id="The-BasisSetRepresentation-1"></a><a class="docs-heading-anchor-permalink" href="#The-BasisSetRepresentation" title="Permalink"></a></h2><p>As we&#39;ll see later, there are two ways to construct the matrices from Hamiltonians directly, but they both use <a href="../exactdiagonalization.html#Rimu.ExactDiagonalization.BasisSetRepresentation"><code>BasisSetRepresentation</code></a> under the hood. The <a href="../exactdiagonalization.html#Rimu.ExactDiagonalization.BasisSetRepresentation"><code>BasisSetRepresentation</code></a>, when called with a Hamiltonian and optionally a starting address, constructs the sparse matrix of the system, as well as its basis. The starting address defaults to the one that was used to initialize the Hamiltonian. <a href="../exactdiagonalization.html#Rimu.ExactDiagonalization.BasisSetRepresentation"><code>BasisSetRepresentation</code></a> only returns the part of the matrix that is accessible from this starting address through non-zero offdiagonal elements.</p><pre><code class="language-julia hljs">bsr = BasisSetRepresentation(ham);</code></pre><p>To access the matrix or basis, access the <code>sparse_matrix</code> and <code>basis</code> fields, respectively.</p><pre><code class="language-julia hljs">bsr.sparse_matrix</code></pre><pre><code class="nohighlight hljs">14×14 SparseArrays.SparseMatrixCSC{Float64, Int64} with 104 stored entries:
 -6.8       0.69282   0.69282    ⋅         ⋅         ⋅         ⋅          ⋅         ⋅         ⋅         ⋅         ⋅         ⋅         ⋅ 
  0.69282  -3.03607   0.4       0.8       0.4       0.8       0.4        0.565685  0.282843   ⋅         ⋅         ⋅         ⋅         ⋅ 
  0.69282   0.4       1.43607   0.4       0.8       0.4       0.8         ⋅        0.282843  0.565685   ⋅         ⋅         ⋅         ⋅ 
   ⋅        0.8       0.4       0.581966  0.4        ⋅        0.4        0.282843  0.565685   ⋅        0.69282   0.69282    ⋅         ⋅ 
   ⋅        0.4       0.8       0.4       2.81803   0.4        ⋅          ⋅        0.565685  0.282843  0.69282    ⋅        0.69282    ⋅ 
   ⋅        0.8       0.4        ⋅        0.4       0.581966  0.4        0.282843  0.565685   ⋅         ⋅         ⋅        0.69282   0.69282
   ⋅        0.4       0.8       0.4        ⋅        0.4       2.81803     ⋅        0.565685  0.282843   ⋅        0.69282    ⋅        0.69282
   ⋅        0.565685   ⋅        0.282843   ⋅        0.282843   ⋅        -0.472136  0.8        ⋅        0.489898   ⋅         ⋅        0.489898
   ⋅        0.282843  0.282843  0.565685  0.565685  0.565685  0.565685   0.8       4.4       0.8       0.489898  0.489898  0.489898  0.489898
   ⋅         ⋅        0.565685   ⋅        0.282843   ⋅        0.282843    ⋅        0.8       8.47214    ⋅        0.489898  0.489898   ⋅ 
   ⋅         ⋅         ⋅        0.69282   0.69282    ⋅         ⋅         0.489898  0.489898   ⋅        1.56393    ⋅         ⋅         ⋅ 
   ⋅         ⋅         ⋅        0.69282    ⋅         ⋅        0.69282     ⋅        0.489898  0.489898   ⋅        6.03607    ⋅         ⋅ 
   ⋅         ⋅         ⋅         ⋅        0.69282   0.69282    ⋅          ⋅        0.489898  0.489898   ⋅         ⋅        6.03607    ⋅ 
   ⋅         ⋅         ⋅         ⋅         ⋅        0.69282   0.69282    0.489898  0.489898   ⋅         ⋅         ⋅         ⋅        1.56393</code></pre><pre><code class="language-julia hljs">bsr.basis</code></pre><pre><code class="nohighlight hljs">14-element Vector{BoseFS{4, 5, BitString{8, 1, UInt8}}}:
 fs&quot;|0 0 4 0 0⟩&quot;
 fs&quot;|0 1 2 1 0⟩&quot;
 fs&quot;|1 0 2 0 1⟩&quot;
 fs&quot;|1 0 1 2 0⟩&quot;
 fs&quot;|0 0 1 1 2⟩&quot;
 fs&quot;|0 2 1 0 1⟩&quot;
 fs&quot;|2 1 1 0 0⟩&quot;
 fs&quot;|0 2 0 2 0⟩&quot;
 fs&quot;|1 1 0 1 1⟩&quot;
 fs&quot;|2 0 0 0 2⟩&quot;
 fs&quot;|0 0 0 3 1⟩&quot;
 fs&quot;|3 0 0 1 0⟩&quot;
 fs&quot;|0 1 0 0 3⟩&quot;
 fs&quot;|1 3 0 0 0⟩&quot;</code></pre><p>When the basis is not needed, we can use <code>Matrix</code> or <code>sparse</code> directly.</p><pre><code class="language-julia hljs">Matrix(ham)</code></pre><pre><code class="nohighlight hljs">14×14 Matrix{Float64}:
 -6.8       0.69282   0.69282   0.0       0.0       0.0       0.0        0.0       0.0       0.0       0.0       0.0       0.0       0.0
  0.69282  -3.03607   0.4       0.8       0.4       0.8       0.4        0.565685  0.282843  0.0       0.0       0.0       0.0       0.0
  0.69282   0.4       1.43607   0.4       0.8       0.4       0.8        0.0       0.282843  0.565685  0.0       0.0       0.0       0.0
  0.0       0.8       0.4       0.581966  0.4       0.0       0.4        0.282843  0.565685  0.0       0.69282   0.69282   0.0       0.0
  0.0       0.4       0.8       0.4       2.81803   0.4       0.0        0.0       0.565685  0.282843  0.69282   0.0       0.69282   0.0
  0.0       0.8       0.4       0.0       0.4       0.581966  0.4        0.282843  0.565685  0.0       0.0       0.0       0.69282   0.69282
  0.0       0.4       0.8       0.4       0.0       0.4       2.81803    0.0       0.565685  0.282843  0.0       0.69282   0.0       0.69282
  0.0       0.565685  0.0       0.282843  0.0       0.282843  0.0       -0.472136  0.8       0.0       0.489898  0.0       0.0       0.489898
  0.0       0.282843  0.282843  0.565685  0.565685  0.565685  0.565685   0.8       4.4       0.8       0.489898  0.489898  0.489898  0.489898
  0.0       0.0       0.565685  0.0       0.282843  0.0       0.282843   0.0       0.8       8.47214   0.0       0.489898  0.489898  0.0
  0.0       0.0       0.0       0.69282   0.69282   0.0       0.0        0.489898  0.489898  0.0       1.56393   0.0       0.0       0.0
  0.0       0.0       0.0       0.69282   0.0       0.0       0.69282    0.0       0.489898  0.489898  0.0       6.03607   0.0       0.0
  0.0       0.0       0.0       0.0       0.69282   0.69282   0.0        0.0       0.489898  0.489898  0.0       0.0       6.03607   0.0
  0.0       0.0       0.0       0.0       0.0       0.69282   0.69282    0.489898  0.489898  0.0       0.0       0.0       0.0       1.56393</code></pre><pre><code class="language-julia hljs">sparse(ham)</code></pre><pre><code class="nohighlight hljs">14×14 SparseArrays.SparseMatrixCSC{Float64, Int64} with 104 stored entries:
 -6.8       0.69282   0.69282    ⋅         ⋅         ⋅         ⋅          ⋅         ⋅         ⋅         ⋅         ⋅         ⋅         ⋅ 
  0.69282  -3.03607   0.4       0.8       0.4       0.8       0.4        0.565685  0.282843   ⋅         ⋅         ⋅         ⋅         ⋅ 
  0.69282   0.4       1.43607   0.4       0.8       0.4       0.8         ⋅        0.282843  0.565685   ⋅         ⋅         ⋅         ⋅ 
   ⋅        0.8       0.4       0.581966  0.4        ⋅        0.4        0.282843  0.565685   ⋅        0.69282   0.69282    ⋅         ⋅ 
   ⋅        0.4       0.8       0.4       2.81803   0.4        ⋅          ⋅        0.565685  0.282843  0.69282    ⋅        0.69282    ⋅ 
   ⋅        0.8       0.4        ⋅        0.4       0.581966  0.4        0.282843  0.565685   ⋅         ⋅         ⋅        0.69282   0.69282
   ⋅        0.4       0.8       0.4        ⋅        0.4       2.81803     ⋅        0.565685  0.282843   ⋅        0.69282    ⋅        0.69282
   ⋅        0.565685   ⋅        0.282843   ⋅        0.282843   ⋅        -0.472136  0.8        ⋅        0.489898   ⋅         ⋅        0.489898
   ⋅        0.282843  0.282843  0.565685  0.565685  0.565685  0.565685   0.8       4.4       0.8       0.489898  0.489898  0.489898  0.489898
   ⋅         ⋅        0.565685   ⋅        0.282843   ⋅        0.282843    ⋅        0.8       8.47214    ⋅        0.489898  0.489898   ⋅ 
   ⋅         ⋅         ⋅        0.69282   0.69282    ⋅         ⋅         0.489898  0.489898   ⋅        1.56393    ⋅         ⋅         ⋅ 
   ⋅         ⋅         ⋅        0.69282    ⋅         ⋅        0.69282     ⋅        0.489898  0.489898   ⋅        6.03607    ⋅         ⋅ 
   ⋅         ⋅         ⋅         ⋅        0.69282   0.69282    ⋅          ⋅        0.489898  0.489898   ⋅         ⋅        6.03607    ⋅ 
   ⋅         ⋅         ⋅         ⋅         ⋅        0.69282   0.69282    0.489898  0.489898   ⋅         ⋅         ⋅         ⋅        1.56393</code></pre><h2 id="Computing-eigenvalues"><a class="docs-heading-anchor" href="#Computing-eigenvalues">Computing eigenvalues</a><a id="Computing-eigenvalues-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-eigenvalues" title="Permalink"></a></h2><p>Now that we have a way of constructing matrices from Hamiltonians, we can use standard Julia functionality to diagonalise them.</p><h3 id="The-built-in-method"><a class="docs-heading-anchor" href="#The-built-in-method">The built-in method</a><a id="The-built-in-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-built-in-method" title="Permalink"></a></h3><p>Let&#39;s begin by looking at the <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.eigen"><code>eigen</code></a>, <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.eigvecs"><code>eigvecs</code></a>, and <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.eigvals"><code>eigvals</code></a> functions from the LinearAlgebra standard library. They operate on dense matrices and return the full spectra, hence they are only useful for small systems, or when all eigenvalues are required.</p><pre><code class="language-julia hljs">using LinearAlgebra

mat = Matrix(ham)
eig = eigen(mat);</code></pre><p>The values can be accessed like so:</p><pre><code class="language-julia hljs">eig.values</code></pre><pre><code class="nohighlight hljs">14-element Vector{Float64}:
 -6.9798639983216155
 -3.363124291613371
 -0.7590191922770746
  0.1358418221962303
  0.1578999869460933
  0.8767114411781396
  1.530592997097333
  1.5835732611867464
  3.072870330325867
  3.125672653951849
  4.862107221562182
  6.26069485038059
  6.402671211183119
  9.093371706203957</code></pre><p>The vectors are stored as columns in <code>eig.vectors</code>:</p><pre><code class="language-julia hljs">eig.vectors</code></pre><pre><code class="nohighlight hljs">14×14 Matrix{Float64}:
 -0.980348     0.175378     0.0135766   -2.81719e-15  -0.0221221  -0.0697193   1.3739e-15    0.0314466   -2.35922e-16  -0.0360987   -0.0161557  -5.55112e-17   0.00625248  -0.0058099
  0.177701     0.932229     0.105473     3.01009e-14   0.225254   -0.132826    9.71445e-17  -0.00292026  -2.09555e-15  -0.0861158   -0.0907789  -4.996e-16     0.0591715   -0.0264275
  0.0768085   -0.0622307    0.0129069   -6.06251e-14  -0.447424   -0.63969     2.05322e-14   0.383444    -6.54338e-15  -0.431051    -0.181167   -6.10623e-16   0.0599783   -0.106852
 -0.0214153   -0.175119    -0.20169      0.616673      0.522017   -0.296818   -0.31234      -0.122119    -0.123629     -0.106455    -0.126661    0.0829132     0.148347    -0.0574235
 -0.0119687   -0.0373038    0.0678797    0.0693699     0.0495446   0.416847    0.33773       0.0584554   -0.601232     -0.467179    -0.215841   -0.140166      0.190543    -0.114342
 -0.0214153   -0.175119    -0.20169     -0.616673      0.522017   -0.296818    0.31234      -0.122119     0.123629     -0.106455    -0.126661   -0.0829132     0.148347    -0.0574235
 -0.0119687   -0.0373038    0.0678797   -0.0693699     0.0495446   0.416847   -0.33773       0.0584554    0.601232     -0.467179    -0.215841    0.140166      0.190543    -0.114342
 -0.0138439   -0.165902     0.922758     1.00753e-14   0.1111     -0.172508   -1.30521e-14  -0.207974     2.66454e-15   0.0848902   -0.149153   -8.32667e-16   0.0712921   -0.0301968
 -0.00234782   0.00840544  -0.098969    -9.6867e-15   -0.0847116   0.082999    1.51129e-14   0.274424     3.60822e-15   0.575786    -0.61385    -2.72005e-15   0.353775    -0.259338
 -0.00237613   0.00294196   0.00143189   5.56152e-15   0.0427486   0.0110863  -3.72619e-15  -0.0663108    9.50628e-16   0.00167015   0.0832916   2.91434e-15  -0.448519    -0.8863
  0.00363555   0.0455298   -0.133824    -0.332825     -0.290831   -0.057199   -0.527627     -0.588225    -0.332816     -0.0472302   -0.18528    -0.00844536    0.0915588   -0.0346434
  0.00195478   0.0150664    0.0206752   -0.0642658    -0.0638689  -0.0250518   0.0999631    -0.012992    -0.111668      0.0393523    0.423534    0.688046      0.513839    -0.222499
  0.00195478   0.0150664    0.0206752    0.0642658    -0.0638689  -0.0250518  -0.0999631    -0.012992     0.111668      0.0393523    0.423534   -0.688046      0.513839    -0.222499
  0.00363555   0.0455298   -0.133824     0.332825     -0.290831   -0.057199    0.527627     -0.588225     0.332816     -0.0472302   -0.18528     0.00844536    0.0915588   -0.0346434</code></pre><p>If you need the full spectrum, but would like to use less memory, consider using the in-place <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#LinearAlgebra.eigen!"><code>eigen!</code></a>.</p><h3 id="Iterative-sparse-solvers"><a class="docs-heading-anchor" href="#Iterative-sparse-solvers">Iterative sparse solvers</a><a id="Iterative-sparse-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-sparse-solvers" title="Permalink"></a></h3><p>For larger Hamiltonians, it is better to use an iterative solver. There are several options. We will look at <a href="https://arpack.julialinearalgebra.org/stable/api/#Arpack.eigs-Tuple{Any}"><code>eigs</code></a> from <a href="https://github.com/JuliaLinearAlgebra/Arpack.jl"><code>Arpack.jl</code></a> and <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>eigsolve</code></a> from <a href="https://github.com/Jutho/KrylovKit.jl/">KrylovKit.jl</a>.</p><p>Let&#39;s start with Arpack&#39;s <a href="https://arpack.julialinearalgebra.org/stable/api/#Arpack.eigs-Tuple{Any}"><code>eigs</code></a>. It is important to set the <code>nev</code> and <code>which</code> keyword arguments. <code>nev</code> sets the number of eigenpairs to find. <code>which</code> should in most cases be set to <code>:SR</code>, which will find the eigenvalues with the smallest real part.</p><pre><code class="language-julia hljs">using Arpack

num_eigvals = 3

sparse_matrix = sparse(ham)
vals_ar, vecs_ar = eigs(sparse_matrix; which=:SR, nev=num_eigvals)
vals_ar</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 -6.979863998321619
 -3.3631242916133606
 -0.7590191922770747</code></pre><p>Using KrylovKit&#39;s <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>eigsolve</code></a> is similar, but the <code>nev</code> and <code>which</code> are given as positional arguments. Note that KrylovKit may sometimes return more than <code>nev</code> eigenpairs if it happens to find them.</p><pre><code class="language-julia hljs">using KrylovKit

vals_kk, vecs_kk = eigsolve(sparse_matrix, num_eigvals, :SR)
vals_kk</code></pre><pre><code class="nohighlight hljs">14-element Vector{Float64}:
 -6.979863998321601
 -3.363124291613371
 -0.7590191922770853
  0.13584182219621077
  0.15789998694609508
  0.876711441178136
  1.530592997097317
  1.5835732611867481
  3.0728703303258706
  3.1256726539518365
  4.862107221562165
  6.260694850380596
  6.4026712111831126
  9.093371706203957</code></pre><p>Both solvers use variants of the <a href="https://en.wikipedia.org/wiki/Lanczos_algorithm">Lanczos algorithm</a> for Hermitian matrices and the <a href="https://en.wikipedia.org/wiki/Arnoldi_iteration">Arnoldi algorithm</a> for non-Hermitian ones. These may in some cases miss degenerate eigenpairs.</p><p>If diagonalisation takes too long, you can reduce the tolerance by setting the <code>tol</code> keyword argument to <code>eigs</code> or <code>eigsolve</code>. Using drastically lower tolerances than the default can still produce good results in practice. This, however, should be checked on a case-by-case basis.</p><h3 id="The-matrix-free-method"><a class="docs-heading-anchor" href="#The-matrix-free-method">The matrix-free method</a><a id="The-matrix-free-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-matrix-free-method" title="Permalink"></a></h3><p>KrylovKit&#39;s <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>eigsolve</code></a> function is implemented in a way that does not require the linear operator and vector to be Julia arrays. Rimu leverages this functionality, which allows diagonalising Hamiltonians without ever needing to construct the matrix - all matrix elements are generated on the fly.</p><p>While this method is by far the slowest of the ones discussed, it also uses drastically less memory. This allows us to diagonalise much larger Hamiltonians.</p><p>To use this method, you first need a starting vector. It&#39;s best to use <a href="../dictvectors.html#Rimu.DictVectors.PDVec"><code>PDVec</code></a> here as it leverages threading during the diagonalisation.</p><pre><code class="language-julia hljs">dvec = PDVec(add =&gt; 1.0)</code></pre><pre><code class="nohighlight hljs">1-element PDVec: style = IsDeterministic{Float64}()
  fs&quot;|0 0 4 0 0⟩&quot; =&gt; 1.0</code></pre><p>Then, pass that vector and the Hamiltonian to <a href="https://jutho.github.io/KrylovKit.jl/stable/man/eig/#KrylovKit.eigsolve"><code>eigsolve</code></a>.</p><pre><code class="language-julia hljs">vals_mf, vecs_mf = eigsolve(ham, dvec, num_eigvals, :SR; issymmetric=true)
vals_mf</code></pre><pre><code class="nohighlight hljs">10-element Vector{Float64}:
 -6.979863998321612
 -3.3631242916133406
 -0.7590191922770728
  0.1578999869460862
  0.8767114411781503
  1.5835732611867401
  3.125672653951839
  4.862107221562172
  6.402671211183112
  9.093371706203953</code></pre><p>Keep in mind that if an eigenvector is orthogonal to <code>dvec</code>, KrylovKit will miss it. Consider the following example:</p><pre><code class="language-julia hljs">eigsolve(ham, vecs_mf[2], num_eigvals, :SR, issymmetric=true)[1]</code></pre><pre><code class="nohighlight hljs">1-element Vector{Float64}:
 -3.3631242916133606</code></pre><h2 id="Reducing-matrix-size-with-symmetries"><a class="docs-heading-anchor" href="#Reducing-matrix-size-with-symmetries">Reducing matrix size with symmetries</a><a id="Reducing-matrix-size-with-symmetries-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-matrix-size-with-symmetries" title="Permalink"></a></h2><p>As these matrices tend to get large quickly, memory is usually the bottleneck.  There are currently two methods implemented to reduce the matrix size, <a href="../hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>ParitySymmetry</code></a> and <a href="../hamiltonians.html#Rimu.Hamiltonians.TimeReversalSymmetry"><code>TimeReversalSymmetry</code></a>. These symmetries work by performing a unitary transformation on the Hamiltonian which causes it to become block-diagonal. When building a matrix from a block-diagonal Hamiltonian, only the block that contains the starting address is constructed.</p><p>You should only use these where the relevant symmetries actually apply - no checks are performed to make sure they do. There is also currently no way of using both at the same time. Please consult the documentation for a more in-depth description of these options.</p><p>The Hamiltonian presented in this example is compatible with <a href="../hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>ParitySymmetry</code></a>. Let&#39;s see how the matrix size is reduced when applying it.</p><pre><code class="language-julia hljs">size(sparse(ham))</code></pre><pre><code class="nohighlight hljs">(14, 14)</code></pre><pre><code class="language-julia hljs">size(sparse(ParitySymmetry(ham)))</code></pre><pre><code class="nohighlight hljs">(10, 10)</code></pre><p>In this small example, the size reduction is modest, but for larger systems, you can expect to reduce the dimension of the matrix by about half.</p><pre><code class="language-julia hljs">all_eigs = eigvals(Matrix(ham))
even_eigs = eigvals(Matrix(ParitySymmetry(ham)))</code></pre><pre><code class="nohighlight hljs">10-element Vector{Float64}:
 -6.979863998321621
 -3.3631242916133637
 -0.759019192277076
  0.1578999869460802
  0.8767114411781437
  1.5835732611867417
  3.125672653951844
  4.862107221562179
  6.402671211183117
  9.093371706203957</code></pre><p>The eigenvalues of the transformed Hamiltonian are a subset of the full spectrum. To get the other half, we can pass the <code>even=false</code> keyword argument to <a href="../hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>ParitySymmetry</code></a>. When doing that, we need to make sure the starting address of the Hamiltonian is not symmetric under reversal:</p><pre><code class="language-julia hljs">add_odd = BoseFS(M, cld(M, 2) =&gt; N - 3, cld(M, 2) - 1 =&gt; 2, cld(M, 2) + 2 =&gt; 1)</code></pre><pre><code class="nohighlight hljs">BoseFS{4,5}(0, 2, 1, 0, 1)</code></pre><pre><code class="language-julia hljs">odd_eigs = eigvals(Matrix(ParitySymmetry(HubbardMom1D(add_odd); even=false)))</code></pre><pre><code class="nohighlight hljs">4-element Vector{Float64}:
 0.135841822196218
 1.530592997097328
 3.0728703303258613
 6.260694850380591</code></pre><p>Now, let&#39;s check that combining the two sets of eigenvalues indeed recovers the whole spectrum.</p><pre><code class="language-julia hljs">sort([even_eigs; odd_eigs]) ≈ all_eigs</code></pre><pre><code class="nohighlight hljs">true</code></pre><h2 id="Computing-observables"><a class="docs-heading-anchor" href="#Computing-observables">Computing observables</a><a id="Computing-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-observables" title="Permalink"></a></h2><p>Since building a matrix from an operator only builds the part that is reachable from the starting address, we need to use a different approach when computing observables.</p><p>To demonstrate this, we will use the <a href="../hamiltonians.html#Rimu.Hamiltonians.DensityMatrixDiagonal"><code>DensityMatrixDiagonal</code></a> operator, which in this case will give the momentum density.</p><p>The idea here is to construct a <a href="../dictvectors.html#Rimu.DictVectors.PDVec"><code>PDVec</code></a> from the computed eigenvector and use it directly with the operator.</p><pre><code class="language-julia hljs">dvec = PDVec(zip(bsr.basis, eigvecs(Matrix(ham))[:, 1]))</code></pre><pre><code class="nohighlight hljs">14-element PDVec: style = IsDeterministic{Float64}()
  fs&quot;|1 0 1 2 0⟩&quot; =&gt; -0.0214153
  fs&quot;|2 0 0 0 2⟩&quot; =&gt; -0.00237613
  fs&quot;|0 0 4 0 0⟩&quot; =&gt; -0.980348
  fs&quot;|0 0 0 3 1⟩&quot; =&gt; 0.00363555
  fs&quot;|2 1 1 0 0⟩&quot; =&gt; -0.0119687
  fs&quot;|1 0 2 0 1⟩&quot; =&gt; 0.0768085
  fs&quot;|1 3 0 0 0⟩&quot; =&gt; 0.00363555
  fs&quot;|0 1 2 1 0⟩&quot; =&gt; 0.177701
  fs&quot;|0 0 1 1 2⟩&quot; =&gt; -0.0119687
  fs&quot;|3 0 0 1 0⟩&quot; =&gt; 0.00195478
  fs&quot;|0 2 0 2 0⟩&quot; =&gt; -0.0138439
  fs&quot;|1 1 0 1 1⟩&quot; =&gt; -0.00234782
  fs&quot;|0 1 0 0 3⟩&quot; =&gt; 0.00195478
  fs&quot;|0 2 1 0 1⟩&quot; =&gt; -0.0214153</code></pre><p>The eigenvectors these methods produce are normalized, hence we can use the three-argument <code>dot</code> to compute the values of observables. Here we are computing the single particle momentum density distribution, which is just the diagonal of the single-particle density matrix in momentum space.</p><pre><code class="language-julia hljs">[dot(dvec, DensityMatrixDiagonal(i), dvec) for i in 1:M]</code></pre><pre><code class="nohighlight hljs">5-element Vector{Float64}:
 0.0066861389450877905
 0.033070399772041625
 3.9204869225657406
 0.03307039977204162
 0.006686138945087839</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="G2-example.html">« Calculating observables</a><a class="docs-footer-nextpage" href="HO-example.html">Degenerate perturbation theory in a harmonic oscillator basis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Sunday 5 May 2024 11:40">Sunday 5 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
