<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hamiltonians · Rimu.jl</title><meta name="title" content="Hamiltonians · Rimu.jl"/><meta property="og:title" content="Hamiltonians · Rimu.jl"/><meta property="twitter:title" content="Hamiltonians · Rimu.jl"/><meta name="description" content="Documentation for Rimu.jl."/><meta property="og:description" content="Documentation for Rimu.jl."/><meta property="twitter:description" content="Documentation for Rimu.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="Rimu.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Rimu.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Guide</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="generated/BHM-example.html">1D Bose-Hubbard Model</a></li><li><a class="tocitem" href="generated/BHM-example-mpi.html">Rimu with MPI</a></li><li><a class="tocitem" href="generated/G2-example.html">Calculating observables</a></li><li><a class="tocitem" href="generated/exact-example.html">Exact diagonalisation</a></li><li><a class="tocitem" href="generated/HO-example.html">Degenerate perturbation theory in a harmonic oscillator basis</a></li></ul></li><li><span class="tocitem">User documentation</span><ul><li><a class="tocitem" href="statstools.html">StatsTools</a></li><li><a class="tocitem" href="mpi.html">Using MPI</a></li></ul></li><li><span class="tocitem">Developer documentation</span><ul><li><a class="tocitem" href="interfaces.html">Interfaces</a></li><li class="is-active"><a class="tocitem" href="hamiltonians.html">Hamiltonians</a><ul class="internal"><li><a class="tocitem" href="#Usage-with-FCIQMC-and-exact-diagonalisation"><span>Usage with FCIQMC and exact diagonalisation</span></a></li><li><a class="tocitem" href="#Model-Hamiltonians"><span>Model Hamiltonians</span></a></li><li><a class="tocitem" href="#Hamiltonian-wrappers"><span>Hamiltonian wrappers</span></a></li><li><a class="tocitem" href="#Observables"><span>Observables</span></a></li><li><a class="tocitem" href="#Hamiltonians-interface"><span>Hamiltonians interface</span></a></li><li><a class="tocitem" href="#Geometry"><span>Geometry</span></a></li><li><a class="tocitem" href="#Harmonic-Oscillator"><span>Harmonic Oscillator</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="dictvectors.html">Dict vectors</a></li><li><a class="tocitem" href="addresses.html">BitString addresses</a></li><li><a class="tocitem" href="stochasticstyles.html">Stochastic styles</a></li><li><a class="tocitem" href="RMPI.html">RMPI</a></li><li><a class="tocitem" href="rimuio.html">I/O</a></li><li><a class="tocitem" href="randomnumbers.html">Random numbers</a></li><li><a class="tocitem" href="documentation.html">Documentation generation</a></li><li><a class="tocitem" href="testing.html">Code testing</a></li></ul></li><li><a class="tocitem" href="API.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer documentation</a></li><li class="is-active"><a href="hamiltonians.html">Hamiltonians</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hamiltonians.html">Hamiltonians</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/joachimbrand/Rimu.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/joachimbrand/Rimu.jl/blob/develop/docs/src/hamiltonians.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Module-Hamiltonians"><a class="docs-heading-anchor" href="#Module-Hamiltonians">Module <code>Hamiltonians</code></a><a id="Module-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Hamiltonians" title="Permalink"></a></h1><p>This module contains definitions of Hamiltonians, in particular specific physical models of interest. These are organised by means of an interface around the abstract type <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>, in the spirit of the <code>AbstractArray</code> interface as discussed in the <a href="https://docs.julialang.org/en/v1/manual/interfaces/">Julia Documentation</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians" href="#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">module Hamiltonians</code></pre><p>This module defines Hamiltonian types and functions for working with Hamiltonians.</p><p><strong><a href="hamiltonians.html#Model-Hamiltonians">Exported concrete Hamiltonian types</a></strong></p><p>Real space Hubbard models</p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>BoseHubbardReal1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul><p>Momentum space Hubbard models</p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></li></ul><p>Harmonic oscillator models</p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>HOCartesianContactInteractions</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>HOCartesianEnergyConservedPerDim</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianCentralImpurity"><code>HOCartesianCentralImpurity</code></a></li></ul><p>Other</p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.FroehlichPolaron"><code>FroehlichPolaron</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian"><code>MatrixHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Transcorrelated1D"><code>Transcorrelated1D</code></a></li></ul><p><strong><a href="hamiltonians.html#Hamiltonian-wrappers">Wrappers</a></strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.GutzwillerSampling"><code>GutzwillerSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.GuidingVectorSampling"><code>GuidingVectorSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>ParitySymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.TimeReversalSymmetry"><code>TimeReversalSymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Stoquastic"><code>Stoquastic</code></a></li></ul><p><strong><a href="hamiltonians.html#Observables">Observables</a></strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2MomCorrelator"><code>G2MomCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.DensityMatrixDiagonal"><code>DensityMatrixDiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Momentum"><code>Momentum</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AxialAngularMomentumHO"><code>AxialAngularMomentumHO</code></a></li></ul><p><strong><a href="hamiltonians.html#Hamiltonians-interface">Interface for working with Hamiltonians</a></strong></p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>: defined in the module <a href="API.html#Interfaces"><code>Interfaces</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/Hamiltonians.jl#L1-L47">source</a></section></article><h2 id="Usage-with-FCIQMC-and-exact-diagonalisation"><a class="docs-heading-anchor" href="#Usage-with-FCIQMC-and-exact-diagonalisation">Usage with FCIQMC and exact diagonalisation</a><a id="Usage-with-FCIQMC-and-exact-diagonalisation-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-with-FCIQMC-and-exact-diagonalisation" title="Permalink"></a></h2><p>In order to define a specific model Hamiltonian with relevant parameters for the model, instantiate the model like this in the input file:</p><pre><code class="language-julia-repl hljs">hubb = HubbardReal1D(BoseFS((1,2,0,3)); u=1.0, t=1.0)</code></pre><p>The Hamiltonian <code>hubb</code> is now ready to be used for FCIQMC in <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> and for exact diagonalisation with <a href="https://github.com/Jutho/KrylovKit.jl"><code>KrylovKit.jl</code></a> directly, or after transforming into a sparse matrix first with</p><pre><code class="language-julia-repl hljs">using SparseArrays
sh = sparse(hubb)</code></pre><p>or into a full matrix with</p><pre><code class="language-julia-repl hljs">using LinearAlgebra
fh = Matrix(hubb)</code></pre><p>This functionality relies on</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.BasisSetRep" href="#Rimu.Hamiltonians.BasisSetRep"><code>Rimu.Hamiltonians.BasisSetRep</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BasisSetRep(
    h::AbstractHamiltonian, addr=starting_address(h);
    sizelim=10^6, nnzs, cutoff, filter, sort=false, kwargs...
)
BasisSetRep(h::AbstractHamiltonian, addresses::AbstractVector; kwargs...)</code></pre><p>Eagerly construct the basis set representation of the operator <code>h</code> with all addresses reachable from <code>addr</code>. Instead of a single address, a vector of <code>addresses</code> can be passed.</p><p>An <code>ArgumentError</code> is thrown if <code>dimension(h) &gt; sizelim</code> in order to prevent memory overflow. Set <code>sizelim = Inf</code> in order to disable this behaviour.</p><p>Providing the number <code>nnzs</code> of expected calculated matrix elements and <code>col_hint</code> for the estimated number of nonzero off-diagonal matrix elements in each matrix column may improve performance.</p><p>Providing an energy cutoff will skip the columns and rows with diagonal elements greater than <code>cutoff</code>. Alternatively, an arbitrary <code>filter</code> function can be used instead. Addresses passed as arguments are not filtered. To generate the matrix truncated to the subspace spanned by the <code>addresses</code>, use <code>filter = Returns(false)</code>.</p><p>Setting <code>sort</code> to <code>true</code> will sort the matrix rows and columns. This is useful when the order of the columns matters, e.g. when comparing matrices. Any additional keyword arguments are passed on to <code>Base.sortperm</code>.</p><p><strong>Fields</strong></p><ul><li><code>sm</code>: sparse matrix representing <code>h</code> in the basis <code>basis</code></li><li><code>basis</code>: vector of addresses</li><li><code>h</code>: the Hamiltonian</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; h = HubbardReal1D(BoseFS(1,0,0));

julia&gt; bsr = BasisSetRep(h)
BasisSetRep(HubbardReal1D(BoseFS{1,3}(1, 0, 0); u=1.0, t=1.0)) with dimension 3 and 9 stored entries:3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 9 stored entries:
  0.0  -1.0  -1.0
 -1.0   0.0  -1.0
 -1.0  -1.0   0.0

julia&gt; BasisSetRep(h, bsr.basis[1:2]; filter = Returns(false)) # passing addresses and truncating
BasisSetRep(HubbardReal1D(BoseFS{1,3}(1, 0, 0); u=1.0, t=1.0)) with dimension 2 and 4 stored entries:2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
  0.0  -1.0
 -1.0   0.0</code></pre><pre><code class="language-julia-repl hljs">julia&gt; using LinearAlgebra; eigvals(Matrix(bsr)) # eigenvalues
3-element Vector{Float64}:
 -1.9999999999999996
  0.9999999999999997
  1.0000000000000002

julia&gt; ev = eigvecs(Matrix(bsr))[:,1] # ground state eigenvector
3-element Vector{Float64}:
 -0.5773502691896257
 -0.5773502691896255
 -0.5773502691896257

julia&gt; DVec(zip(bsr.basis,ev)) # ground state as DVec
DVec{BoseFS{1, 3, BitString{3, 1, UInt8}},Float64} with 3 entries, style = IsDeterministic{Float64}()
  fs&quot;|0 0 1⟩&quot; =&gt; -0.57735
  fs&quot;|0 1 0⟩&quot; =&gt; -0.57735
  fs&quot;|1 0 0⟩&quot; =&gt; -0.57735</code></pre><p>Has methods for <a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>dimension</code></a>, <a href="hamiltonians.html#SparseArrays.sparse"><code>sparse</code></a>, <a href="hamiltonians.html#Base.Matrix"><code>Matrix</code></a>, <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a>.</p><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface. See also <a href="hamiltonians.html#Rimu.Hamiltonians.build_basis"><code>build_basis</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L363-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SparseArrays.sparse" href="#SparseArrays.sparse"><code>SparseArrays.sparse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sparse(h::AbstractHamiltonian, addr=starting_address(h); kwargs...)
sparse(bsr::BasisSetRep)</code></pre><p>Return a sparse matrix representation of <code>h</code> or <code>bsr</code>. <code>kwargs</code> are passed to <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p><p>See <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L619-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.Matrix" href="#Base.Matrix"><code>Base.Matrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Matrix(h::AbstractHamiltonian, addr=starting_address(h); sizelim=10^4, kwargs...)
Matrix(bsr::BasisSetRep)</code></pre><p>Return a dense matrix representation of <code>h</code> or <code>bsr</code>. <code>kwargs</code> are passed to <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p><p>See <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L633-L641">source</a></section></article><p>If only the basis is required and not the matrix representation it is more efficient to use</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.build_basis" href="#Rimu.Hamiltonians.build_basis"><code>Rimu.Hamiltonians.build_basis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_basis(
    ham, address=starting_address(ham);
    cutoff, filter, sizelim, sort=false, kwargs...
) -&gt; basis
build_basis(ham, addresses::AbstractVector; kwargs...)</code></pre><p>Get all basis element of a linear operator <code>ham</code> that are reachable (via non-zero matrix elements) from the address <code>address</code>, returned as a vector. Instead of a single address, a vector of <code>addresses</code> can be passed. Does not return the matrix, for that purpose use <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p><p>Providing an energy cutoff will skip addresses with diagonal elements greater than <code>cutoff</code>. Alternatively, an arbitrary <code>filter</code> function can be used instead. Addresses passed as arguments are not filtered. A maximum basis size <code>sizelim</code> can be set which will throw an error if the expected dimension of <code>ham</code> is larger than <code>sizelim</code>. This may be useful when memory may be a concern. These options are disabled by default.</p><p>Setting <code>sort</code> to <code>true</code> will sort the basis. Any additional keyword arguments are passed on to <code>Base.sort!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L303-L324">source</a></section></article><h2 id="Model-Hamiltonians"><a class="docs-heading-anchor" href="#Model-Hamiltonians">Model Hamiltonians</a><a id="Model-Hamiltonians-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Hamiltonians" title="Permalink"></a></h2><p>Here is a list of fully implemented model Hamiltonians. There are several variants of the Hubbard model in real and momentum space, as well as some other models.</p><h3 id="Real-space-Hubbard-models"><a class="docs-heading-anchor" href="#Real-space-Hubbard-models">Real space Hubbard models</a><a id="Real-space-Hubbard-models-1"></a><a class="docs-heading-anchor-permalink" href="#Real-space-Hubbard-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardReal1D" href="#Rimu.Hamiltonians.HubbardReal1D"><code>Rimu.Hamiltonians.HubbardReal1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardReal1D(address; u=1.0, t=1.0)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in real space.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \frac{u}{2}\sum_i n_i (n_i-1)\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardReal1D.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.BoseHubbardReal1D2C" href="#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>Rimu.Hamiltonians.BoseHubbardReal1D2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseHubbardReal1D2C(address::BoseFS2C; ua=1.0, ub=1.0, ta=1.0, tb=1.0, v=1.0)</code></pre><p>Implements a two-component one-dimensional Bose Hubbard chain in real space.</p><p class="math-container">\[\hat{H} = \hat{H}_a + \hat{H}_b + V\sum_{i} n_{a_i}n_{b_i}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>ua</code>: the on-site interaction parameter parameter for Hamiltonian a.</li><li><code>ub</code>: the on-site interaction parameter parameter for Hamiltonian b.</li><li><code>ta</code>: the hopping strength for Hamiltonian a.</li><li><code>tb</code>: the hopping strength for Hamiltonian b.</li><li><code>v</code>: the inter-species interaction parameter V.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/BoseHubbardReal1D2C.jl#L1-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardReal1DEP" href="#Rimu.Hamiltonians.HubbardReal1DEP"><code>Rimu.Hamiltonians.HubbardReal1DEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardReal1DEP(address; u=1.0, t=1.0, v_ho=1.0)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in real space with external potential.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \sum_i ϵ_i n_i
+ \frac{u}{2}\sum_i n_i (n_i-1)\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li><li><code>v_ho</code>: strength of the external harmonic oscillator potential <span>$ϵ_i = v_{ho} i^2$</span>.</li></ul><p>The first index is <code>i=0</code> and the maximum of the potential occurs in the centre of the lattice.</p><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardReal1DEP.jl#L21-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardRealSpace" href="#Rimu.Hamiltonians.HubbardRealSpace"><code>Rimu.Hamiltonians.HubbardRealSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardRealSpace(address; geometry=PeriodicBoundaries(M,), t=ones(C), u=ones(C, C), v=zeros(C, D))</code></pre><p>Hubbard model in real space. Supports single or multi-component Fock state addresses (with <code>C</code> components) and various (rectangular) lattice geometries in <code>D</code> dimensions.</p><p class="math-container">\[  \hat{H} = -\sum_{\langle i,j\rangle,σ} t_σ a^†_{iσ} a_{jσ} +
  \frac{1}{2}\sum_{i,σ} u_{σσ} n_{iσ} (n_{iσ} - 1) +
  \sum_{i,σ≠τ}u_{στ} n_{iσ} n_{iτ}\]</p><p>If <code>v</code> is nonzero then this calculates <span>$\hat{H} + \hat{V}$</span> by adding the harmonic trapping potential</p><p class="math-container">\[    \hat{V} = \sum_{i,σ,d} v_{σd} x_{di}^2 n_{iσ}\]</p><p>where <span>$x_{di}$</span> is the distance of site <span>$i$</span> from the centre of the trap along dimension <span>$d$</span>.</p><p><strong>Address types</strong></p><ul><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS"><code>BoseFS</code></a>: Single-component Bose-Hubbard model.</li><li><a href="addresses.html#Rimu.BitStringAddresses.FermiFS"><code>FermiFS</code></a>: Single-component Fermi-Hubbard model.</li><li><a href="addresses.html#Rimu.BitStringAddresses.CompositeFS"><code>CompositeFS</code></a>: For multi-component models.</li></ul><p>Note that a single component of fermions cannot interact with itself. A warning is produced if <code>address</code>is incompatible with the interaction parameters <code>u</code>.</p><p><strong>Geometries</strong></p><p>Implemented <a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a>s for keyword <code>geometry</code></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul><p>Default is <code>geometry=PeriodicBoundaries(M,)</code>, i.e. a one-dimensional lattice with the number of sites <code>M</code> inferred from the number of modes in <code>address</code>.</p><p><strong>Other parameters</strong></p><ul><li><code>t</code>: the hopping strengths. Must be a vector of length <code>C</code>. The <code>i</code>-th element of the vector corresponds to the hopping strength of the <code>i</code>-th component.</li><li><code>u</code>: the on-site interaction parameters. Must be a symmetric matrix. <code>u[i, j]</code> corresponds to the interaction between the <code>i</code>-th and <code>j</code>-th component. <code>u[i, i]</code> corresponds to the interaction of a component with itself. Note that <code>u[i,i]</code> must be zero for fermionic components.</li><li><code>v</code>: the trap potential strengths. Must be a matrix of size <code>C × D</code>. <code>v[i,j]</code> is the strength of the trap for component <code>i</code> in the <code>j</code>th dimension.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardRealSpace.jl#L111-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.ExtendedHubbardReal1D" href="#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>Rimu.Hamiltonians.ExtendedHubbardReal1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ExtendedHubbardReal1D(address; u=1.0, v=1.0, t=1.0)</code></pre><p>Implements the extended Hubbard model on a one-dimensional chain in real space.</p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle} a_i^† a_j + \frac{u}{2}\sum_i n_i (n_i-1) + v \sum_{\langle i,j\rangle} n_i n_j\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address.</li><li><code>u</code>: on-site interaction parameter</li><li><code>v</code>: the next-neighbor interaction</li><li><code>t</code>: the hopping strength</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/ExtendedHubbardReal1D.jl#L1-L17">source</a></section></article><h3 id="Momentum-space-Hubbard-models"><a class="docs-heading-anchor" href="#Momentum-space-Hubbard-models">Momentum space Hubbard models</a><a id="Momentum-space-Hubbard-models-1"></a><a class="docs-heading-anchor-permalink" href="#Momentum-space-Hubbard-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardMom1D" href="#Rimu.Hamiltonians.HubbardMom1D"><code>Rimu.Hamiltonians.HubbardMom1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardMom1D(address; u=1.0, t=1.0, dispersion=hubbard_dispersion)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space.</p><p class="math-container">\[\hat{H} =  \sum_{k} ϵ_k n_k + \frac{u}{M}\sum_{kpqr} a^†_{r} a^†_{q} a_p a_k δ_{r+q,p+k}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li><li><code>dispersion</code>: defines <span>$ϵ_k =$</span><code>t*dispersion(k)</code><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>hubbard_dispersion</code></a>: <span>$ϵ_k = -2t \cos(k)$</span></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>continuum_dispersion</code></a>: <span>$ϵ_k = tk^2$</span></li></ul></li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>ExtendedHubbardReal1D</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardMom1D.jl#L17-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.BoseHubbardMom1D2C" href="#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>Rimu.Hamiltonians.BoseHubbardMom1D2C</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BoseHubbardMom1D2C(add::BoseFS2C; ua=1.0, ub=1.0, ta=1.0, tb=1.0, v=1.0, kwargs...)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space with a two-component Bose gas.</p><p class="math-container">\[\hat{H} = \hat{H}_a + \hat{H}_b + \frac{V}{M}\sum_{kpqr} b^†_{r} a^†_{q} b_p a_k δ_{r+q,p+k}\]</p><p><strong>Arguments</strong></p><ul><li><code>add</code>: the starting address.</li><li><code>ua</code>: the <code>u</code> parameter for Hamiltonian a.</li><li><code>ub</code>: the <code>u</code> parameter for Hamiltonian b.</li><li><code>ta</code>: the <code>t</code> parameter for Hamiltonian a.</li><li><code>tb</code>: the <code>t</code> parameter for Hamiltonian b.</li><li><code>v</code>: the inter-species interaction parameter V.</li></ul><p>Further keyword arguments are passed on to the constructor of <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>.</p><p><strong>See also</strong></p><ul><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS2C"><code>BoseFS2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>BoseHubbardReal1D2C</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/BoseHubbardMom1D2C.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HubbardMom1DEP" href="#Rimu.Hamiltonians.HubbardMom1DEP"><code>Rimu.Hamiltonians.HubbardMom1DEP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HubbardMom1DEP(address; u=1.0, t=1.0, v_ho=1.0, dispersion=hubbard_dispersion)</code></pre><p>Implements a one-dimensional Bose Hubbard chain in momentum space with harmonic external potential.</p><p class="math-container">\[Ĥ = \sum_{k} ϵ_k n_k + \frac{u}{M}\sum_{kpqr} a^†_{r} a^†_{q} a_p a_k δ_{r+q,p+k}
            + V̂_\mathrm{ho} ,\]</p><p>where</p><p class="math-container">\[\begin{aligned}
V̂_\mathrm{ho} &amp; = \frac{1}{M} \sum_{p,q}  \mathrm{DFT}[V_{ext}]_{p-q} \,
                    a^†_{p} a_q ,\\
V_\mathrm{ext}(x) &amp;= v_\mathrm{ho} \,x^2 ,
\end{aligned}\]</p><p>is an external harmonic potential in momentum space, <span>$\mathrm{DFT}[…]_k$</span> is a discrete Fourier transform performed by <code>fft()[k%M + 1]</code>, and <code>M == num_modes(address)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: the starting address, defines number of particles and sites.</li><li><code>u</code>: the interaction parameter.</li><li><code>t</code>: the hopping strength.</li><li><code>dispersion</code>: defines <span>$ϵ_k =$</span><code>t*dispersion(k)</code><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>hubbard_dispersion</code></a>: <span>$ϵ_k = -2t \cos(k)$</span></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>continuum_dispersion</code></a>: <span>$ϵ_k = tk^2$</span></li></ul></li><li><code>v_ho</code>: strength of the external harmonic oscillator potential <span>$v_\mathrm{ho}$</span>.</li></ul><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.Transcorrelated1D"><code>Transcorrelated1D</code></a>, <a href="API.html#Hamiltonians"><code>Hamiltonians</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardMom1DEP.jl#L33-L67">source</a></section></article><h3 id="Harmonic-oscillator-models"><a class="docs-heading-anchor" href="#Harmonic-oscillator-models">Harmonic oscillator models</a><a id="Harmonic-oscillator-models-1"></a><a class="docs-heading-anchor-permalink" href="#Harmonic-oscillator-models" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HOCartesianContactInteractions" href="#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>Rimu.Hamiltonians.HOCartesianContactInteractions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HOCartesianContactInteractions(addr; S, η, g = 1.0, interaction_only = false, block_by_level = true)</code></pre><p>Implements a bosonic harmonic oscillator in Cartesian basis with contact interactions </p><p class="math-container">\[\hat{H} = \sum_{i} \epsilon_\mathbf{i} n_\mathbf{i} + \frac{g}{2}\sum_\mathbf{ijkl} 
    V_\mathbf{ijkl} a^†_\mathbf{i} a^†_\mathbf{j} a_\mathbf{k} a_\mathbf{l}.\]</p><p>For a <span>$D$</span>-dimensional harmonic oscillator indices <span>$\mathbf{i}, \mathbf{j}, \ldots$</span> are <span>$D$</span>-tuples. The energy scale is defined by the first dimension i.e. <span>$\hbar \omega_x$</span>  so that single particle energies are </p><p class="math-container">\[    \frac{\epsilon_\mathbf{i}}{\hbar \omega_x} = (i_x + 1/2) + \eta_y (i_y+1/2) + \ldots.\]</p><p>The factors <span>$\eta_y, \ldots$</span> allow for anisotropic trapping geometries and are assumed to  be greater than <code>1</code> so that <span>$\omega_x$</span> is the smallest trapping frequency.</p><p>By default the offdiagonal elements due to the interactions are consistent with first-order  degenerate perturbation theory</p><p class="math-container">\[    V_{\mathbf{ijkl}} = \delta_{\epsilon_\mathbf{i} + \epsilon_\mathbf{j}}
        ^{\epsilon_\mathbf{k} + \epsilon_\mathbf{l}} 
        \prod_{d \in x, y,\ldots} \mathcal{I}(i_d,j_d,k_d,l_d),\]</p><p>where the <span>$\delta$</span> function indicates that the <em>total</em> noninteracting energy is conserved meaning all states with the same noninteracting energy are connected by this interaction and  the Hamiltonian blocks according to noninteracting energy levels. Setting <code>block_by_level = false</code> will disable this restriction and allow coupling between  basis states of any noninteracting energy level, leading to many more offdiagonals and  fewer but larger blocks (the blocks are still distinguished by parity of basis states). Alternatively, see <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>HOCartesianEnergyConservedPerDim</code></a> for a model with the stronger  restriction that conserves energy separately per spatial dimension. The integral <span>$\mathcal{I}(a,b,c,d)$</span> is of four one dimensional harmonic oscillator  basis functions, implemented in <a href="hamiltonians.html#Rimu.Hamiltonians.four_oscillator_integral_general"><code>four_oscillator_integral_general</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>addr</code>: the starting address, defines number of particles and total number of modes.</li><li><code>S</code>: Tuple of the number of levels in each dimension, including the groundstate. The    allowed couplings between states is defined by the aspect ratio of <code>S .- 1</code>. Defaults    to a 1D spectrum with number of levels matching modes of <code>addr</code>. Will be sorted to make    the first dimension the largest.</li><li><code>η</code>: Define a custom aspect ratio for the trapping potential strengths, instead of deriving   from <code>S .- 1</code>. This will only affect the single particle energy scale and not the    interactions. The values are always scaled relative to the first dimension, which sets    the energy scale of the system, <span>$\hbar\omega_x$</span>.</li><li><code>g</code>: the (isotropic) bare interaction parameter. The value of <code>g</code> is assumed    to be in trap units.</li><li><code>interaction_only</code>: if set to <code>true</code> then the noninteracting single-particle terms are    ignored. Useful if only energy shifts due to interactions are required.</li><li><code>block_by_level</code>: if set to false will allow the interactions to couple all states without    comparing their noninteracting energy.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>num_offdiagonals</code> is a bad estimate for this Hamiltonian. Take care when building  a matrix or using QMC methods. Use <a href="hamiltonians.html#Rimu.Hamiltonians.get_all_blocks"><code>get_all_blocks</code></a> first then pass option <code>col_hint = block_size</code> to <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a> to safely build the matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HOCartesianContactInteractions.jl#L103-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim" href="#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HOCartesianEnergyConservedPerDim(addr; S, η, g = 1.0, interaction_only = false)</code></pre><p>Implements a bosonic harmonic oscillator in Cartesian basis with contact interactions </p><p class="math-container">\[\hat{H} = \sum_{i} ϵ_i n_i + \frac{g}{2}\sum_{ijkl} V_{ijkl} a^†_i a^†_j a_k a_l,\]</p><p>with the additional restriction that the interactions only couple states with the same energy in each dimension separately. See <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>HOCartesianContactInteractions</code></a> for a model that  conserves total energy.</p><p>For a <span>$D$</span>-dimensional harmonic oscillator indices <span>$\mathbf{i}, \mathbf{j}, \ldots$</span>  are <span>$D$</span>-tuples. The energy scale is defined by the first dimension i.e. <span>$\hbar \omega_x$</span>  so that single particle energies are </p><p class="math-container">\[    \frac{\epsilon_\mathbf{i}}{\hbar \omega_x} = (i_x + 1/2) + \eta_y (i_y+1/2) + \ldots.\]</p><p>The factors <span>$\eta_y, \ldots$</span> allow for anisotropic trapping geometries and are assumed to  be greater than <code>1</code> so that <span>$\omega_x$</span> is the smallest trapping frequency.</p><p>Matrix elements <span>$V_{\mathbf{ijkl}}$</span> are for a contact interaction calculated in this basis using  first-order degenerate perturbation theory.</p><p class="math-container">\[    V_{\mathbf{ijkl}} = \prod_{d \in x, y,\ldots} \mathcal{I}(i_d,j_d,k_d,l_d) 
        \delta_{i_d + j_d}^{k_d + l_d},\]</p><p>where the <span>$\delta$</span>-function indicates that the noninteracting energy is conserved along each dimension. The integral <span>$\mathcal{I}(a,b,c,d)$</span> is of four one dimensional harmonic oscillator  basis functions, see <a href="hamiltonians.html#Rimu.Hamiltonians.four_oscillator_integral_general"><code>four_oscillator_integral_general</code></a>, with the additional restriction  that energy is conserved in each dimension.</p><p><strong>Arguments</strong></p><ul><li><code>addr</code>: the starting address, defines number of particles and total number of modes.</li><li><code>S</code>: Tuple of the number of levels in each dimension, including the groundstate. Defaults    to a 1D spectrum with number of levels matching modes of <code>addr</code>. Will be sorted to    make the first dimension the largest.</li><li><code>η</code>: Define a custom aspect ratio for the trapping potential strengths, instead of deriving   from <code>S .- 1</code>. The values are always scaled relative to the first dimension, which sets    the energy scale of the system, <span>$\hbar\omega_x$</span>.</li><li><code>g</code>: the (isotropic) interparticle interaction parameter. The value of <code>g</code> is assumed    to be in trap units.</li><li><code>interaction_only</code>: if set to <code>true</code> then the noninteracting single-particle terms are    ignored. Useful if only energy shifts due to interactions are required.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HOCartesianEnergyConservedPerDim.jl#L55-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HOCartesianCentralImpurity" href="#Rimu.Hamiltonians.HOCartesianCentralImpurity"><code>Rimu.Hamiltonians.HOCartesianCentralImpurity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HOCartesianCentralImpurity(addr; kwargs...)</code></pre><p>Hamiltonian of non-interacting particles in an arbitrary harmonic trap with a delta-function  potential at the centre, with strength <code>g</code>,</p><p class="math-container">\[\hat{H}_\mathrm{rel} = \sum_\mathbf{i} ϵ_\mathbf{i} n_\mathbf{i} 
    + g\sum_\mathbf{ij} V_\mathbf{ij} a^†_\mathbf{i} a_\mathbf{j}.\]</p><p>For a <span>$D$</span>-dimensional harmonic oscillator indices <span>$\mathbf{i}, \mathbf{j}, \ldots$</span>  are <span>$D$</span>-tuples. The energy scale is defined by the first dimension i.e. <span>$\hbar \omega_x$</span>  so that single particle energies are </p><p class="math-container">\[    \frac{\epsilon_\mathbf{i}}{\hbar \omega_x} = (i_x + 1/2) + \eta_y (i_y+1/2) + \ldots.\]</p><p>The factors <span>$\eta_y, \ldots$</span> allow for anisotropic trapping geometries and are assumed to  be greater than <code>1</code> so that <span>$\omega_x$</span> is the smallest trapping frequency.</p><p>Matrix elements <span>$V_{\mathbf{ij}}$</span> are for a delta function potential calculated in this basis</p><p class="math-container">\[    V_{\mathbf{ij}} = \prod_{d \in x, y,\ldots} \psi_{i_d}(0) \psi_{j_d}(0).\]</p><p>Only even parity states feel this impurity, so all <span>$i_d$</span> are even. Note that the matrix  representation of this Hamiltonian for a single particle is completely dense in the even-parity  subspace.</p><p><strong>Arguments</strong></p><ul><li><code>addr</code>: the starting address, defines number of particles and total number of modes.</li><li><code>max_nx = num_modes(addr) - 1</code>: the maximum harmonic oscillator index number in the <span>$x$</span>-dimension.   Must be even. Index number for the harmonic oscillator groundstate is <code>0</code>.</li><li><code>ηs = ()</code>: a tuple of aspect ratios for the remaining dimensions <code>(η_y, ...)</code>. Should be empty    for a 1D trap or contain values greater than <code>1.0</code>. The maximum index    in other dimensions will be the largest even number less than <code>M/η_y</code>.</li><li><code>S = nothing</code>: Instead of <code>max_nx</code>, manually set the number of levels in each dimension,    including the groundstate. Must be a <code>Tuple</code> of <code>Int</code>s.</li><li><code>g = 1.0</code>: the strength of the delta impurity in (<span>$x$</span>-dimension) trap units.</li><li><code>impurity_only=false</code>: if set to <code>true</code> then the trap energy terms are ignored. Useful if    only energy shifts due to the impurity are required.</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><pre><code class="nohighlight hljs">Due to use of `SpecialFunctions` with large arguments the matrix representation of 
this Hamiltonian may not be strictly symmetric, but is approximately symmetric within
machine precision.</code></pre></div></div><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>HOCartesianContactInteractions</code></a> and<a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>HOCartesianEnergyConservedPerDim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HOCartesianCentralImpurity.jl#L47-L93">source</a></section></article><h3 id="Other"><a class="docs-heading-anchor" href="#Other">Other</a><a id="Other-1"></a><a class="docs-heading-anchor-permalink" href="#Other" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.MatrixHamiltonian" href="#Rimu.Hamiltonians.MatrixHamiltonian"><code>Rimu.Hamiltonians.MatrixHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixHamiltonian(
    mat::AbstractMatrix{T};
    starting_address::Int = starting_address(mat)
) &lt;: AbstractHamiltonian{T}</code></pre><p>Wrap an abstract matrix <code>mat</code> as an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> object. Works with stochastic methods of <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!()</code></a> and <a href="dictvectors.html#Rimu.DictVectors.DVec"><code>DVec</code></a>. Optionally, a valid index can be provided as the <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a>.</p><p>Specialised methods are implemented for sparse matrices of type <code>AbstractSparseMatrixCSC</code>. One based indexing is required for the matrix <code>mat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/MatrixHamiltonian.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.Transcorrelated1D" href="#Rimu.Hamiltonians.Transcorrelated1D"><code>Rimu.Hamiltonians.Transcorrelated1D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Transcorrelated1D(address; t=1.0, v=1.0, v_ho=0.0, cutoff=1, three_body_term=true)</code></pre><p>Implements a transcorrelated Hamiltonian for contact interactions in one dimensional momentum space from <a href="http://arxiv.org/abs/1806.11268">Jeszenski <em>et al.</em> (2018)</a>. Currently limited to two component fermionic addresses.</p><p class="math-container">\[\begin{aligned}

\tilde{H} &amp;= t \sum_{kσ}k^2 n_{k,σ} \\
    &amp;\quad + \sum_{pqkσσ&#39;} T_{pqk} a^†_{p-k,σ} a^†_{q+k,σ&#39;} a_{q,σ&#39;} a_{p,σ} \\
    &amp;\quad + \sum_{pqskk&#39;σσ&#39;} Q_{kk&#39;}a^†_{p-k,σ} a^†_{q+k,σ} a^†_{s+k-k&#39;,σ&#39;}
                                       a_{s,σ&#39;} a_{q,σ} a_{p,σ} \\
    &amp;\quad + V̂_\mathrm{ho}
\end{aligned}\]</p><p>where</p><p class="math-container">\[\begin{aligned}
\tilde{u}(k) &amp;= \begin{cases} -\frac{2}{k^2} &amp;\mathrm{if\ } |k| ≥ k_c\\
0 &amp; \mathrm{otherwise}
\end{cases}
\\

T_{pqk} &amp;= \frac{v}{M} + \frac{2v}{M}\left[k^2\tilde{u}(k)
          - (p - q)k\tilde{u}(k)\right] + \frac{2v^2}{t}W(k)\\
W(k) &amp;= \frac{1}{M^2}\sum_{q} (k - q)q\, \tilde{u}(q)\,\tilde{u}(k - q) \\
Q_{kl} &amp;= -\frac{v^2}{t M^2}k \tilde{u}(k)\,l\tilde{u}(l),
\end{aligned}\]</p><p><strong>Arguments</strong></p><ul><li><code>address</code>: The starting address, defines number of particles and sites.</li><li><code>v</code>: The interaction parameter.</li><li><code>t</code>: The kinetic energy prefactor.</li><li><code>v_ho</code>: Strength of the external harmonic oscillator potential <span>$V̂_\mathrm{ho}$</span>. See <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a>.</li><li><code>cutoff</code> controls <span>$k_c$</span> in equations above. Note: skipping generating off-diagonal elements below the cutoff is not implemented - zero-valued elements are returned instead.</li><li><code>three_body_term</code>: If set to false, generating three body excitations is skipped. Note: when disabling three body terms, cutoff should be set to a higher value for best results.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/Transcorrelated1D.jl#L2-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.FroehlichPolaron" href="#Rimu.Hamiltonians.FroehlichPolaron"><code>Rimu.Hamiltonians.FroehlichPolaron</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FroehlichPolaron(address::OccupationNumberFS{M}; kwargs...) &lt;: AbstractHamiltonian</code></pre><p>The Froehlich polaron Hamiltonian for a 1D lattice with <code>M</code> momentum modes is given by</p><p class="math-container">\[H = (p̂_f - p)^2/m + ωN̂ - v Σₖ(âₖ^† + â₋ₖ)\]</p><p>where <span>$p$</span> is the total momentum, <span>$p̂_f = Σ_k k âₖ^† âₖ$</span> is the momentum operator for the bosons, and <span>$k$</span> part of the momentum lattice with separation <span>$2π/l$</span>. <span>$N̂$</span> is the number operator for the bosons.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>p=0.0</code>: the total momentum <span>$p$</span>.</li><li><code>v=1.0</code>: the coupling strength <span>$v$</span>.</li><li><code>mass=1.0</code>: the particle mass <span>$m$</span>.</li><li><code>omega=1.0</code>: the oscillation frequency of the phonons <span>$ω$</span>.</li><li><code>l=1.0</code>: the box size in real space <span>$l$</span>. Provides scale parameter of the momentum   lattice.</li><li><code>momentum_cutoff=nothing</code>: the maximum boson momentum allowed for an address.</li><li><code>mode_cutoff</code>: the maximum number of bosons in each momentum mode. Defaults to the maximum   value supported by the address type <a href="addresses.html#Rimu.BitStringAddresses.OccupationNumberFS"><code>OccupationNumberFS</code></a>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; fs = OccupationNumberFS(0,0,0)
OccupationNumberFS{3, UInt8}(0, 0, 0)

julia&gt; ham = FroehlichPolaron(fs; v=0.5)
FroehlichPolaron(fs&quot;|0 0 0⟩{8}&quot;; v=0.5, mass=1.0, omega=1.0, l=1.0, p=0.0, mode_cutoff=255)

julia&gt; dimension(ham)
16777216

julia&gt; dimension(FroehlichPolaron(fs; v=0.5, mode_cutoff=5))
216</code></pre><p>See also <a href="addresses.html#Rimu.BitStringAddresses.OccupationNumberFS"><code>OccupationNumberFS</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>dimension</code></a>, <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/FroehlichPolaron.jl#L1-L44">source</a></section></article><h3 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.rayleigh_quotient" href="#Rimu.Hamiltonians.rayleigh_quotient"><code>Rimu.Hamiltonians.rayleigh_quotient</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rayleigh_quotient(H, v)</code></pre><p>Return the Rayleigh quotient of the linear operator <code>H</code> and the vector <code>v</code>:</p><p class="math-container">\[\frac{⟨ v | H | v ⟩}{⟨ v|v ⟩}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L145-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.momentum" href="#Rimu.Hamiltonians.momentum"><code>Rimu.Hamiltonians.momentum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">momentum(ham::AbstractHamiltonian)</code></pre><p>Momentum as a linear operator in Fock space. Pass a Hamiltonian <code>ham</code> in order to convey information about the Fock basis. Returns an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> that represents the momentum operator.</p><p>Note: <code>momentum</code> is currently only defined on <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; add = BoseFS((1, 0, 2, 1, 2, 1, 1, 3));


julia&gt; ham = HubbardMom1D(add; u = 2.0, t = 1.0);


julia&gt; mom = momentum(ham);


julia&gt; diagonal_element(mom, add) # calculate the momentum of a single configuration
-1.5707963267948966

julia&gt; v = DVec(add =&gt; 10; capacity=1000);


julia&gt; rayleigh_quotient(mom, v) # momentum expectation value for state vector `v`
-1.5707963267948966</code></pre><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L175-L206">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.hubbard_dispersion" href="#Rimu.Hamiltonians.hubbard_dispersion"><code>Rimu.Hamiltonians.hubbard_dispersion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hubbard_dispersion(k)</code></pre><p>Dispersion relation for <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>. Returns <code>-2cos(k)</code>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>continuum_dispersion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardMom1D.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.continuum_dispersion" href="#Rimu.Hamiltonians.continuum_dispersion"><code>Rimu.Hamiltonians.continuum_dispersion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">continuum_dispersion(k)</code></pre><p>Dispersion relation for <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>HubbardMom1D</code></a>. Returns <code>k^2</code>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>hubbard_dispersion</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardMom1D.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.shift_lattice" href="#Rimu.Hamiltonians.shift_lattice"><code>Rimu.Hamiltonians.shift_lattice</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift_lattice(is)</code></pre><p>Circular shift contiguous indices <code>is</code> in interval <code>[M÷2, M÷2)</code> such that set starts with 0, where <code>M=length(is)</code>.</p><p>Inverse operation: <a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice_inv"><code>shift_lattice_inv</code></a>. Used in <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardReal1DEP.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.shift_lattice_inv" href="#Rimu.Hamiltonians.shift_lattice_inv"><code>Rimu.Hamiltonians.shift_lattice_inv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift_lattice_inv(js)</code></pre><p>Circular shift indices starting with 0 into a contiguous set in interval <code>[M÷2, M÷2)</code>, where <code>M=length(js)</code>.</p><p>Inverse operation of <a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice"><code>shift_lattice</code></a>. Used in <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>HubbardReal1DEP</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>HubbardMom1DEP</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HubbardReal1DEP.jl#L11-L18">source</a></section></article><h2 id="Hamiltonian-wrappers"><a class="docs-heading-anchor" href="#Hamiltonian-wrappers">Hamiltonian wrappers</a><a id="Hamiltonian-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-wrappers" title="Permalink"></a></h2><p>The following Hamiltonians are constructed from an existing Hamiltonian instance and change its behaviour:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.GutzwillerSampling" href="#Rimu.Hamiltonians.GutzwillerSampling"><code>Rimu.Hamiltonians.GutzwillerSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GutzwillerSampling(::AbstractHamiltonian; g)</code></pre><p>Wrapper over any <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> that implements Gutzwiller sampling. In this importance sampling scheme the Hamiltonian is modified as follows</p><p class="math-container">\[\tilde{H}_{ij} = H_{ij} e^{-g(H_{ii} - H_{jj})} .\]</p><p>This way off-diagonal spawns to higher-energy configurations are discouraged and spawns to lower-energy configurations encouraged for positive <code>g</code>.</p><p><strong>Constructor</strong></p><ul><li><code>GutzwillerSampling(::AbstractHamiltonian, g)</code></li><li><code>GutzwillerSampling(::AbstractHamiltonian; g)</code></li></ul><p>After construction, we can access the underlying Hamiltonian with <code>G.hamiltonian</code> and the <code>g</code> parameter with <code>G.g</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H = HubbardMom1D(BoseFS(1,1,1); u=6.0, t=1.0)
HubbardMom1D(BoseFS{3,3}(1, 1, 1); u=6.0, t=1.0)

julia&gt; G = GutzwillerSampling(H, g=0.3)
GutzwillerSampling(HubbardMom1D(BoseFS{3,3}(1, 1, 1); u=6.0, t=1.0); g=0.3)

julia&gt; get_offdiagonal(H, BoseFS(2, 1, 0), 1)
(BoseFS{3,3}(1, 0, 2), 2.0)

julia&gt; get_offdiagonal(G, BoseFS(2, 1, 0), 1)
(BoseFS{3,3}(1, 0, 2), 0.8131393194811987)</code></pre><p><strong>Observables</strong></p><p>To calculate observables, pass the transformed Hamiltonian <code>G</code> to <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a> with keyword argument <code>transform=G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/GutzwillerSampling.jl#L1-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.GuidingVectorSampling" href="#Rimu.Hamiltonians.GuidingVectorSampling"><code>Rimu.Hamiltonians.GuidingVectorSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GuidingVectorSampling</code></pre><p>Wrapper over any <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> that implements guided vector a.k.a. guided wave function sampling. In this importance sampling scheme the Hamiltonian is modified as follows.</p><p class="math-container">\[\tilde{H}_{ij} = v_i H_{ij} v_j^{-1}\]</p><p>and where <code>v</code> is the guiding vector. <code>v_i</code> and <code>v_j</code> are also thresholded to avoid dividing by zero (see below).</p><p><strong>Constructors</strong></p><ul><li><code>GuidingVectorSampling(::AbstractHamiltonian, vector, eps)</code></li><li><code>GuidingVectorSampling(::AbstractHamiltonian; vector, eps)</code></li></ul><p><code>eps</code> is a thresholding parameter used to avoid dividing by zero; all values below <code>eps</code> are set to <code>eps</code>. It is recommended that <code>eps</code> is in the same value range as the guiding vector. The default value is set to <code>eps=norm(v, Inf) * 1e-2</code></p><p>After construction, we can access the underlying hamiltonian with <code>G.hamiltonian</code>, the <code>eps</code> parameter with <code>G.eps</code>, and the guiding vector with <code>G.vector</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H = HubbardReal1D(BoseFS(1,1,1); u=6.0, t=1.0);

julia&gt; v = DVec(starting_address(H) =&gt; 10; capacity=1);

julia&gt; G = GuidingVectorSampling(H, v, 0.1);

julia&gt; get_offdiagonal(H, starting_address(H), 4)
(BoseFS{3,3}(2, 0, 1), -1.4142135623730951)

julia&gt; get_offdiagonal(G, starting_address(G), 4)
(BoseFS{3,3}(2, 0, 1), -0.014142135623730952)</code></pre><p><strong>Observables</strong></p><p>To calculate observables, pass the transformed Hamiltonian <code>G</code> to <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a> with keyword argument <code>transform=G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/GuidingVectorSampling.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.ParitySymmetry" href="#Rimu.Hamiltonians.ParitySymmetry"><code>Rimu.Hamiltonians.ParitySymmetry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParitySymmetry(ham::AbstractHamiltonian{T}; even=true) &lt;: AbstractHamiltonian{T}</code></pre><p>Impose even or odd parity on all states and the Hamiltonian <code>ham</code> as controlled by the keyword argument <code>even</code>. Parity symmetry of the Hamiltonian is assumed. For some Hamiltonians, <code>ParitySymmetry</code> reduces the size of the Hilbert space by half.</p><p><code>ParitySymmetry</code> performs a unitary transformation, leaving the eigenvalues unchanged and preserving the <a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>LOStructure</code></a>. This is achieved by changing the basis set to states with defined parity. Effectively, a non-even address <span>$|α⟩$</span> is replaced by <span>$\frac{1}{√2}(|α⟩ ± |ᾱ⟩)$</span> for even and odd parity, respectively, where <code>ᾱ == reverse(α)</code>.</p><p><strong>Notes</strong></p><ul><li>This modifier currently only works on <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a>s with an odd number of modes.</li><li>For odd parity, the <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a> of the underlying Hamiltonian cannot be symmetric.</li><li>If parity is not a symmetry of the Hamiltonian <code>ham</code> then the result is undefined.</li><li><code>ParitySymmetry</code> works by modifying the <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a> iterator.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; ham = HubbardReal1D(BoseFS(0,2,1))
HubbardReal1D(BoseFS{3,3}(0, 2, 1); u=1.0, t=1.0)

julia&gt; size(Matrix(ham))
(10, 10)

julia&gt; size(Matrix(ParitySymmetry(ham)))
(6, 6)

julia&gt; size(Matrix(ParitySymmetry(ham; odd=true)))
(4, 4)

julia&gt; eigvals(Matrix(ham))[1] ≈ eigvals(Matrix(ParitySymmetry(ham)))[1]
true</code></pre><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.TimeReversalSymmetry"><code>TimeReversalSymmetry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/ParitySymmetry.jl#L1-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.TimeReversalSymmetry" href="#Rimu.Hamiltonians.TimeReversalSymmetry"><code>Rimu.Hamiltonians.TimeReversalSymmetry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeReversalSymmetry(ham::AbstractHamiltonian{T}; even=true) &lt;: AbstractHamiltonian{T}</code></pre><p>Impose even or odd time reversal on all states and the Hamiltonian <code>ham</code> as controlled by the keyword argument <code>even</code>. If time reversal is a symmetry of the Hamiltonian it will block (reducing Hilbert space dimension) preserving the eigenvalues and <a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>LOStructure</code></a>.</p><p><strong>Notes</strong></p><ul><li>This modifier only works two component <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a>es.</li><li>For odd time reversal symmetry, the <a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address</code></a> of the underlying Hamiltonian must not be symmetric.</li><li>If time reversal is not a symmetry of the Hamiltonian <code>ham</code> then the result is undefined.</li><li><code>TimeReversalSymmetry</code> works by modifying the <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a> iterator.</li></ul><pre><code class="language-julia-repl hljs">julia&gt; ham = HubbardMom1D(FermiFS2C((1,0,1),(0,1,1)));

julia&gt; size(Matrix(ham))
(3, 3)

julia&gt; size(Matrix(TimeReversalSymmetry(ham)))
(2, 2)

julia&gt; size(Matrix(TimeReversalSymmetry(ham, even=false)))
(1, 1)

julia&gt; eigvals(Matrix(TimeReversalSymmetry(ham)))[1] ≈ eigvals(Matrix(ham))[1]
true</code></pre><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>ParitySymmetry</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/TRSymmetry.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.Stoquastic" href="#Rimu.Hamiltonians.Stoquastic"><code>Rimu.Hamiltonians.Stoquastic</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stoquastic(ham &lt;: AbstractHamiltonian) &lt;: AbstractHamiltonian</code></pre><p>A wrapper for an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> that replaces all off-diagonal matrix elements <code>v</code> by <code>-abs(v)</code>, thus making the new Hamiltonian <em>stoquastic</em>.</p><p>A stoquastic Hamiltonian does not have a Monte Carlo sign problem. For a hermitian <code>ham</code> the smallest eigenvalue of <code>Stoquastic(ham)</code> is ≤ the smallest eigenvalue of <code>ham</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/Stoquastic.jl#L1-L8">source</a></section></article><h2 id="Observables"><a class="docs-heading-anchor" href="#Observables">Observables</a><a id="Observables-1"></a><a class="docs-heading-anchor-permalink" href="#Observables" title="Permalink"></a></h2><p>Observables are <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>s that represent a physical observable. Their ground state expectation values can be sampled by passing them into <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.G2MomCorrelator" href="#Rimu.Hamiltonians.G2MomCorrelator"><code>Rimu.Hamiltonians.G2MomCorrelator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">G2MomCorrelator(d::Int,c=:cross) &lt;: AbstractHamiltonian{ComplexF64}</code></pre><p>Two-body correlation operator representing the density-density correlation at distance <code>d</code> of a two component system in a momentum-space Fock-state basis. It returns a <code>Complex</code> value.</p><p>Correlation across two components:</p><p class="math-container">\[\hat{G}^{(2)}(d) = \frac{1}{M}\sum_{spqr=1}^M e^{-id(p-q)2π/M} a^†_{s} b^†_{p}  b_q a_r δ_{s+p,q+r}\]</p><p>Correlation within a single component:</p><p class="math-container">\[\hat{G}^{(2)}(d) = \frac{1}{M}\sum_{spqr=1}^M e^{-id(p-q)2π/M} a^†_{s} a^†_{p}  a_q a_r δ_{s+p,q+r}\]</p><p>The diagonal element, where <code>(p-q)=0</code>, is</p><p class="math-container">\[\frac{1}{M}\sum_{k,p=1}^M a^†_{k} b^†_{p}  b_p a_k .\]</p><p><strong>Arguments</strong></p><ul><li><code>d::Integer</code>: the distance between two particles.</li><li><code>c</code>: possible instructions: <code>:cross</code>: default instruction, computing correlation between particles across two components; <code>:first</code>: computing correlation between particles within the first component; <code>:second</code>: computing correlation between particles within the second component. These are the only defined instructions, using anything else will produce errors.</li></ul><p><strong>To use on a one-component system</strong></p><p>For a system with only one component, e.g. with <code>BoseFS</code>, the second argument <code>c</code> is irrelevant and can be any of the above instructions, one could simply skip this argument and let it be the default value.</p><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>BoseHubbardMom1D2C</code></a></li><li><a href="addresses.html#Rimu.BitStringAddresses.BoseFS2C"><code>BoseFS2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a></li><li><a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/correlation_functions.jl#L87-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.G2RealCorrelator" href="#Rimu.Hamiltonians.G2RealCorrelator"><code>Rimu.Hamiltonians.G2RealCorrelator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">G2RealCorrelator(d::Int) &lt;: AbstractHamiltonian{Float64}</code></pre><p>Two-body operator for density-density correlation between sites separated by <code>d</code> with <code>0 ≤ d &lt; M</code>.</p><p class="math-container">\[    \hat{G}^{(2)}(d) = \frac{1}{M} \sum_i^M \hat{n}_i (\hat{n}_{i+d} - \delta_{0d}).\]</p><p>Assumes a one-dimensional lattice with periodic boundary conditions where</p><p class="math-container">\[    \hat{G}^{(2)}(-M/2 \leq d &lt; 0) = \hat{G}^{(2)}(|d|),\]</p><p class="math-container">\[    \hat{G}^{(2)}(M/2 &lt; d &lt; M) = \hat{G}^{(2)}(M - d),\]</p><p>and normalisation</p><p class="math-container">\[    \sum_{d=0}^{M-1} \langle \hat{G}^{(2)}(d) \rangle = \frac{N (N-1)}{M}.\]</p><p>For multicomponent basis, calculates correlations between all particles equally, equivalent to stacking all components into a single Fock state.</p><p><strong>Arguments</strong></p><ul><li><code>d::Integer</code>: distance between sites.</li></ul><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2MomCorrelator"><code>G2MomCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a></li><li><a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/correlation_functions.jl#L2-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.SuperfluidCorrelator" href="#Rimu.Hamiltonians.SuperfluidCorrelator"><code>Rimu.Hamiltonians.SuperfluidCorrelator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SuperfluidCorrelator(d::Int) &lt;: AbstractHamiltonian{Float64}</code></pre><p>Operator for extracting superfluid correlation between sites separated by a distance <code>d</code> with <code>0 ≤ d &lt; M</code>:</p><p class="math-container">\[    \hat{C}_{\text{SF}}(d) = \frac{1}{M} \sum_{i}^{M} a_{i}^{\dagger} a_{i + d}\]</p><p>Assumes a one-dimensional lattice with <span>$M$</span> sites and periodic boundary conditions. <span>$M$</span> is also the number of modes in the Fock state address.</p><p><strong>Usage</strong></p><p>Superfluid correlations can be extracted from a Monte Carlo calculation by wrapping <code>SuperfluidCorrelator</code> with  <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a> and passing into <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a> with the <code>replica</code> keyword argument. For an example with a similar use of <a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a> see  <a href="https://joachimbrand.github.io/Rimu.jl/previews/PR227/generated/G2-example.html">G2 Correlator Example</a>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a>, <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>, and <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/correlation_functions.jl#L243-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.StringCorrelator" href="#Rimu.Hamiltonians.StringCorrelator"><code>Rimu.Hamiltonians.StringCorrelator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StringCorrelator(d::Int) &lt;: AbstractHamiltonian{Float64}</code></pre><p>Operator for extracting string correlation between lattice sites on a one-dimensional Hubbard lattice  separated by a distance <code>d</code> with <code>0 ≤ d &lt; M</code></p><p class="math-container">\[    \hat{C}_{\text{string}}(d) = \frac{1}{M} \sum_{j}^{M} \delta n_j (e^{i \pi \sum_{j \leq k &lt; j + d} \delta n_k}) \delta n_{j+d}\]</p><p>Here, <span>$\delta \hat{n}_j = \hat{n}_j - \bar{n}$</span> is the boson number deviation from the mean filling  number and <span>$\bar{n} = N/M$</span> is the mean filling number of lattice sites with <span>$N$</span> particles and  <span>$M$</span> lattice sites (or modes). </p><p>Assumes a one-dimensional lattice with periodic boundary conditions. For usage see <a href="hamiltonians.html#Rimu.Hamiltonians.SuperfluidCorrelator"><code>SuperfluidCorrelator</code></a> and <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>HubbardReal1D</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>G2RealCorrelator</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.SuperfluidCorrelator"><code>SuperfluidCorrelator</code></a>, <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>, and <a href="API.html#Rimu.AllOverlaps"><code>AllOverlaps</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/correlation_functions.jl#L291-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.DensityMatrixDiagonal" href="#Rimu.Hamiltonians.DensityMatrixDiagonal"><code>Rimu.Hamiltonians.DensityMatrixDiagonal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DensityMatrixDiagonal(mode; component=0) &lt;: AbstractHamiltonian</code></pre><p>Represent a diagonal element of the single-particle density:</p><p class="math-container">\[\hat{n}_{i,σ} = \hat a^†_{i,σ} \hat a_{i,σ}\]</p><p>where <span>$i$</span> is the <code>mode</code> and <span>$σ$</span> is the <code>component</code>. If <code>component</code> is zero, the sum over all components is computed.</p><p><strong>See also</strong></p><ul><li><a href="API.html#Rimu.single_particle_density-Tuple{Any}"><code>single_particle_density</code></a></li><li><a href="API.html#Rimu.SingleParticleDensity"><code>SingleParticleDensity</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/DensityMatrixDiagonal.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.Momentum" href="#Rimu.Hamiltonians.Momentum"><code>Rimu.Hamiltonians.Momentum</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Momentum(component=0; fold=true) &lt;: AbstractHamiltonian</code></pre><p>The momentum operator <span>$\hat{p}$</span>.</p><p>The component argument controls which component of the address is taken into consideration. A value of 0 sums the contributions of all components. If <code>fold</code> is true, the momentum is folded into the Brillouin zone.</p><pre><code class="language-julia-repl hljs">julia&gt; add = BoseFS((1, 0, 2, 1, 2, 1, 1, 3))
BoseFS{11,8}(1, 0, 2, 1, 2, 1, 1, 3)

julia&gt; v = DVec(add =&gt; 10);

julia&gt; rayleigh_quotient(Momentum(), DVec(add =&gt; 1))
-2.0

julia&gt; rayleigh_quotient(Momentum(fold=false), DVec(add =&gt; 1))
14.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/Momentum.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.AxialAngularMomentumHO" href="#Rimu.Hamiltonians.AxialAngularMomentumHO"><code>Rimu.Hamiltonians.AxialAngularMomentumHO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AxialAngularMomentumHO(S; z_dim = 3, addr = BoseFS(prod(S))) &lt;: AbstractHamiltonian</code></pre><p>Angular momentum operator for application to Cartesian harmonic oscillator basis, see <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>HOCartesianContactInteractions</code></a> or <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>HOCartesianEnergyConservedPerDim</code></a>. Represents the projection of angular momentum onto <code>z</code>-axis:</p><p class="math-container">\[\hat{L}_z = i \hbar \sum_{j=1}^N \left( b_x b_y^\dag - b_y b_x^\dag \right),\]</p><p>where <span>$b_x^\dag$</span> and <span>$b_x$</span> are raising and lowering (ladder) operators for  a harmonic oscillator in the <span>$x$</span> dimension, and simlarly for <span>$y$</span>.</p><p>This is implemented for an <span>$N$</span> particle Fock space with creation and annihilation operators as</p><p class="math-container">\[\frac{1}{\hbar} \hat{L}_z = i \sum_{n_x=1}^{M_x} \sum_{n_y=1}^{M_y}
    \left( a_{n_x-1,n_y+1}^\dag - a_{n_x+1,n_y-1}^\dag \right) a_{n_x, n_y}.\]</p><p>in units of <span>$\hbar$</span>.</p><p>Argument <code>S</code> is a tuple defining the range of Cartesian modes in each dimension and their mapping to Fock space modes in a <code>SingleComponentFockAddress</code>. If <code>S</code> indicates a 3D system the <code>z</code> dimension can be changed by setting <code>z_dim</code>; <code>S</code> should be be isotropic in the remaining <code>x</code>-<code>y</code> plane, i.e. must have <code>S[x_dim] == S[y_dim]</code>. The starting address <code>addr</code> only needs to satisfy <code>num_modes(addr) == prod(S)</code>.</p><p><strong>Example</strong></p><p>Calculate the overlap of two Fock addresses interpreted as harmonic oscillator states in a 2D Cartesian basis</p><pre><code class="language-julia-repl hljs">julia&gt; S = (2,2)
(2, 2)

julia&gt; Lz = AxialAngularMomentumHO(S)
AxialAngularMomentumHO((2, 2); z_dim = 3, addr = BoseFS{0,4}(0, 0, 0, 0))

julia&gt; v = DVec(BoseFS(prod(S), 2 =&gt; 1) =&gt; 1.0)
DVec{BoseFS{1, 4, BitString{4, 1, UInt8}},Float64} with 1 entry, style = IsDeterministic{Float64}()
  fs&quot;|0 1 0 0⟩&quot; =&gt; 1.0

julia&gt; w = DVec(BoseFS(prod(S), 3 =&gt; 1) =&gt; 1.0)
DVec{BoseFS{1, 4, BitString{4, 1, UInt8}},Float64} with 1 entry, style = IsDeterministic{Float64}()
  fs&quot;|0 0 1 0⟩&quot; =&gt; 1.0

julia&gt; dot(w, Lz, v)
0.0 + 1.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/angular_momentum.jl#L1-L50">source</a></section></article><h2 id="Hamiltonians-interface"><a class="docs-heading-anchor" href="#Hamiltonians-interface">Hamiltonians interface</a><a id="Hamiltonians-interface-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonians-interface" title="Permalink"></a></h2><p>Behind the implementation of a particular model is a more abstract interface for defining Hamiltonians. If you want to define a new model you should make use of this interface. The most general form of a model Hamiltonian should subtype to <code>AbstractHamiltonian</code> and implement the relevant methods.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.AbstractHamiltonian" href="#Rimu.Interfaces.AbstractHamiltonian"><code>Rimu.Interfaces.AbstractHamiltonian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractHamiltonian{T}</code></pre><p>Supertype that provides an interface for linear operators over a linear space with scalar type <code>T</code> that are suitable for FCIQMC (with <a href="API.html#Rimu.lomc!-Tuple{Any, Any}"><code>lomc!</code></a>). Indexing is done with addresses (typically not integers) from an address space that may be large (and will not need to be completely generated).</p><p><code>AbstractHamiltonian</code> instances operate on vectors of type <a href="dictvectors.html#Rimu.Interfaces.AbstractDVec"><code>AbstractDVec</code></a> from the module <code>DictVectors</code> and work well with addresses of type <a href="addresses.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>AbstractFockAddress</code></a> from the module <code>BitStringAddresses</code>. The type works well with the external package <a href="https://github.com/Jutho/KrylovKit.jl">KrylovKit.jl</a>.</p><p>For available implementations see <a href="hamiltonians.html#Rimu.Hamiltonians"><code>Hamiltonians</code></a>.</p><p><strong>Interface</strong></p><p>Basic interface methods to implement:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>starting_address(::AbstractHamiltonian)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.diagonal_element"><code>diagonal_element(::AbstractHamiltonian, address)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>num_offdiagonals(::AbstractHamiltonian, address)</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>get_offdiagonal(::AbstractHamiltonian, address, chosen::Integer)</code></a> (optional, see   below)</li></ul><p>Optional additional methods to implement:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>LOStructure(::Type{typeof(lo)})</code></a>: defaults to <code>AdjointUnknown</code></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>dimension(::AbstractHamiltonian, addr)</code></a>: defaults to dimension of address space</li><li><a href="hamiltonians.html#Rimu.Interfaces.allowed_address_type"><code>allowed_address_type(h::AbstractHamiltonian)</code></a>: defaults to <code>typeof(starting_address(h))</code></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.momentum"><code>momentum(::AbstractHamiltonian)</code></a>: no default</li></ul><p>Provides the following functions and methods:</p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>: iterator over reachable off-diagonal matrix elements</li><li><a href="hamiltonians.html#Rimu.Interfaces.random_offdiagonal"><code>random_offdiagonal</code></a>: function to generate random off-diagonal matrix element</li><li><code>*(H, v)</code>: deterministic matrix-vector multiply (allocating)</li><li><code>H(v)</code>: equivalent to <code>H * v</code>.</li><li><code>mul!(w, H, v)</code>: mutating matrix-vector multiply.</li><li><a href="hamiltonians.html#LinearAlgebra.dot"><code>dot(x, H, v)</code></a>: compute <code>x⋅(H*v)</code> minimizing allocations.</li><li><code>H[address1, address2]</code>: indexing with <code>getindex()</code> - mostly for testing purposes (slow!)</li><li><a href="hamiltonians.html#SparseArrays.sparse"><code>BasisSetRep</code></a>: construct a basis set repesentation</li><li><a href="hamiltonians.html#SparseArrays.sparse"><code>sparse</code></a>, <a href="hamiltonians.html#Base.Matrix"><code>Matrix</code></a>: construct a (sparse) matrix representation</li></ul><p>Alternatively to the above, <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a> can be implemented instead of <a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>get_offdiagonal</code></a>. Sometimes this can be done efficiently. In this case <a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>num_offdiagonals</code></a> should provide an upper bound on the number of elements obtained when iterating <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians"><code>Hamiltonians</code></a>, <a href="API.html#Interfaces"><code>Interfaces</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L4-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.offdiagonals" href="#Rimu.Interfaces.offdiagonals"><code>Rimu.Interfaces.offdiagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offdiagonals(h::AbstractHamiltonian, address)</code></pre><p>Return an iterator over nonzero off-diagonal matrix elements of <code>h</code> in the same column as <code>address</code>. Will iterate over pairs <code>(newaddress, matrixelement)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; address = BoseFS(3,2,1);


julia&gt; H = HubbardReal1D(address);


julia&gt; h = offdiagonals(H, address)
6-element Rimu.Hamiltonians.Offdiagonals{BoseFS{6, 3, BitString{8, 1, UInt8}}, Float64, HubbardReal1D{Float64, BoseFS{6, 3, BitString{8, 1, UInt8}}, 1.0, 1.0}}:
 (fs&quot;|2 3 1⟩&quot;, -3.0)
 (fs&quot;|2 2 2⟩&quot;, -2.449489742783178)
 (fs&quot;|3 1 2⟩&quot;, -2.0)
 (fs&quot;|4 1 1⟩&quot;, -2.8284271247461903)
 (fs&quot;|4 2 0⟩&quot;, -2.0)
 (fs&quot;|3 3 0⟩&quot;, -1.7320508075688772)</code></pre><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p><p><strong>Extemded help</strong></p><p><code>offdiagonals</code> return and iterator of type <code>&lt;:AbstractOffdiagonals</code>. It defaults to returning <code>Offdiagonals(h, a)</code></p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.Offdiagonals"><code>Offdiagonals</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.AbstractOffdiagonals"><code>AbstractOffdiagonals</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L160-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.diagonal_element" href="#Rimu.Interfaces.diagonal_element"><code>Rimu.Interfaces.diagonal_element</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">diagonal_element(ham, address)</code></pre><p>Compute the diagonal matrix element of the linear operator <code>ham</code> at address <code>address</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; address = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(address);


julia&gt; diagonal_element(H, address)
8.666666666666664</code></pre><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L73-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.starting_address" href="#Rimu.Interfaces.starting_address"><code>Rimu.Interfaces.starting_address</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">starting_address(h)</code></pre><p>Return the starting address for Hamiltonian <code>h</code>. When called on an <code>AbstractMatrix</code>, <code>starting_address</code> returns the index of the lowest diagonal element.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; address = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(address);


julia&gt; address == starting_address(H)
true</code></pre><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L137-L157">source</a></section></article><p>The following functions may be implemented instead of <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.num_offdiagonals" href="#Rimu.Interfaces.num_offdiagonals"><code>Rimu.Interfaces.num_offdiagonals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_offdiagonals(ham, address)</code></pre><p>Compute the number of number of reachable configurations from address <code>address</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; address = BoseFS((3, 2, 1));


julia&gt; H = HubbardMom1D(address);


julia&gt; num_offdiagonals(H, address)
10</code></pre><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L95-L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.get_offdiagonal" href="#Rimu.Interfaces.get_offdiagonal"><code>Rimu.Interfaces.get_offdiagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">newadd, me = get_offdiagonal(ham, add, chosen)</code></pre><p>Compute value <code>me</code> and new address <code>newadd</code> of a single (off-diagonal) matrix element in a Hamiltonian <code>ham</code>. The off-diagonal element is in the same column as address <code>add</code> and is indexed by integer index <code>chosen</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; addr = BoseFS(3, 2, 1);

julia&gt; H = HubbardMom1D(addr);

julia&gt; get_offdiagonal(H, addr, 3)
(BoseFS{6,3}(2, 1, 3), 1.0)</code></pre><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L116-L134">source</a></section></article><p>The following functions come with default implementations, but may be customized.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.random_offdiagonal" href="#Rimu.Interfaces.random_offdiagonal"><code>Rimu.Interfaces.random_offdiagonal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_offdiagonal(offdiagonals::AbstractOffdiagonals)
random_offdiagonal(ham::AbstractHamiltonian, add)</code></pre><p>Generate a single random excitation, i.e. choose from one of the accessible off-diagonal elements in the column corresponding to address <code>add</code> of the Hamiltonian matrix represented by <code>ham</code>. Alternatively, pass as argument an iterator over the accessible matrix elements.</p><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L202-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.LOStructure" href="#Rimu.Interfaces.LOStructure"><code>Rimu.Interfaces.LOStructure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LOStructure(op::AbstractHamiltonian)
LOStructure(typeof(op))</code></pre><p>Return information about the structure of the linear operator <code>op</code>. <code>LOStructure</code> is used as a trait to speficy symmetries or other properties of the linear operator <code>op</code> that may simplify or speed up calculations. Implemented instances are:</p><ul><li><code>IsDiagonal()</code>: The operator is diagonal.</li><li><code>IsHermitian()</code>: The operator is complex and Hermitian or real and symmetric.</li><li><code>AdjointKnown()</code>: The operator is not Hermitian, but its   <a href="hamiltonians.html#Base.adjoint"><code>adjoint</code></a> is implemented.</li><li><code>AdjointUnknown()</code>: <a href="hamiltonians.html#Base.adjoint"><code>adjoint</code></a> for this operator is not   implemented.</li></ul><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p><p>In order to define this trait for a new linear operator type, define a method for <code>LOStructure(::Type{&lt;:MyNewLOType}) = …</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L223-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.dimension" href="#Rimu.Hamiltonians.dimension"><code>Rimu.Hamiltonians.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dimension(h::AbstractHamiltonian, addr=starting_address(h))
dimension(addr::AbstractFockAddress)
dimension(::Type{&lt;:AbstractFockAddress})</code></pre><p>Return the estimated dimension of Hilbert space. May return a <code>BigInt</code> number.</p><p>When called on an address or address type, the dimension of the linear space spanned by the address type is returned. When called on an <code>AbstractHamiltonian</code>, an upper bound on the dimension of the matrix representing the Hamiltonian is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dimension(OccupationNumberFS(1,2,3))
16777216

julia&gt; dimension(HubbardReal1D(OccupationNumberFS(1,2,3)))
28

julia&gt; dimension(BoseFS{200,100})
1386083821086188248261127842108801860093488668581216236221011219101585442774669540

julia&gt; Float64(ans)
1.3860838210861882e81</code></pre><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface. See also <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a>.</p><p><strong>Extended Help</strong></p><p>The default fallback for <code>dimension</code> called on an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> is to return the dimension of the address space, which provides an upper bound. For new Hamiltonians a tighter bound can be provided by defining a custom method.</p><p>When extending <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>, define a method for the two-argument form <code>dimension(h::MyNewHamiltonian, addr)</code>. For number-conserving Hamiltonians, the function <a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_dimension"><code>Hamiltonians.number_conserving_dimension</code></a> may be useful.</p><p>When extending <a href="addresses.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>AbstractFockAddress</code></a>, define a method for <code>dimension(::Type{MyNewFockAddress})</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L22-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.has_adjoint" href="#Rimu.Interfaces.has_adjoint"><code>Rimu.Interfaces.has_adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_adjoint(op)</code></pre><p>Return true if <code>adjoint</code> is defined on <code>op</code>.</p><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p><p>See also <a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>LOStructure</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L255-L263">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Interfaces.allowed_address_type" href="#Rimu.Interfaces.allowed_address_type"><code>Rimu.Interfaces.allowed_address_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allowed_address_type(h::AbstractHamiltonian)</code></pre><p>Return the type of addresses that can be used with Hamiltonian <code>h</code>.</p><p>Part of the <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a> interface.</p><p>Defaults to <code>typeof(starting_address(h))</code>. Overload this function if the Hamiltonian can be used with addresses of different types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Interfaces/hamiltonians.jl#L61-L69">source</a></section></article><p>This interface relies on unexported functionality, including</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.adjoint" href="#Base.adjoint"><code>Base.adjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adjoint(::LOStructure, op::AbstractHamiltonian)</code></pre><p>Represent the adjoint of an <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>. Extend this method to define custom adjoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L665-L670">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.dot" href="#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dot(w, op::AbstractHamiltonian, v)</code></pre><p>Evaluate <code>w⋅op(v)</code> minimizing memory allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/DictVectors/abstractdvec.jl#L273-L277">source</a></section><section><div><pre><code class="language-julia hljs">dot(y::PDVec, A::AbstractHamiltonian, x::PDVec[, w::PDWorkingMemory])</code></pre><p>Perform <code>y ⋅ A ⋅ x</code>. The working memory <code>w</code> is required to facilitate threaded/distributed operations with non-diagonal <code>A</code>. If needed and not passed a new instance will be allocated. <code>A</code> can be replaced with a tuple of operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/DictVectors/pdvec.jl#L756-L762">source</a></section><section><div><pre><code class="language-julia hljs">dot(map::OccupiedModeMap, vec::AbstractVector)
dot(map1::OccupiedModeMap, map2::OccupiedModeMap)</code></pre><p>Dot product extracting mode occupation numbers from an <a href="addresses.html#Rimu.BitStringAddresses.OccupiedModeMap"><code>OccupiedModeMap</code></a> similar to <a href="addresses.html#Rimu.BitStringAddresses.onr"><code>onr</code></a>.</p><pre><code class="language-julia-repl hljs">julia&gt; b = BoseFS(10, 0, 0, 0, 2, 0, 1)
BoseFS{13,7}(10, 0, 0, 0, 2, 0, 1)

julia&gt; mb = OccupiedModeMap(b)
3-element OccupiedModeMap{7, BoseFSIndex}:
 BoseFSIndex(occnum=10, mode=1, offset=0)
 BoseFSIndex(occnum=2, mode=5, offset=14)
 BoseFSIndex(occnum=1, mode=7, offset=18)

julia&gt; dot(mb, 1:7)
27

julia&gt; mb⋅(1:7) == onr(b)⋅(1:7)
true</code></pre><p>See also <a href="addresses.html#Rimu.BitStringAddresses.SingleComponentFockAddress"><code>SingleComponentFockAddress</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/BitStringAddresses/fockaddress.jl#L289-L312">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.AbstractOffdiagonals" href="#Rimu.Hamiltonians.AbstractOffdiagonals"><code>Rimu.Hamiltonians.AbstractOffdiagonals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractOffdiagonals{A,T}&lt;:AbstractVector{Tuple{A,T}}</code></pre><p>Iterator over new address and matrix elements for reachable off-diagonal matrix elements of a linear operator.</p><p>See <a href="hamiltonians.html#Rimu.Hamiltonians.Offdiagonals"><code>Offdiagonals</code></a> for a default implementation.</p><p><strong>Methods to define</strong></p><ul><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals(h, a)::AbstractOffdiagonals</code></a>: This function is used to construct the correct type of offdiagonals for a given combination of Hamiltonian <code>h</code> and Fock address <code>a</code>.</li><li><code>Base.getindex(::AbstractOffdiagonals, i)</code>: should be equivalent to <code>get_offdiagonal(h, a, i)</code>.</li><li><code>Base.size(::AbstractOffdiagonals)</code>: should be equivalent to <code>num_offdiagonals(h, a)</code>.</li></ul><p>See also <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>, <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/offdiagonals.jl#L4-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.Offdiagonals" href="#Rimu.Hamiltonians.Offdiagonals"><code>Rimu.Hamiltonians.Offdiagonals</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Offdiagonals(h, address) &lt;: AbstractOffdiagonals</code></pre><p>Iterator over new address and matrix element for reachable off-diagonal matrix elements of linear operator <code>h</code> from address <code>address</code>.  Represents an abstract vector containing the non-zero off-diagonal matrix elements of the column of <code>h</code> indexed by <code>address</code>. To construct this iterator use <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>.</p><p>This is the default implementation of <a href="hamiltonians.html#Rimu.Hamiltonians.AbstractOffdiagonals"><code>AbstractOffdiagonals</code></a> defined in terms of <a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>num_offdiagonals</code></a> and <a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>get_offdiagonal</code></a>.</p><p>See also <a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>offdiagonals</code></a>, <a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>AbstractHamiltonian</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/offdiagonals.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.check_address_type" href="#Rimu.Hamiltonians.check_address_type"><code>Rimu.Hamiltonians.check_address_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_address_type(h::AbstractHamiltonian, addr_or_type)</code></pre><p>Throw an <code>ArgumentError</code> if <code>addr_or_type</code> is not compatible with <code>h</code>. Acceptable arguments are either an address or an address type, or a tuple or array thereof.</p><p>See also <a href="hamiltonians.html#Rimu.Interfaces.allowed_address_type"><code>allowed_address_type</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.number_conserving_dimension" href="#Rimu.Hamiltonians.number_conserving_dimension"><code>Rimu.Hamiltonians.number_conserving_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_conserving_dimension(address &lt;: AbstractFockAddress)</code></pre><p>Return the dimension of the Fock space spanned by the address type assuming particle number conservation.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_bose_dimension"><code>number_conserving_bose_dimension</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_fermi_dimension"><code>number_conserving_fermi_dimension</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>dimension</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L119-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.number_conserving_bose_dimension" href="#Rimu.Hamiltonians.number_conserving_bose_dimension"><code>Rimu.Hamiltonians.number_conserving_bose_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_conserving_bose_dimension(n, m)</code></pre><p>Return the dimension of the number-conserving Fock space for <code>n</code> bosons in <code>m</code> modes: <code>binomial(n + m - 1, n)</code>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_fermi_dimension"><code>number_conserving_fermi_dimension</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_dimension"><code>number_conserving_dimension</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L100-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.number_conserving_fermi_dimension" href="#Rimu.Hamiltonians.number_conserving_fermi_dimension"><code>Rimu.Hamiltonians.number_conserving_fermi_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">number_conserving_fermi_dimension(n, m)</code></pre><p>Return the dimension of the number-conserving Fock space for <code>n</code> fermions in <code>m</code> modes: <code>binomial(m, n)</code>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_bose_dimension"><code>number_conserving_bose_dimension</code></a>, <a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_dimension"><code>number_conserving_dimension</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/abstract.jl#L109-L116">source</a></section></article><h2 id="Geometry"><a class="docs-heading-anchor" href="#Geometry">Geometry</a><a id="Geometry-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry" title="Permalink"></a></h2><p>Lattices in higher dimensions are defined here for <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.LatticeGeometry" href="#Rimu.Hamiltonians.LatticeGeometry"><code>Rimu.Hamiltonians.LatticeGeometry</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type LatticeGeometry{D}</code></pre><p>A <code>LatticeGeometry</code> controls which sites in an <a href="addresses.html#Rimu.BitStringAddresses.AbstractFockAddress"><code>AbstractFockAddress</code></a> are considered to be neighbours.</p><p>Currently only supported by <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><p><strong>Available implementations</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul><p><strong>Interface to implement</strong></p><ul><li><code>Base.size</code>: return the lattice size.</li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site(::LatticeGeometry, ::Int, ::Int)</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_dimensions"><code>num_dimensions(::LatticeGeometry)</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>num_neighbours(::LatticeGeometry)</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/geometry.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.PeriodicBoundaries" href="#Rimu.Hamiltonians.PeriodicBoundaries"><code>Rimu.Hamiltonians.PeriodicBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PeriodicBoundaries(size...) &lt;: LatticeGeometry</code></pre><p>Rectangular lattice with periodic boundary conditions of size <code>size</code>.</p><p>The dimension of the lattice is controlled by the number of arguments given to its constructor.</p><p>This is the default geometry used by <a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>HubbardRealSpace</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = PeriodicBoundaries(5, 4) # 2D lattice of size 5 × 4
PeriodicBoundaries(5, 4)

julia&gt; num_neighbours(lattice)
4

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
5

julia&gt; neighbour_site(lattice, 1, 3)
6

julia&gt; neighbour_site(lattice, 1, 4)
16</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>num_neighbours</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/geometry.jl#L67-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.HardwallBoundaries" href="#Rimu.Hamiltonians.HardwallBoundaries"><code>Rimu.Hamiltonians.HardwallBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HardwallBoundaries</code></pre><p>Rectangular lattice with hard wall boundary conditions of size <code>size</code>. <a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site()</code></a> will return 0 for some neighbours of boundary sites.</p><p>The dimension of the lattice is controlled by the number of arguments given to its constructor.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = HardwallBoundaries(5) # 1D lattice of size 5
HardwallBoundaries(5)

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
0
</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>LadderBoundaries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/geometry.jl#L136-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.LadderBoundaries" href="#Rimu.Hamiltonians.LadderBoundaries"><code>Rimu.Hamiltonians.LadderBoundaries</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LadderBoundaries(size...; subgeometry=PeriodicBoundaries) &lt;: LatticeGeometry</code></pre><p>Lattice geometry where the first dimension is of size 2 and has hardwall boundary conditions. Using this geometry is more efficient than using <a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a> with a size of 2, as it does not generate rejected neighbours.</p><p>In other dimensions, it behaves like its subgeometry, which can be any <a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">julia&gt; lattice = LadderBoundaries(2, 3, 4) # 3D lattice of size 2 × 3 × 4
LadderBoundaries(2, 3, 4)

julia&gt; num_neighbours(lattice)
5

julia&gt; neighbour_site(lattice, 1, 1)
2

julia&gt; neighbour_site(lattice, 1, 2)
3

julia&gt; neighbour_site(lattice, 1, 3)
5

julia&gt; neighbour_site(lattice, 1, 4)
7

julia&gt; neighbour_site(lattice, 1, 5)
19</code></pre><p><strong>See also</strong></p><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>HardwallBoundaries</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/geometry.jl#L190-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.num_neighbours" href="#Rimu.Hamiltonians.num_neighbours"><code>Rimu.Hamiltonians.num_neighbours</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_neighbours(geom::LatticeGeometry)</code></pre><p>Return the number of neighbours each lattice site has in this geometry.</p><p>Note that for efficiency reasons, all sites are expected to have the same number of neighbours. If some of the neighbours are invalid, this is handled by having <a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>neighbour_site</code></a> return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/geometry.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.num_dimensions" href="#Rimu.Hamiltonians.num_dimensions"><code>Rimu.Hamiltonians.num_dimensions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_dimensions(geom::LatticeGeometry)</code></pre><p>Return the number of dimensions of the lattice in this geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/geometry.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.neighbour_site" href="#Rimu.Hamiltonians.neighbour_site"><code>Rimu.Hamiltonians.neighbour_site</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neighbour_site(geom::LatticeGeometry, site, i)</code></pre><p>Find the <code>i</code>-th neighbour of <code>site</code> in the geometry. If the move is illegal, return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/geometry.jl#L41-L45">source</a></section></article><h2 id="Harmonic-Oscillator"><a class="docs-heading-anchor" href="#Harmonic-Oscillator">Harmonic Oscillator</a><a id="Harmonic-Oscillator-1"></a><a class="docs-heading-anchor-permalink" href="#Harmonic-Oscillator" title="Permalink"></a></h2><p>Useful utilities for harmonic oscillator in Cartesian basis, see <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>HOCartesianContactInteractions</code></a>  and <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>HOCartesianEnergyConservedPerDim</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.get_all_blocks" href="#Rimu.Hamiltonians.get_all_blocks"><code>Rimu.Hamiltonians.get_all_blocks</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_all_blocks(h::Union{HOCartesianContactInteractions,HOCartesianEnergyConservedPerDim}; 
    target_energy = nothing, 
    max_energy = nothing, 
    max_blocks = nothing, 
    method = :vertices,
    kwargs...) -&gt; df</code></pre><p>Find all distinct blocks of <code>h</code>. Returns a <code>DataFrame</code> with columns </p><ul><li><code>block_id</code>: index of block in order found</li><li><code>block_E0</code>: noninteracting energy of all elements in the block</li><li><code>block_size</code>: number of elements in the block</li><li><code>addr</code>: first address that generates the block with e.g. <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a></li><li><code>indices</code>: tuple of mode indices that allow recreation of the generating address    <code>addr</code>; in this case use e.g. <code>BoseFS(M; indices .=&gt; 1)</code> This is useful when    the <code>DataFrame</code> is loaded from file since <code>Arrow.jl</code> converts custom   types to <code>NamedTuple</code>s.</li><li><code>t_basis</code>: time to generate the basis for each block</li></ul><p>Keyword arguments:</p><ul><li><code>target_energy</code>: only blocks with this noninteracting energy are found</li><li><code>max_energy</code>: only blocks with noninteracting energy less than this are found</li><li><code>max_blocks</code>: exit after finding this many blocks</li><li><code>method</code>: Choose between <code>:vertices</code> and <code>:comb</code> for method of enumerating    tuples of quantum numbers</li><li><code>save_to_file=nothing</code>: if set then the <code>DataFrame</code> recording blocks is saved    after each new block is found</li><li>additional <code>kwargs</code>: passed to <code>isapprox</code> for comparing block energies.    Useful for anisotropic traps</li></ul><p>Note: If <code>h</code> was constructed with option <code>block_by_level = false</code> then the block seeds  <code>addr</code> are determined by parity. In this case the blocks are not generated; <code>t_basis</code>  will be zero, and <code>block_size</code> will be an estimate. Pass the seed addresses to  <a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>BasisSetRep</code></a> with an appropriate <code>filter</code> to generate the blocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/ho-cart-tools.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.fock_to_cart" href="#Rimu.Hamiltonians.fock_to_cart"><code>Rimu.Hamiltonians.fock_to_cart</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fock_to_cart(addr, S; zero_index = true)</code></pre><p>Convert a Fock state address <code>addr</code> to Cartesian harmonic oscillator basis  indices <span>$n_x,n_y,\ldots$</span>. These indices are bounded by <code>S</code> which is a  tuple of the maximum number of states in each dimension. By default the  groundstate in each dimension is indexed by <code>0</code>, but this can be changed  by setting <code>zero_index = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/ho-cart-tools.jl#L210-L218">source</a></section></article><p>Underlying integrals for the interaction matrix elements are implemented in the following unexported functions</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.four_oscillator_integral_general" href="#Rimu.Hamiltonians.four_oscillator_integral_general"><code>Rimu.Hamiltonians.four_oscillator_integral_general</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">four_oscillator_integral_general(i, j, k, l; max_level = typemax(Int))</code></pre><p>Integral of four one-dimensional harmonic oscillator functions, </p><p class="math-container">\[    \mathcal{I}(i,j,k,l) = \int_{-\infty}^\infty dx \, 
    \phi_i(x) \phi_j(x) \phi_k(x) \phi_l(x)\]</p><p>Indices <code>i,j,k,l</code> start at <code>0</code> for the groundstate.</p><p>This integral has a closed form in terms of the hypergeometric <span>$_{3}F_2$</span> function,  and is non-zero unless <span>$i+j+k+l$</span> is odd. See e.g.  <a href="https://doi.org/10.1112/jlms/s1-23.1.15">Titchmarsh (1948)</a>. This is a generalisation of the closed form in  <a href="https://doi.org/10.1103/PhysRevA.65.033606">Papenbrock (2002)</a>, which is is the special  case where <span>$i+j == k+l$</span>, but is numerically unstable for large arguments. Used in <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>HOCartesianContactInteractions</code></a> and <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>HOCartesianEnergyConservedPerDim</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HOCartesianContactInteractions.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.ho_delta_potential" href="#Rimu.Hamiltonians.ho_delta_potential"><code>Rimu.Hamiltonians.ho_delta_potential</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ho_delta_potential(S, i, j; [vals])</code></pre><p>Returns the matrix element of a delta potential at the centre of a trap, i.e. the  product of two harmonic oscillator functions evaluated at the origin, </p><p class="math-container">\[    v_{ij} = \phi_{\mathbf{n}_i}(0) \phi_{\mathbf{n}_j}(0)\]</p><p>which is only non-zero for even-parity states. The <code>i</code>th single particle state  corresponds to a <span>$D$</span>-tuple of harmonic oscillator indices <span>$\mathbf{n}_i$</span>.  <code>S</code> defines the bounds of Cartesian harmonic oscillator indices for each dimension. The optional keyword argument <code>vals</code> allows passing pre-computed values of  <span>$\phi_i(0)$</span> to speed-up the calculation. The values can be calculated with  <a href="hamiltonians.html#Rimu.Hamiltonians.log_abs_oscillator_zero"><code>log_abs_oscillator_zero</code></a>.</p><p>See also <a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianCentralImpurity"><code>HOCartesianCentralImpurity</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HOCartesianCentralImpurity.jl#L16-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Rimu.Hamiltonians.log_abs_oscillator_zero" href="#Rimu.Hamiltonians.log_abs_oscillator_zero"><code>Rimu.Hamiltonians.log_abs_oscillator_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">log_abs_oscillator_zero(n)</code></pre><p>Compute the logarithm of the absolute value of the <span>$n^\mathrm{th}$</span> 1D  harmonic oscillator function evaluated at the origin. The overall sign is determined when the matrix element is evaluated in <a href="hamiltonians.html#Rimu.Hamiltonians.ho_delta_potential"><code>ho_delta_potential</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/joachimbrand/Rimu.jl/blob/5ba2d2e553563958f24759a25b17c42a29fe16aa/src/Hamiltonians/HOCartesianCentralImpurity.jl#L1-L7">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="hamiltonians.html#Rimu.Hamiltonians"><code>Rimu.Hamiltonians</code></a></li><li><a href="hamiltonians.html#Base.Matrix"><code>Base.Matrix</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AbstractOffdiagonals"><code>Rimu.Hamiltonians.AbstractOffdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.AxialAngularMomentumHO"><code>Rimu.Hamiltonians.AxialAngularMomentumHO</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BasisSetRep"><code>Rimu.Hamiltonians.BasisSetRep</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardMom1D2C"><code>Rimu.Hamiltonians.BoseHubbardMom1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.BoseHubbardReal1D2C"><code>Rimu.Hamiltonians.BoseHubbardReal1D2C</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.DensityMatrixDiagonal"><code>Rimu.Hamiltonians.DensityMatrixDiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ExtendedHubbardReal1D"><code>Rimu.Hamiltonians.ExtendedHubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.FroehlichPolaron"><code>Rimu.Hamiltonians.FroehlichPolaron</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2MomCorrelator"><code>Rimu.Hamiltonians.G2MomCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.G2RealCorrelator"><code>Rimu.Hamiltonians.G2RealCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.GuidingVectorSampling"><code>Rimu.Hamiltonians.GuidingVectorSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.GutzwillerSampling"><code>Rimu.Hamiltonians.GutzwillerSampling</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianCentralImpurity"><code>Rimu.Hamiltonians.HOCartesianCentralImpurity</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianContactInteractions"><code>Rimu.Hamiltonians.HOCartesianContactInteractions</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim"><code>Rimu.Hamiltonians.HOCartesianEnergyConservedPerDim</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HardwallBoundaries"><code>Rimu.Hamiltonians.HardwallBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1D"><code>Rimu.Hamiltonians.HubbardMom1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardMom1DEP"><code>Rimu.Hamiltonians.HubbardMom1DEP</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1D"><code>Rimu.Hamiltonians.HubbardReal1D</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardReal1DEP"><code>Rimu.Hamiltonians.HubbardReal1DEP</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.HubbardRealSpace"><code>Rimu.Hamiltonians.HubbardRealSpace</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LadderBoundaries"><code>Rimu.Hamiltonians.LadderBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.LatticeGeometry"><code>Rimu.Hamiltonians.LatticeGeometry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.MatrixHamiltonian"><code>Rimu.Hamiltonians.MatrixHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Momentum"><code>Rimu.Hamiltonians.Momentum</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Offdiagonals"><code>Rimu.Hamiltonians.Offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ParitySymmetry"><code>Rimu.Hamiltonians.ParitySymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.PeriodicBoundaries"><code>Rimu.Hamiltonians.PeriodicBoundaries</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Stoquastic"><code>Rimu.Hamiltonians.Stoquastic</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.StringCorrelator"><code>Rimu.Hamiltonians.StringCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.SuperfluidCorrelator"><code>Rimu.Hamiltonians.SuperfluidCorrelator</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.TimeReversalSymmetry"><code>Rimu.Hamiltonians.TimeReversalSymmetry</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.Transcorrelated1D"><code>Rimu.Hamiltonians.Transcorrelated1D</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.AbstractHamiltonian"><code>Rimu.Interfaces.AbstractHamiltonian</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.LOStructure"><code>Rimu.Interfaces.LOStructure</code></a></li><li><a href="hamiltonians.html#Base.adjoint"><code>Base.adjoint</code></a></li><li><a href="hamiltonians.html#LinearAlgebra.dot"><code>LinearAlgebra.dot</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.build_basis"><code>Rimu.Hamiltonians.build_basis</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.check_address_type"><code>Rimu.Hamiltonians.check_address_type</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.continuum_dispersion"><code>Rimu.Hamiltonians.continuum_dispersion</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.dimension"><code>Rimu.Hamiltonians.dimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.fock_to_cart"><code>Rimu.Hamiltonians.fock_to_cart</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.four_oscillator_integral_general"><code>Rimu.Hamiltonians.four_oscillator_integral_general</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.get_all_blocks"><code>Rimu.Hamiltonians.get_all_blocks</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.ho_delta_potential"><code>Rimu.Hamiltonians.ho_delta_potential</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.hubbard_dispersion"><code>Rimu.Hamiltonians.hubbard_dispersion</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.log_abs_oscillator_zero"><code>Rimu.Hamiltonians.log_abs_oscillator_zero</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.momentum"><code>Rimu.Hamiltonians.momentum</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.neighbour_site"><code>Rimu.Hamiltonians.neighbour_site</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_dimensions"><code>Rimu.Hamiltonians.num_dimensions</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.num_neighbours"><code>Rimu.Hamiltonians.num_neighbours</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_bose_dimension"><code>Rimu.Hamiltonians.number_conserving_bose_dimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_dimension"><code>Rimu.Hamiltonians.number_conserving_dimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.number_conserving_fermi_dimension"><code>Rimu.Hamiltonians.number_conserving_fermi_dimension</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.rayleigh_quotient"><code>Rimu.Hamiltonians.rayleigh_quotient</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice"><code>Rimu.Hamiltonians.shift_lattice</code></a></li><li><a href="hamiltonians.html#Rimu.Hamiltonians.shift_lattice_inv"><code>Rimu.Hamiltonians.shift_lattice_inv</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.allowed_address_type"><code>Rimu.Interfaces.allowed_address_type</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.diagonal_element"><code>Rimu.Interfaces.diagonal_element</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.get_offdiagonal"><code>Rimu.Interfaces.get_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.has_adjoint"><code>Rimu.Interfaces.has_adjoint</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.num_offdiagonals"><code>Rimu.Interfaces.num_offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.offdiagonals"><code>Rimu.Interfaces.offdiagonals</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.random_offdiagonal"><code>Rimu.Interfaces.random_offdiagonal</code></a></li><li><a href="hamiltonians.html#Rimu.Interfaces.starting_address"><code>Rimu.Interfaces.starting_address</code></a></li><li><a href="hamiltonians.html#SparseArrays.sparse"><code>SparseArrays.sparse</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="interfaces.html">« Interfaces</a><a class="docs-footer-nextpage" href="dictvectors.html">Dict vectors »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 31 March 2024 09:21">Sunday 31 March 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
